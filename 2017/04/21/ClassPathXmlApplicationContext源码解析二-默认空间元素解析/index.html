<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="分享高质量Tomcat Spring SpringMCV Kafka 高并发相关技术博客"><meta name="keywords" content="Tomcat Spring AMQ Kafka Zookeeper"><title>ClassPathXmlApplicationContext源码解析二:默认空间元素解析 | The Fourty Thieves</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.0"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.0"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ClassPathXmlApplicationContext源码解析二:默认空间元素解析</h1><a id="logo" href="/.">The Fourty Thieves</a><p class="description">窈窕淑女，君子好逑。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索..."></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">ClassPathXmlApplicationContext源码解析二:默认空间元素解析</h1><div class="post-meta"><span class="date">Apr 21, 2017</span><span class="category"><a href="/categories/Spring源码分析/">Spring源码分析</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i> Hits</i></i></span><a href="/2017/04/21/ClassPathXmlApplicationContext源码解析二-默认空间元素解析/#comments" class="comment-count"><i class="cloud-tie-join-count"><i class="join-count">0</i></i> 留言</a></div><div class="post-content"><p><strong>写在前面</strong><br>在 <a href="http://www.sunmingshuai.cn/2017/04/17/ClassPathXmlApplicationContext%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%80/" target="_blank" rel="external">ClassPathXmlApplicationContext源码解析一</a> 中 我们用了很长的篇幅 介绍了加载上下文环境前的各种准备工作 spring是个世界级的项目框架 由精英团队打造 全世界的<strong><em>测试人员</em></strong>测试 即使如果读者感觉有点吃力 对突然冒出来的代码有点不习惯的话 也不要气馁 继续往下读 刚阅读源代码的时候 最怕纠结于一些琐碎单却不重要的事情</p>
<p>下面我们看一下<code>parseBeanDefinitions(root, this.delegate)</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//对于`delegate`  我们暂时只要知道这个类中含有我们需要的一些environment,beanfactory等信息就可以了 当然他还提供一些解析方法</div><div class="line">	protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</div><div class="line">		/**</div><div class="line">		 * 如果是默认命名空间 也就是&quot;http://www.springframework.org/schema/beans&quot;这个空间下的元素 调用parseDefaultElement</div><div class="line">		 * 否则调用parseCustomElement 例如aop context tx等标签的解析</div><div class="line">		 * 也就是parseDefaultElement 解析import alias bean beans标签元素</div><div class="line">		 * parseCustomElement 解析aop context tx 或者是用户自定义命名空间的元素</div><div class="line">		 */</div><div class="line">		if (delegate.isDefaultNamespace(root)) &#123;</div><div class="line">			NodeList nl = root.getChildNodes();</div><div class="line">			for (int i = 0; i &lt; nl.getLength(); i++) &#123;</div><div class="line">				Node node = nl.item(i);</div><div class="line">				if (node instanceof Element) &#123;</div><div class="line">					Element ele = (Element) node;</div><div class="line">					if (delegate.isDefaultNamespace(ele)) &#123;</div><div class="line">					//继续这个方法研究</div><div class="line">						parseDefaultElement(ele, delegate);</div><div class="line">					&#125;</div><div class="line">					else &#123;</div><div class="line">						delegate.parseCustomElement(ele);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			delegate.parseCustomElement(root);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>我们这篇文章只看默认命名空间的解析 也就是<code>http://www.springframework.org/schema/beans</code>这个空间下的定义的元素定义 对于非默认空间下的元素的解析的话 请看<a href="http://www.sunmingshuai.cn/2017/04/18/component-scan%E5%81%9A%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/" target="_blank" rel="external">component-scan做了些什么</a> 这篇文章讲解了<code>component</code>空间下的元素解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</div><div class="line">	//解析import元素标签 通过调用`loadBeanDefinitions`模块方法完成元素加载&lt;import resource=&quot;url&quot;/&gt;</div><div class="line">	if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</div><div class="line">		importBeanDefinitionResource(ele);</div><div class="line">	&#125;</div><div class="line">	//解析alias元素标签 &lt;alias name=&quot;&quot; alias=&quot;&quot; /&gt;</div><div class="line">	else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</div><div class="line">		//注册别名 说白点就是把name alias的对应关系加入到一个map中</div><div class="line">		processAliasRegistration(ele);</div><div class="line">	&#125;</div><div class="line">	//解析bean元素标签 最核心 &lt;bean &gt;</div><div class="line">	else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</div><div class="line">		processBeanDefinition(ele, delegate);</div><div class="line">	&#125;</div><div class="line">	//解析beans元素标签 又调用了`doRegisterBeanDefinitions(element)`方法去解析&lt;beans&gt;</div><div class="line">	else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</div><div class="line">		// recurse</div><div class="line">		doRegisterBeanDefinitions(ele);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到达这个方法的时候 <code>ele</code>代表的就是一个<code>bean</code>标签元素了 例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</div></pre></td></tr></table></figure></p>
<p>我们不必深入了解xml文档的解析 也是能看的懂的 当然如果了解解析的过程 是更好的了<br>我们可以很清晰的看到<code>beans</code>空间下的元素标签有<code>import</code> <code>alias</code> <code>bean</code> <code>beans</code> 我们当然是重点讲解<code>bean</code>标签的解析了 继续跟踪代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</div><div class="line">//继续跟踪</div><div class="line">	BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</div><div class="line">	if (bdHolder != null) &#123;</div><div class="line">		//处理非默认命名空间的元素 如果有的话 这里不继续跟踪下去了</div><div class="line">		bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</div><div class="line">		try &#123;</div><div class="line">			// 也就是放到一个map中去 key为beanName value为BeanDefinition</div><div class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</div><div class="line">		&#125;</div><div class="line">		catch (BeanDefinitionStoreException ex) &#123;</div><div class="line">			getReaderContext().error(&quot;Failed to register bean definition with name &apos;&quot; +</div><div class="line">					bdHolder.getBeanName() + &quot;&apos;&quot;, ele, ex);</div><div class="line">		&#125;</div><div class="line">		// Send registration event.</div><div class="line">		getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>跟踪进<code>BeanDefinitionParserDelegate.parseBeanDefinitionElement</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123;</div><div class="line">	String id = ele.getAttribute(ID_ATTRIBUTE);</div><div class="line">	String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</div><div class="line"></div><div class="line">	//bean标签中的name其实会被划分成alias</div><div class="line">	List&lt;String&gt; aliases = new ArrayList&lt;String&gt;();</div><div class="line">	if (StringUtils.hasLength(nameAttr)) &#123;</div><div class="line">		String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</div><div class="line">		aliases.addAll(Arrays.asList(nameArr));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	String beanName = id;</div><div class="line">	if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</div><div class="line">		beanName = aliases.remove(0);</div><div class="line">		if (logger.isDebugEnabled()) &#123;</div><div class="line">			logger.debug(&quot;No XML &apos;id&apos; specified - using &apos;&quot; + beanName +</div><div class="line">					&quot;&apos; as bean name and &quot; + aliases + &quot; as aliases&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (containingBean == null) &#123;</div><div class="line">		//beanName唯一性校验</div><div class="line">		checkNameUniqueness(beanName, aliases, ele);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);//GenericBeanDefinition</div><div class="line">	if (beanDefinition != null) &#123;</div><div class="line">		// 阅读源代码要做到有的放矢 像下面这样的代码就没有太大的必要去看了</div><div class="line">		if (!StringUtils.hasText(beanName)) &#123;</div><div class="line">			try &#123;</div><div class="line">				if (containingBean != null) &#123;</div><div class="line">					beanName = BeanDefinitionReaderUtils.generateBeanName(</div><div class="line">							beanDefinition, this.readerContext.getRegistry(), true);</div><div class="line">				&#125;</div><div class="line">				else &#123;</div><div class="line">					beanName = this.readerContext.generateBeanName(beanDefinition);</div><div class="line">					String beanClassName = beanDefinition.getBeanClassName();</div><div class="line">					if (beanClassName != null &amp;&amp;</div><div class="line">							beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</div><div class="line">							!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</div><div class="line">						aliases.add(beanClassName);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				if (logger.isDebugEnabled()) &#123;</div><div class="line">					logger.debug(&quot;Neither XML &apos;id&apos; nor &apos;name&apos; specified - &quot; +</div><div class="line">							&quot;using generated bean name [&quot; + beanName + &quot;]&quot;);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			catch (Exception ex) &#123;</div><div class="line">				error(ex.getMessage(), ele);</div><div class="line">				return null;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		//返回BeanDefinitionHolder</div><div class="line">		String[] aliasesArray = StringUtils.toStringArray(aliases);</div><div class="line">		return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>id</code> 就是<code>beanName</code>了 必须要唯一才行 其实<code>parseBeanDefinitionElement</code>这个方法的目的就很明确了 就是要把<code>bean</code>的配置读取并保存起来 保存到<code>GenericBeanDefinition</code>中 例如我们常见的<code>property</code> <code>constructor-arg</code>等 无非就是构造合适的结构 然后读取数据并保存起来 供以后使用 虽然目的明确 但过程确实是很繁琐的 因为<code>spring</code>支持多种复杂数据结构 例如list map等<br>我们就不再深入解读了 读者可以自己找几个解析方法阅读<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 在这个方法中会遇到我们之前可能没有遇到的标签/属性元素 最好的解决办法就是先搜索这个元素/属性的用法,然后再看解析, 再看他们的应用处理等</div><div class="line"> * 我们这里不对这些不常用的元素/属性进行详解 这里主要就是解析出来并保存到BeanDefinitiion中</div><div class="line"> */</div><div class="line">public AbstractBeanDefinition parseBeanDefinitionElement(</div><div class="line">		Element ele, String beanName, BeanDefinition containingBean) &#123;</div><div class="line"></div><div class="line">	this.parseState.push(new BeanEntry(beanName));</div><div class="line"></div><div class="line">	String className = null;</div><div class="line">	if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</div><div class="line">		className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	try &#123;</div><div class="line">		String parent = null;</div><div class="line">		if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</div><div class="line">			parent = ele.getAttribute(PARENT_ATTRIBUTE);</div><div class="line">		&#125;</div><div class="line">		//GenericBeanDefinition 设置className parentName变量 parent属性目前只是作为一个普通属性放倒BeanDefinition中去了 后面加载单例的时候会用到</div><div class="line">		AbstractBeanDefinition bd = createBeanDefinition(className, parent);//</div><div class="line"></div><div class="line">		//解析元素属性 例如scope lazy-init factory-method等属性的解析</div><div class="line">		parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</div><div class="line">		//解析元素子元素开始</div><div class="line">		bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</div><div class="line"></div><div class="line">		//&lt;meta key=&quot;&quot; value=&quot;&quot; /&gt; 作为对bd的额外参数使用</div><div class="line">		parseMetaElements(ele, bd);</div><div class="line">		//&lt;lookup-method name=&quot;&quot; bean=&quot;&quot; /&gt; 插拔式设计 方法根据配置 动态返回不同的bean 感兴趣的可以自行搜索相关使用demo</div><div class="line">		parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</div><div class="line">		//&lt;replaced-method name=&quot;&quot; replacer=&quot;&quot;/&gt; 根据配置 替换/更改原来的方法逻辑 interesting 感兴趣的可以自行搜索相关使用demo</div><div class="line">		parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</div><div class="line"></div><div class="line">		//todo &lt;constructor-arg index=&quot;i&quot;&gt;&lt;/constructor-arg&gt;</div><div class="line">		parseConstructorArgElements(ele, bd);</div><div class="line">		//&lt;property name=&quot;&quot; value=&quot;&quot;/&gt; or more complex property such as list,map 阅读源代码 我们要有的放矢</div><div class="line">		// 没必要把每一行都看懂 就像下面的解析构造参数 与 property一样 都是很复杂的 但我们没必要都读懂才行</div><div class="line">		parsePropertyElements(ele, bd);</div><div class="line">		//&lt;qualifier /&gt;</div><div class="line">		parseQualifierElements(ele, bd);</div><div class="line"></div><div class="line">		bd.setResource(this.readerContext.getResource());</div><div class="line">		bd.setSource(extractSource(ele));</div><div class="line"></div><div class="line">		return bd;</div><div class="line">	&#125;</div><div class="line">	catch (ClassNotFoundException ex) &#123;</div><div class="line">		error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);</div><div class="line">	&#125;</div><div class="line">	catch (NoClassDefFoundError err) &#123;</div><div class="line">		error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);</div><div class="line">	&#125;</div><div class="line">	catch (Throwable ex) &#123;</div><div class="line">		error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);</div><div class="line">	&#125;</div><div class="line">	finally &#123;</div><div class="line">		this.parseState.pop();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生成<code>beanDefinition</code>后 再用<code>BeanDefinitionHolder</code>封装后返回注册 至此xml配置文件中的设置就转化为了java对象保存<br>我们在回到<code>refresh()</code>方法 继续往下看<code>prepareBeanFactory()</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</div><div class="line">	// Tell the internal bean factory to use the context&apos;s class loader etc.</div><div class="line">	beanFactory.setBeanClassLoader(getClassLoader());</div><div class="line">	</div><div class="line">	//</div><div class="line">	beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver());</div><div class="line">	// 我们知道xml文档中的都是字符串形式的值 但我们可能需要的是其他的类型 比如Float Date等</div><div class="line">	// 这里注册一些常用的属性编辑器 去解决类型转化问题</div><div class="line">	beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));</div><div class="line"></div><div class="line">	//BPP 作用是如果bean实现了Aware接口的话 自动调用`setXXX`方法</div><div class="line">	beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</div><div class="line">	//忽略特殊类`ResourceLoaderAware` 等的依赖</div><div class="line">	beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</div><div class="line">	beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</div><div class="line">	beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</div><div class="line">	beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</div><div class="line">	beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</div><div class="line"></div><div class="line">	// BeanFactory interface not registered as resolvable type in a plain factory.</div><div class="line">	// MessageSource registered (and found for autowiring) as a bean.</div><div class="line">	beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</div><div class="line">	beanFactory.registerResolvableDependency(ResourceLoader.class, this);</div><div class="line">	beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);</div><div class="line">	beanFactory.registerResolvableDependency(ApplicationContext.class, this);</div><div class="line"></div><div class="line">	// Detect a LoadTimeWeaver and prepare for weaving, if found.</div><div class="line">	// @AspectJ相关 不常用 后面会专门讲解Spring AOP</div><div class="line">	if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</div><div class="line">		beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</div><div class="line">		// Set a temporary ClassLoader for type matching.</div><div class="line">		beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// Register default environment beans.</div><div class="line">	if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</div><div class="line">		beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</div><div class="line">	&#125;</div><div class="line">	if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</div><div class="line">		beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</div><div class="line">	&#125;</div><div class="line">	if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</div><div class="line">		beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码里面的注释应该是很详细了 我们来分析一个很有趣的事情<br>如果我们想在我们自己类中 获取如<code>ApplicationContext</code>的话 我们一般会继承ApplicationContextAware 然后有个回调方法会让我们实现 例如setApplicationContext 那么为什么我们只要实现了这个接口 我们实现的回调方法就会调用呢  奥秘就在这句代码<code>beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this))</code><br>BPP(BeanFactoryPostProcessor)是个很重要的知识点 我们这里大概了解一下</p>
<blockquote>
<p>不管是单例模式还是原型模式 我们定义的class肯定是要实例化的 如果有定义初始化方法的话 还会调用初始化方法 对于一个类来说 实例化 初始化都是很重要的时间节点  我们的<code>class</code>又是托管给<code>spring</code>进行管理的 那么<code>spring</code>就有能力 有机会在这些时间节点前后添加一些处理方法 <code>spring</code>中代表这一类操作的接口是<code>BeanPostProcessor</code> 简称BPP 中文翻译是后置处理器 当然<code>spring</code>中还有一种PostProcessor是容器级别的 <code>BeanFactoryPostProcessor</code> 就是在容器加载前后做一些特殊的操作</p>
</blockquote>
<p>在<code>ApplicationContextAwareProcessor.postProcessBeforeInitialization(final Object bean, String beanName)</code>方法中 会调用<code>invokeAwareInterfaces(bean)</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">private void invokeAwareInterfaces(Object bean) &#123;</div><div class="line">	if (bean instanceof Aware) &#123;</div><div class="line">		if (bean instanceof EnvironmentAware) &#123;</div><div class="line">			((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());</div><div class="line">		&#125;</div><div class="line">		if (bean instanceof EmbeddedValueResolverAware) &#123;</div><div class="line">			((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(</div><div class="line">					new EmbeddedValueResolver(this.applicationContext.getBeanFactory()));</div><div class="line">		&#125;</div><div class="line">		if (bean instanceof ResourceLoaderAware) &#123;</div><div class="line">			((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);</div><div class="line">		&#125;</div><div class="line">		if (bean instanceof ApplicationEventPublisherAware) &#123;</div><div class="line">			((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);</div><div class="line">		&#125;</div><div class="line">		if (bean instanceof MessageSourceAware) &#123;</div><div class="line">			((MessageSourceAware) bean).setMessageSource(this.applicationContext);</div><div class="line">		&#125;</div><div class="line">		if (bean instanceof ApplicationContextAware) &#123;</div><div class="line">			((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看起来很神秘的东西  它的实现是不是很一般 而且还感觉有点low 竟然没有魔法</p>
</div><div class="tags"><a href="/tags/context/">context</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2017/04/17/ClassPathXmlApplicationContext源码解析一/" class="pre">ClassPathXmlApplicationContext源码解析一:准备工作</a><a href="/2017/04/28/component-scan做了些什么/" class="next">component-scan做了些什么:源码解读</a></div><div id="comments"><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java并发包/">Java并发包</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Raspberry-Pi/">Raspberry Pi</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring源码分析/">Spring源码分析</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tomcat源码分析/">Tomcat源码分析</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/书单/">书单</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂七杂八/">杂七杂八</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/concurrent/" style="font-size: 15px;">concurrent</a> <a href="/tags/context/" style="font-size: 15px;">context</a> <a href="/tags/BFPP/" style="font-size: 15px;">BFPP</a> <a href="/tags/aop/" style="font-size: 15px;">aop</a> <a href="/tags/component-scan/" style="font-size: 15px;">component-scan</a> <a href="/tags/jdk动态代理/" style="font-size: 15px;">jdk动态代理</a> <a href="/tags/父子容器/" style="font-size: 15px;">父子容器</a> <a href="/tags/兴趣爱好/" style="font-size: 15px;">兴趣爱好</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/31/Spring问题快问快答/">Spring问题快问快答</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/07/AbstractQueuedSynchronizer-队列同步器-实现分析/">AbstractQueuedSynchronizer(队列同步器)实现分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/23/aop源码解析辅助-jdk动态代理/">aop源码解析辅助:jdk动态代理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/23/aop源码解析四-代理方法的调用/">aop源码解析四:代理方法的调用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/20/树莓派安装Ubuntu-server/">树莓派安装Ubuntu server</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/15/为什么要读书/">为什么要读书</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/11/spring父子容器源码解析二/">spring父子容器源码解析二</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/11/spring父子容器源码解析一/">spring父子容器源码解析一</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/01/aop源码解析三-postProcessAfterInitialization/">aop源码解析三:postProcessAfterInitialization</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/23/aop源码解析二-postProcessBeforeInstantiation/">aop源码解析二:postProcessBeforeInstantiation</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">孙明帅.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.0"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.0" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>var cloudTieConfig = {
  url: document.location.href, 
  sourceId: "",
  productKey: '7e92867159a646e798100b8a60c85579## 网易云跟帖(productKey)',
  target: "cloud-tie-wrapper"
};</script><script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script></body></html>