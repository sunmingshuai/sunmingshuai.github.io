<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="分享高质量Tomcat Spring SpringMCV Kafka 高并发相关技术博客"><meta name="keywords" content="Tomcat Spring AMQ Kafka Zookeeper"><title>ClassPathXmlApplicationContext源码解析五:加载单例 | The Fourty Thieves</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.0"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.0"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ClassPathXmlApplicationContext源码解析五:加载单例</h1><a id="logo" href="/.">The Fourty Thieves</a><p class="description">在我的记忆中,有一朵紫罗兰熠熠生辉. 这轻狂的姑娘! 我竟未染指!!  妈的,我好不后悔!!! </p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索..."></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">ClassPathXmlApplicationContext源码解析五:加载单例</h1><div class="post-meta"><span class="date">May 12, 2017</span><span class="category"><a href="/categories/Spring源码分析/">Spring源码分析</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i> Hits</i></i></span><a href="/2017/05/12/ClassPathXmlApplicationContext源码解析五-加载单例/#comments" class="comment-count"><i class="cloud-tie-join-count"><i class="join-count">0</i></i> 留言</a></div><div class="post-content"><p>在<code>refresh()</code>方法中 最重要的方法有两个 分别是<code>obtainFreshBeanFactory()</code>与 <code>finishBeanFactoryInitialization(beanFactory)</code> 第一个方法我们已经讲解过了 现在我们看下第二个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</div><div class="line">	if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</div><div class="line">			beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</div><div class="line">		beanFactory.setConversionService(</div><div class="line">				beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</div><div class="line">	&#125;</div><div class="line">	String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);</div><div class="line">	for (String weaverAwareName : weaverAwareNames) &#123;</div><div class="line">		getBean(weaverAwareName);</div><div class="line">	&#125;</div><div class="line">	beanFactory.setTempClassLoader(null);</div><div class="line">	beanFactory.freezeConfiguration();</div><div class="line">	//重要 实例化所有的非懒惰加载的bean</div><div class="line">	beanFactory.preInstantiateSingletons();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到<code>beanFactory.freezeConfiguration()</code>这里的时候 就不再允许改变配置文件了 因为可能会影响到后面的加载过程<br>如果<code>bean</code>是单例模式 并且没有设置懒惰加载的话 就预先实例化这个<code>bean</code> 调用<code>DefaultListableBeanFactory#preInstantiateSingletons()</code>方法 <code>DefaultListableBeanFactory</code>是个很重要的类 承载了很多功能 读者可以借助编辑器查看下这个类的继承关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public void preInstantiateSingletons() throws BeansException &#123;</div><div class="line">	if (this.logger.isInfoEnabled()) &#123;</div><div class="line">		this.logger.info(&quot;Pre-instantiating singletons in &quot; + this);</div><div class="line">	&#125;</div><div class="line">	List&lt;String&gt; beanNames;</div><div class="line">	synchronized (this.beanDefinitionMap) &#123;</div><div class="line">		beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames);</div><div class="line">	&#125;</div><div class="line">	// 循环检查所有的bean 并按情况加载</div><div class="line">	for (String beanName : beanNames) &#123;</div><div class="line">		RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</div><div class="line">		if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</div><div class="line">		//如果是工厂bean</div><div class="line">			if (isFactoryBean(beanName)) &#123;</div><div class="line">				final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</div><div class="line">				boolean isEagerInit;</div><div class="line">				if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</div><div class="line">					isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123;</div><div class="line">						public Boolean run() &#123;</div><div class="line">							return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</div><div class="line">						&#125;</div><div class="line">					&#125;, getAccessControlContext());</div><div class="line">				&#125;</div><div class="line">				else &#123;</div><div class="line">					isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</div><div class="line">							((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</div><div class="line">				&#125;</div><div class="line">				if (isEagerInit) &#123;</div><div class="line">					getBean(beanName);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				getBean(beanName);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于<code>beanFactory</code>中的每一个<code>bean</code> 先根据<code>beanName</code>获取<code>BeanDefinition</code> 因为我们所需要的属性等都在这个类里面了 调用<code>getMergedLocalBeanDefinition(beanName)</code> 方法获得 这里需要考虑的一个问题就是如果设置了<code>parent</code>属性的话(在由xml文件载入<code>BeanDefinition</code>的时候 <code>parent</code>属性被当作普通属性来对待 并没有做什么特殊处理)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;xxx&quot; class=&quot;com.xxx.xxx&quot; parent=&quot;TestXXX&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>那么就需要跟<code>parent</code>所指向的<code>BeanDefinition</code>的配置属性合并后再返回了. 当然这里肯定是个递归调用 因为<code>parent</code>本身可能也定义了自己的<code>parent</code>属性 合并的原则是先拷贝父类的所有属性元素,然后与子类的合并,如果有属性名一样的话,则覆盖.<br>在满足下面三个条件的时候 才会尝试加载</p>
<blockquote>
<ol>
<li>不是抽象类</li>
<li>单例模式</li>
<li>没有设置懒惰加载</li>
</ol>
</blockquote>
<p>如果是<code>FactoryBean</code>的话 那么就需要考虑是返回<code>FactoryBean</code>本身 还是返回<code>FactoryBean#getObect()</code>方法返回的对象 spring约定 如果要返回<code>FactoryBean</code>本身 那么需要在<code>beanName</code>前加上约定的<code>&amp;</code>符号 否则就是返回<code>T getObject()</code> 我们看一下<code>FactoryBean</code>的接口定义 很显然 这是利用了工厂方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface FactoryBean &#123;</div><div class="line">    T getObject() throws Exception;</div><div class="line">    Class&lt;?&gt; getObjectType();</div><div class="line">    boolean isSingleton();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面的源码内容 对于读者来说 比较难理解 对于作者本人来说比较难讲解 一个是涉及到的内容比较多 比如 <code>FactoryBean</code> <code>循环依赖</code> <code>代理</code> <code>属性填充</code> <code>BPP</code> <code>寻找构造函数</code>等 另外一个是功能间<code>咬合</code>比较多 下文介绍的时候 我们就不考虑那么多 先把最简单的情况介绍到 如下面的代码实例:第一次加载 有默认构造函数 <code>TestA</code>中有一个java基本类型 一个引用类型  <code>init-method</code>属性, 在了解加载<code>TestA</code>的加载的基础上  再去了解那些扩展功能</p>
<blockquote>
<p>当然对于TestA的加载其实过程很简单 简单叙述来说 就是根据TestA.class实例化TestA 这里用的是默认的构造函数 然后是属性的填充 调用init()方法等</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class TestA&#123;</div><div class="line"></div><div class="line">    private String a;</div><div class="line">    </div><div class="line">    private TestB b;</div><div class="line">    </div><div class="line">    @Autowired</div><div class="line">    private TestC c;</div><div class="line">    </div><div class="line">    //  getXXX setXXX</div><div class="line">    </div><div class="line">    public void init()&#123;</div><div class="line">        System.out.println(&quot;Hello World&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class TestB&#123;</div><div class="line"></div><div class="line">    private int c;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">____________________________</div><div class="line">......</div><div class="line">&lt;!--  --&gt; </div><div class="line">&lt;component:scan basepackage=&quot;com.xxx.xxx&quot;/&gt;</div><div class="line">&lt;bean id=&quot;testA&quot; class=&quot;com.xxx.xxx.TestA&quot;&gt;</div><div class="line">    &lt;property name=&quot;b&quot; ref=&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;bean id=&quot;testB&quot; class=&quot;com.xxx.xxx.TestB&quot;/&gt;</div><div class="line">&lt;bean id=&quot;testC&quot; class=&quot;com.xxx.xxx.TestC&quot;/&gt;</div><div class="line">......</div></pre></td></tr></table></figure>
<p><code>AbstractBeanFactory#doGetBean(...)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div></pre></td><td class="code"><pre><div class="line">protected &lt;T&gt; T doGetBean(</div><div class="line">		final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)</div><div class="line">		throws BeansException &#123;</div><div class="line"></div><div class="line">	// 如果是别名 就返回对应的真实的beanName</div><div class="line">	// 如果以&amp;开头 先去除</div><div class="line">	final String beanName = transformedBeanName(name);</div><div class="line">	Object bean;</div><div class="line"></div><div class="line">	// Eagerly check singleton cache for manually registered singletons.</div><div class="line">	Object sharedInstance = getSingleton(beanName);</div><div class="line">	if (sharedInstance != null &amp;&amp; args == null) &#123;</div><div class="line">		if (logger.isDebugEnabled()) &#123;</div><div class="line">			if (isSingletonCurrentlyInCreation(beanName)) &#123;</div><div class="line">				logger.debug(&quot;Returning eagerly cached instance of singleton bean &apos;&quot; + beanName +</div><div class="line">						&quot;&apos; that is not fully initialized yet - a consequence of a circular reference&quot;);</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				logger.debug(&quot;Returning cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		//todo 待看</div><div class="line">		bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	else &#123;</div><div class="line">		//依赖分为三种依赖: 原型循环依赖 构造器循环依赖 单例循环依赖</div><div class="line">		//只有单例依赖才能解决   其他情况只能抛出异常</div><div class="line">		</div><div class="line">		//原型循环依赖 无法解决 抛异常</div><div class="line">		if (isPrototypeCurrentlyInCreation(beanName)) &#123;</div><div class="line">			throw new BeanCurrentlyInCreationException(beanName);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// Check if bean definition exists in this factory.</div><div class="line">		BeanFactory parentBeanFactory = getParentBeanFactory();</div><div class="line">		//如果这个容器中没有bean的定义的话 去父容器中加载</div><div class="line">		if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</div><div class="line">			// Not found -&gt; check parent.</div><div class="line">			//还原beanName</div><div class="line">			String nameToLookup = originalBeanName(name);</div><div class="line">			if (args != null) &#123;</div><div class="line">				// Delegation to parent with explicit args.</div><div class="line">				return (T) parentBeanFactory.getBean(nameToLookup, args);</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				// No args -&gt; delegate to standard getBean method.</div><div class="line">				return parentBeanFactory.getBean(nameToLookup, requiredType);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if (!typeCheckOnly) &#123;</div><div class="line">			markBeanAsCreated(beanName);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		try &#123;</div><div class="line">			//返回配置文件定义的bean的定义信息 GenericBeanDefinition-&gt;RootBeanDefinition</div><div class="line">			final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</div><div class="line">			checkMergedBeanDefinition(mbd, beanName, args);</div><div class="line"></div><div class="line">			// 先加载配置中`depend-on`属性中配置的`bean`</div><div class="line">			String[] dependsOn = mbd.getDependsOn();</div><div class="line">			if (dependsOn != null) &#123;</div><div class="line">				for (String dependsOnBean : dependsOn) &#123;</div><div class="line">					getBean(dependsOnBean);</div><div class="line">					registerDependentBean(dependsOnBean, beanName);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			// 单例模式</div><div class="line">			if (mbd.isSingleton()) &#123;</div><div class="line">				sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123;</div><div class="line">					public Object getObject() throws BeansException &#123;</div><div class="line">						try &#123;</div><div class="line">							//核心加载部分</div><div class="line">							return createBean(beanName, mbd, args);</div><div class="line">						&#125;</div><div class="line">						catch (BeansException ex) &#123;</div><div class="line">							// Explicitly remove instance from singleton cache: It might have been put there</div><div class="line">							// eagerly by the creation process, to allow for circular reference resolution.</div><div class="line">							// Also remove any beans that received a temporary reference to the bean.</div><div class="line">							destroySingleton(beanName);</div><div class="line">							throw ex;</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;);</div><div class="line">				//获取到的bean可能是FactoryBean类型的bean</div><div class="line">				bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</div><div class="line">			&#125;</div><div class="line">			// 原型模式</div><div class="line">			else if (mbd.isPrototype()) &#123;</div><div class="line">				// It&apos;s a prototype -&gt; create a new instance.</div><div class="line">				Object prototypeInstance = null;</div><div class="line">				try &#123;</div><div class="line">					beforePrototypeCreation(beanName);</div><div class="line">					prototypeInstance = createBean(beanName, mbd, args);</div><div class="line">				&#125;</div><div class="line">				finally &#123;</div><div class="line">					afterPrototypeCreation(beanName);</div><div class="line">				&#125;</div><div class="line">				bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			else &#123;</div><div class="line">				String scopeName = mbd.getScope();</div><div class="line">				final Scope scope = this.scopes.get(scopeName);</div><div class="line">				if (scope == null) &#123;</div><div class="line">					throw new IllegalStateException(&quot;No Scope registered for scope &apos;&quot; + scopeName + &quot;&apos;&quot;);</div><div class="line">				&#125;</div><div class="line">				try &#123;</div><div class="line">					Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123;</div><div class="line">						public Object getObject() throws BeansException &#123;</div><div class="line">							beforePrototypeCreation(beanName);</div><div class="line">							try &#123;</div><div class="line">								return createBean(beanName, mbd, args);</div><div class="line">							&#125;</div><div class="line">							finally &#123;</div><div class="line">								afterPrototypeCreation(beanName);</div><div class="line">							&#125;</div><div class="line">						&#125;</div><div class="line">					&#125;);</div><div class="line">					bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</div><div class="line">				&#125;</div><div class="line">				catch (IllegalStateException ex) &#123;</div><div class="line">					throw new BeanCreationException(beanName,</div><div class="line">							&quot;Scope &apos;&quot; + scopeName + &quot;&apos; is not active for the current thread; &quot; +</div><div class="line">							&quot;consider defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,</div><div class="line">							ex);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		catch (BeansException ex) &#123;</div><div class="line">			cleanupAfterBeanCreationFailure(beanName);</div><div class="line">			throw ex;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// Check if required type matches the type of the actual bean instance.</div><div class="line">	if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;</div><div class="line">		try &#123;</div><div class="line">			return getTypeConverter().convertIfNecessary(bean, requiredType);</div><div class="line">		&#125;</div><div class="line">		catch (TypeMismatchException ex) &#123;</div><div class="line">			if (logger.isDebugEnabled()) &#123;</div><div class="line">				logger.debug(&quot;Failed to convert bean &apos;&quot; + name + &quot;&apos; to required type [&quot; +</div><div class="line">						ClassUtils.getQualifiedName(requiredType) + &quot;]&quot;, ex);</div><div class="line">			&#125;</div><div class="line">			throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return (T) bean;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>getSingleton(beanName)</code>的调用中 其实处理了好几种情况 </p>
<ol>
<li>是否已经加载完成过 bean的加载是个耗时的过程 加载完成后就放到map中保存 有就直接返回</li>
<li>没有加载完成 并且知道正在创建中 那么说明是遇到了循环依赖问题<br>对于循环依赖问题 以后有时间会单独开一个博客讲解 这里简单介绍下 首先对于都是<strong>单例模式</strong>来说 会遇到两种循环依赖问题 <code>构造器循环依赖</code> <code>set循环依赖</code> 举例如下 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//构造器循环依赖</div><div class="line">public class TestA()&#123;</div><div class="line">    ...</div><div class="line">    public TestA(TestB b)&#123;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class TestB()&#123;</div><div class="line">    ...</div><div class="line">    public TestB(TestA a)&#123;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//set循环依赖</div><div class="line">public class TestA()&#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    @Autowired</div><div class="line">    private TestB b;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class TestB()&#123;</div><div class="line">    ...</div><div class="line">    @Autowired</div><div class="line">    private TestA a;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造器循环依赖 是不能够被解决的 原因如下：在实例化<code>TestA</code>的时候需要去实例化<code>TestB</code> 然后去实例化<code>TestB</code> 然后这个时候又发现需要<code>TestA</code> 所以两个都不能完成实例化<br>而对于set依赖来说 虽然也存在循环依赖 但问题却能够得到解决 解释如下：<code>TestA</code>实例化完成后 在给<code>TestA</code>填充属性的过程中发现需要<code>TestB</code> 存下<code>TestA</code>的引用 然后去获取<code>TestB</code> 实例化<code>TestB</code>后 给<code>TestB</code>填充属性的过程中发现需要<code>TestA</code> 然后再去获取<code>TestA</code> 之前埋入了<code>TestA</code>的引用 （虽然还没加载完整） 这个时候返回<code>TestA</code>的引用 这个时候<code>TestB</code>加载完成 回去继续加载<code>TestA</code> 这个时候循环依赖也就没有了<br><code>Spring</code>通过记录不同状态下的引用 即提前暴露地址的方式解决循环依赖<br>在第一次讲解的时候 我们暂且不考虑那么多 我们就当成我们现在的情况是第一次加载这个<code>bean</code> 并且不存在循环依赖的情况 当然我们还是可以看下他们额外做了写什么 大概有个印象<br>我们回到<code>getSingleton(...)</code>方法 里面有两个map 一个是<code>earlySingletonObjects</code> 另外一个是<code>singletonFactories</code> 这两个map中的东西似乎是互斥的.<br>如果这个时候获得到了的话 就返回 然后再通过<code>getObjectForBeanInstance</code>处理 这个方法主要判断返回的是不是我们最终想要的 如果是<code>FactoryBean</code>类型的话 还需要进一步处理<br>我们看下单例模式下的<code>bean</code>的加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123;</div><div class="line">						public Object getObject() throws BeansException &#123;</div><div class="line">							try &#123;</div><div class="line">								//核心加载部分</div><div class="line">								return createBean(beanName, mbd, args);</div><div class="line">							&#125;</div><div class="line">							catch (BeansException ex) &#123;</div><div class="line">								// Explicitly remove instance from singleton cache: It might have been put there</div><div class="line">								// eagerly by the creation process, to allow for circular reference resolution.</div><div class="line">								// Also remove any beans that received a temporary reference to the bean.</div><div class="line">								destroySingleton(beanName);</div><div class="line">								throw ex;</div><div class="line">							&#125;</div><div class="line">						&#125;</div><div class="line">					&#125;);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;</div><div class="line">	Assert.notNull(beanName, &quot;&apos;beanName&apos; must not be null&quot;);</div><div class="line">	synchronized (this.singletonObjects) &#123;</div><div class="line">		Object singletonObject = this.singletonObjects.get(beanName);</div><div class="line">		if (singletonObject == null) &#123;</div><div class="line">			if (this.singletonsCurrentlyInDestruction) &#123;</div><div class="line">				throw new BeanCreationNotAllowedException(beanName,</div><div class="line">						&quot;Singleton bean creation not allowed while the singletons of this factory are in destruction &quot; +</div><div class="line">						&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;);</div><div class="line">			&#125;</div><div class="line">			//时间节点 放入singletonsCurrentlyInCreation 代表这个bean正在加载中</div><div class="line">			beforeSingletonCreation(beanName);</div><div class="line">			boolean recordSuppressedExceptions = (this.suppressedExceptions == null);</div><div class="line">			if (recordSuppressedExceptions) &#123;</div><div class="line">				this.suppressedExceptions = new LinkedHashSet&lt;Exception&gt;();</div><div class="line">			&#125;</div><div class="line">			try &#123;</div><div class="line">				singletonObject = singletonFactory.getObject();</div><div class="line">			&#125;</div><div class="line">			catch (BeanCreationException ex) &#123;</div><div class="line">				if (recordSuppressedExceptions) &#123;</div><div class="line">					for (Exception suppressedException : this.suppressedExceptions) &#123;</div><div class="line">						ex.addRelatedCause(suppressedException);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				throw ex;</div><div class="line">			&#125;</div><div class="line">			finally &#123;</div><div class="line">				if (recordSuppressedExceptions) &#123;</div><div class="line">					this.suppressedExceptions = null;</div><div class="line">				&#125;</div><div class="line">				//时间节点 从singletonsCurrentlyInCreation中清除 代表创建完成</div><div class="line">				afterSingletonCreation(beanName);</div><div class="line">			&#125;</div><div class="line">			//加入到singletonObjects中 从singletonFactories earlySingletonObjects中去除</div><div class="line">			addSingleton(beanName, singletonObject);</div><div class="line">		&#125;</div><div class="line">		return (singletonObject != NULL_OBJECT ? singletonObject : null);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看下<code>singletonFactory</code>回调方法<code>createBean</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">protected Object createBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)</div><div class="line">		throws BeanCreationException &#123;</div><div class="line">	// 获取class属性</div><div class="line">	resolveBeanClass(mbd, beanName);</div><div class="line"></div><div class="line">	// Prepare method overrides.</div><div class="line">	try &#123;</div><div class="line">		//look-method replace-method配置项检查处理 如果不清楚的可以先搜索相关使用demo</div><div class="line">		mbd.prepareMethodOverrides();</div><div class="line">	&#125;</div><div class="line">	catch (BeanDefinitionValidationException ex) &#123;</div><div class="line">		throw new BeanDefinitionStoreException(mbd.getResourceDescription(),</div><div class="line">				beanName, &quot;Validation of method overrides failed&quot;, ex);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	try &#123;</div><div class="line">		// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</div><div class="line">		// todo AOP功能实现 `AnnotationAwareAspectJAutoProxyCreator`</div><div class="line">		// [看另外一篇博客](http://www.sunmingshuai.cn/2017/05/22/aop%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%80/)</div><div class="line">		Object bean = resolveBeforeInstantiation(beanName, mbd);</div><div class="line">		if (bean != null) &#123;</div><div class="line">			return bean;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	catch (Throwable ex) &#123;</div><div class="line">		throw new BeanCreationException(mbd.getResourceDescription(), beanName,</div><div class="line">				&quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	Object beanInstance = doCreateBean(beanName, mbd, args);</div><div class="line">	if (logger.isDebugEnabled()) &#123;</div><div class="line">		logger.debug(&quot;Finished creating instance of bean &apos;&quot; + beanName + &quot;&apos;&quot;);</div><div class="line">	&#125;</div><div class="line">	return beanInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们有对类进行代理的话 那么返回的就是代理类 而不是裸类 这个处理就是在<code>resolveBeforeInstantiation</code>方法中处理的 这里不深入研究 想了解的可以看博主的另外的博客介绍  <a href="http://www.sunmingshuai.cn/2017/05/22/aop%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%80/" target="_blank" rel="external">aop源码解析一:注册BPP</a> <a href="http://www.sunmingshuai.cn/2017/05/23/aop%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%BA%8C-%E5%AF%BB%E6%89%BEAdvisor/" target="_blank" rel="external">aop源码解析二:寻找Advisor</a><br>方法又转到了<code>doCreateBean(beanName,mnb,args)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) &#123;</div><div class="line">		// Instantiate the bean.</div><div class="line">		BeanWrapper instanceWrapper = null;</div><div class="line">		if (mbd.isSingleton()) &#123;</div><div class="line">			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);</div><div class="line">		&#125;</div><div class="line">		if (instanceWrapper == null) &#123;</div><div class="line">			//判断采用哪种实例化方法 factoryMethod | 构造器(如果有多个构造器还需要根据args判断采用哪个构造器构造)</div><div class="line">			//如果有配置replace-method lookup-method 会创建代理</div><div class="line">			//注册属性编辑器</div><div class="line">			instanceWrapper = createBeanInstance(beanName, mbd, args);</div><div class="line">		&#125;</div><div class="line">		final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);</div><div class="line">		Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);</div><div class="line"></div><div class="line">		// Allow post-processors to modify the merged bean definition.</div><div class="line">		synchronized (mbd.postProcessingLock) &#123;</div><div class="line">			if (!mbd.postProcessed) &#123;</div><div class="line">				//todo ## BPP触发的另一个地方 如处理@AutoWired注解的AutowiredAnnotationBeanPostProcessor#postProcessMergedBeanDefinition()</div><div class="line">				// [component-scan做了些什么:源码解读](http://www.sunmingshuai.cn/2017/04/28/component-scan%E5%81%9A%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/)</div><div class="line">				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</div><div class="line">				mbd.postProcessed = true;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// 提前加入缓存 以辩能够解决循环引用问题</div><div class="line">		boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</div><div class="line">				isSingletonCurrentlyInCreation(beanName));</div><div class="line">		if (earlySingletonExposure) &#123;</div><div class="line">			if (logger.isDebugEnabled()) &#123;</div><div class="line">				logger.debug(&quot;Eagerly caching bean &apos;&quot; + beanName +</div><div class="line">						&quot;&apos; to allow for resolving potential circular references&quot;);</div><div class="line">			&#125;</div><div class="line">			// 解决循环依赖问题的关键 提前把ObjectFactory加入进来 如果有碰到循环依赖的话 通过ObjectFactory获取bean</div><div class="line">			// 因为他们代表的地址是一样的</div><div class="line">			addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123;</div><div class="line">				public Object getObject() throws BeansException &#123;</div><div class="line">					return getEarlyBeanReference(beanName, mbd, bean);</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// 初始化bean的实例</div><div class="line">		Object exposedObject = bean;</div><div class="line">		try &#123;</div><div class="line">			// bean属性的填充(xml文件定义的属性 被@Autowired @Value等注解修饰 以及一些其他属性  IOC的直接体现</div><div class="line">			populateBean(beanName, mbd, instanceWrapper);</div><div class="line">			if (exposedObject != null) &#123;</div><div class="line">				exposedObject = initializeBean(beanName, exposedObject, mbd);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		catch (Throwable ex) &#123;</div><div class="line">			if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</div><div class="line">				throw (BeanCreationException) ex;</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if (earlySingletonExposure) &#123;</div><div class="line">			// 再一次调用`getSingleton()`方法 只是这一次`allowEarlyReference`为false</div><div class="line">			Object earlySingletonReference = getSingleton(beanName, false);</div><div class="line">			if (earlySingletonReference != null) &#123;</div><div class="line">				if (exposedObject == bean) &#123;</div><div class="line">					exposedObject = earlySingletonReference;</div><div class="line">				&#125;</div><div class="line">				else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</div><div class="line">					String[] dependentBeans = getDependentBeans(beanName);</div><div class="line">					Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length);</div><div class="line">					for (String dependentBean : dependentBeans) &#123;</div><div class="line">						if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</div><div class="line">							actualDependentBeans.add(dependentBean);</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					if (!actualDependentBeans.isEmpty()) &#123;</div><div class="line">						throw new BeanCurrentlyInCreationException(beanName,</div><div class="line">								&quot;Bean with name &apos;&quot; + beanName + &quot;&apos; has been injected into other beans [&quot; +</div><div class="line">								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</div><div class="line">								&quot;] in its raw version as part of a circular reference, but has eventually been &quot; +</div><div class="line">								&quot;wrapped. This means that said other beans do not use the final version of the &quot; +</div><div class="line">								&quot;bean. This is often the result of over-eager type matching - consider using &quot; +</div><div class="line">								&quot;&apos;getBeanNamesOfType&apos; with the &apos;allowEagerInit&apos; flag turned off, for example.&quot;);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// Register bean as disposable.</div><div class="line">		try &#123;</div><div class="line">			registerDisposableBeanIfNecessary(beanName, bean, mbd);</div><div class="line">		&#125;</div><div class="line">		catch (BeanDefinitionValidationException ex) &#123;</div><div class="line">			throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		return exposedObject;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这里会判断采用哪种方式实例化<code>bean</code> 如果采用有参构造函数的形式的话 匹配逻辑稍微有点复杂 实例化后会注册一些属性编辑器 就是把<code>string</code>类型的参数值能够转化为我们想要的类型值<br><code>applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName)</code>方法是<code>spring</code>的一个扩展方法 例如我们常用的<code>@Autowired</code>就在这个方法里预先处理了一下 找出该<code>bean</code>的标注有<code>@Autowited</code>所有的<code>field</code>与<code>method</code> 并放入合适的数据结构保存 我们这里就不展开讲解了<br><code>addSingletonFactory</code>这个方法逻辑不难 却意义重大 到这个阶段的时候 就把这个<code>bean</code>提前暴露出来了 就能够解决我们前面所说的第二种依赖了<br><code>populateBean(beanName, mbd, instanceWrapper)</code>方法的作用就是<code>bean</code>属性的填充 我们说的<code>IOC</code> <code>DI</code>的体现就是在这里了 由<code>spring</code>框架给我们注入我们想要的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) &#123;</div><div class="line">		PropertyValues pvs = mbd.getPropertyValues();</div><div class="line"></div><div class="line">		if (bw == null) &#123;</div><div class="line">			if (!pvs.isEmpty()) &#123;</div><div class="line">				throw new BeanCreationException(</div><div class="line">						mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				// Skip property population phase for null instance.</div><div class="line">				return;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</div><div class="line">		// state of the bean before properties are set. This can be used, for example,</div><div class="line">		// to support styles of field injection.</div><div class="line">		boolean continueWithPropertyPopulation = true;</div><div class="line"></div><div class="line">		//实例化后的后置处理器 spring框架的扩展点</div><div class="line">		if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</div><div class="line">			for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</div><div class="line">				if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</div><div class="line">					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</div><div class="line">					if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</div><div class="line">						continueWithPropertyPopulation = false;</div><div class="line">						break;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if (!continueWithPropertyPopulation) &#123;</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</div><div class="line">				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</div><div class="line">			MutablePropertyValues newPvs = new MutablePropertyValues(pvs);</div><div class="line"></div><div class="line">			// xml文件中定义的非java基本类型依赖 在这里就注入了 byName</div><div class="line">			if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</div><div class="line">				autowireByName(beanName, mbd, bw, newPvs);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			// xml文件中定义的非java基本类型依赖 在这里就注入了 byType</div><div class="line">			if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</div><div class="line">				autowireByType(beanName, mbd, bw, newPvs);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			pvs = newPvs;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</div><div class="line">		boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</div><div class="line"></div><div class="line">		// @Autowired注解实现注入就是在这里</div><div class="line">		if (hasInstAwareBpps || needsDepCheck) &#123;</div><div class="line">			PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</div><div class="line">			if (hasInstAwareBpps) &#123;</div><div class="line">				for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</div><div class="line">					if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</div><div class="line">						InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</div><div class="line">						pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</div><div class="line">						if (pvs == null) &#123;</div><div class="line">							return;</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			if (needsDepCheck) &#123;</div><div class="line">				checkDependencies(beanName, mbd, filteredPds, pvs);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		//</div><div class="line">		applyPropertyValues(beanName, mbd, bw, pvs);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这里涉及到的几个BPP我们后面会挑一个出来讲解 如@Autowired注解的实现过程 这里就不深入讨论了 属性填充完后就到了init的环节 <code>initializeBean(beanName, exposedObject, mbd)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;</div><div class="line">	// 这个时间点是属性填充完了 但是还没有调用initMethod方法的阶段</div><div class="line">	if (System.getSecurityManager() != null) &#123;</div><div class="line">		AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</div><div class="line">			public Object run() &#123;</div><div class="line">				invokeAwareMethods(beanName, bean);</div><div class="line">				return null;</div><div class="line">			&#125;</div><div class="line">		&#125;, getAccessControlContext());</div><div class="line">	&#125;</div><div class="line">	else &#123;</div><div class="line">		//如果有继承xxxAware的话 调用setXXX相应的方法</div><div class="line">		invokeAwareMethods(beanName, bean);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	Object wrappedBean = bean;</div><div class="line">	if (mbd == null || !mbd.isSynthetic()) &#123;</div><div class="line">		//initMethod方法调用前</div><div class="line">		wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	try &#123;</div><div class="line">		//调用initMethod 或者 afterPropertiesSet方法</div><div class="line">		invokeInitMethods(beanName, wrappedBean, mbd);</div><div class="line">	&#125;</div><div class="line">	catch (Throwable ex) &#123;</div><div class="line">		throw new BeanCreationException(</div><div class="line">				(mbd != null ? mbd.getResourceDescription() : null),</div><div class="line">				beanName, &quot;Invocation of init method failed&quot;, ex);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (mbd == null || !mbd.isSynthetic()) &#123;</div><div class="line">		wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</div><div class="line">	&#125;</div><div class="line">	return wrappedBean;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法相对来说比较简单 有几点说一下 读者可能用过<code>xxxAware</code> 然后继承<code>setXXX</code>方法就可以了 那么是怎么实现的呢 答案很简单 <code>spring</code>会判断是哪个<code>aware</code> 然后调用响应的set方法 即<code>invokeAwareMethods</code>的方法实现<br>我们前面说过初始化方法执行前后是个特殊的时间节点 spring自然不会忘记在其执行前后添加一些扩展点 就是调用<code>BPP</code>的扩展方法<br>对于初始化来说 spring提供了一个类似功能的接口供我们继承<code>InitializingBean</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface InitializingBean &#123;</div><div class="line">	void afterPropertiesSet() throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>跟<code>init-method</code>要实现的功能差不多<br>初始化完成后 <code>bean</code>的加载基本上就算完成了</p>
</div><div class="tags"><a href="/tags/context/">context</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2017/05/07/常用命令行命令详解/" class="pre">常用命令行命令详解</a><a href="/2017/05/13/PropertyPlaceholderConfigurer源码解析/" class="next">PropertyPlaceholderConfigurer源码解析</a></div><div id="comments"><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Raspberry-Pi/">Raspberry Pi</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring源码分析/">Spring源码分析</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tomcat源码分析/">Tomcat源码分析</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/书单/">书单</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂七杂八/">杂七杂八</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/context/" style="font-size: 15px;">context</a> <a href="/tags/BFPP/" style="font-size: 15px;">BFPP</a> <a href="/tags/aop/" style="font-size: 15px;">aop</a> <a href="/tags/component-scan/" style="font-size: 15px;">component-scan</a> <a href="/tags/父子容器/" style="font-size: 15px;">父子容器</a> <a href="/tags/兴趣爱好/" style="font-size: 15px;">兴趣爱好</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/31/Spring问题快问快答/">Spring问题快问快答</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/20/树莓派安装Ubuntu-server/">树莓派安装Ubuntu server</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/17/aop源码解析四-调用过程/">aop源码解析三:调用过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/15/为什么要读书/">为什么要读书</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/11/spring父子容器源码解析二/">spring父子容器源码解析二</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/11/spring父子容器源码解析一/">spring父子容器源码解析一</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/01/aop源码解析三-postProcessAfterInitialization/">aop源码解析三:创建代理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/23/aop源码解析二-postProcessBeforeInstantiation/">aop源码解析二:postProcessBeforeInstantiation</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/22/aop源码解析一-注册BPP/">aop源码解析一:注册BPP</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/20/aop基本概念/">aop基本概念</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">孙明帅.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.0"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.0" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>var cloudTieConfig = {
  url: document.location.href, 
  sourceId: "",
  productKey: '7e92867159a646e798100b8a60c85579## 网易云跟帖(productKey)',
  target: "cloud-tie-wrapper"
};</script><script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script></body></html>