[{"title":"component-scan做了些什么|源码解读","date":"2017-04-17T09:35:35.000Z","path":"2017/04/17/component-scan做了些什么/","text":"本文为博主原创文章，未经博主允许不得转载。 写在前面看spring代码中途的过程中才开始写博客的 所以这篇博客假设你看过spring读取配置文件 解析标准&lt;bean&gt;标签的功能 以后会把这部分内容补上 本文目的本文主要解决一个问题就是component-scan会扫描注册哪些注解标注的类 被@Controller标注的类会被扫描注册吗? 正文当遇到component-scan这样非标准或者称为自定义的元素标签时 spring会通过spring.handlers文件中的对应关系http\\://www.springframework.org/schema/context= org.springframework.context.config.ContextNamespaceHandler找到ContextNamespaceHandler 通过ContextNamespaceHandler类init()自动注册一些解析器 下面列出了所有以context为命名空间的组合 例如常见的&lt;context:componet-scan&gt;元素 根据注册对应关系 知道其对应的解析器为ComponentScanBeanDefinitionParser public void init() { registerBeanDefinitionParser(&quot;property-placeholder&quot;, new PropertyPlaceholderBeanDefinitionParser()); registerBeanDefinitionParser(&quot;property-override&quot;, new PropertyOverrideBeanDefinitionParser()); registerBeanDefinitionParser(&quot;annotation-config&quot;, new AnnotationConfigBeanDefinitionParser()); registerBeanDefinitionParser(&quot;component-scan&quot;, new ComponentScanBeanDefinitionParser()); registerBeanDefinitionParser(&quot;load-time-weaver&quot;, new LoadTimeWeaverBeanDefinitionParser()); registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser()); registerBeanDefinitionParser(&quot;mbean-export&quot;, new MBeanExportBeanDefinitionParser()); registerBeanDefinitionParser(&quot;mbean-server&quot;, new MBeanServerBeanDefinitionParser()); } 那我们看一下&lt;context:component-scan&gt;的解析器ComponentScanBeanDefinitionParser的源码 (ComponentScanBeanDefinitionParser继承自BeanDefinitionParser) spring解析&lt;context:component-scan&gt;的时候会调用ComponentScanBeanDefinitionParser的parse()函数 //element 代表的是完整的&lt;context:component-scan&gt;标签 //parserContext 解析的上下文环境 能拿到一些诸如readerContext registry等变量 public BeanDefinition parse(Element element, ParserContext parserContext) { //将指定base-package拆分成string数组的形式 String[] basePackages = StringUtils.tokenizeToStringArray(element.getAttribute(BASE_PACKAGE_ATTRIBUTE), ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); // 根据xml配置或者默认配置(如果没有指定的话)配置扫描器ClassPathBeanDefinitionScanner ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element); //scanner扫描包下面含有特殊注解标注的类 //@Component @Named @ManagedBean (@Controller @Service @Repository @Configuration)都会被注册 Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages); // 注册组件以及一些我们常见的注解处理器(BPP) 如@Resouce @Autowired @Configuration @Value @Required @PostConstruct //那么以后看到属性注入(IOC/DI)的时候 就不会奇怪 这些注解的处理器(BPP)是在哪里注册的了 在这里! registerComponents(parserContext.getReaderContext(), beanDefinitions, element); return null; } 看一下scanner的创建以及设置 protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) { XmlReaderContext readerContext = parserContext.getReaderContext(); boolean useDefaultFilters = true; if (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) { useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)); } // 生成scanner的时候 在其父类构造函数中调用了`registerDefaultFilters()`方法中加入了3个注解类型的typeFilter 分别是@Component // @ManagedBean @Named 意思也就是看类上面有没有这三个注解或者注解的元注解中是否含有这三个注解之一 // 这里虽然没有加入如@Service的注解 但看@Service的定义会发现@Service注解也被@Component给标注了 ClassPathBeanDefinitionScanner scanner = createScanner(readerContext, useDefaultFilters); scanner.setResourceLoader(readerContext.getResourceLoader()); scanner.setEnvironment(parserContext.getDelegate().getEnvironment()); // 利用spring 启动的时候根据xml文件或者默认配置(如果没有指定的话)生成的BeanDefinition规则 scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults()); scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns()); if (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) { scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE)); } try { // 扫描注解定义的bean 需要定义一种beanName的生成规则 一般是驼峰命名法 parseBeanNameGenerator(element, scanner); } catch (Exception ex) { readerContext.error(ex.getMessage(), readerContext.extractSource(element), ex.getCause()); } try { // bean的scope singleton?prototype? parseScope(element, scanner); } catch (Exception ex) { readerContext.error(ex.getMessage(), readerContext.extractSource(element), ex.getCause()); } // 根据xml配置生成includeFilter excludeFilter 在创建scanner类的时候 就硬编码进去了3个注解类型 // 的typeFilter到includeFilter里面 // 类必须满足以下条件才会被注册 因为@Component等是被硬编码进去的 所以只有下面一种情况才会被注册了 // 不被excludeFilter匹配 并且被includeFilter匹配 parseTypeFilters(element, scanner, readerContext, parserContext); return scanner; } 下面在看一下真正的扫描过程doScan 我们发现spirng中真正干活的一般都是以do开头 前面的那么多只是为了做铺垫 单一指责 protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) { Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;); Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(); for (String basePackage : basePackages) { //寻找被@Component或者@Named注解标注的类 或者 类的注解的元注解中含有这两个注解 例如常见的@Respsitory @Controller @Service Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); // 对于生成的AnnotatedBeanDefinition做一些转化工作 例如前面说到的应用bd(BeanDefinition)默认配置 // 处理@Primary @Lazy @DependsOn @Role注解等 // 转化成BeanDefinitionHolder对象 for (BeanDefinition candidate : candidates) { ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) { postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); } if (candidate instanceof AnnotatedBeanDefinition) { AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); } if (checkCandidate(beanName, candidate)) { BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); //注册到容器中 registerBeanDefinition(definitionHolder, this.registry); } } } return beanDefinitions; } 看一下findCandidateComponents方法 public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) { Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;BeanDefinition&gt;(); try { String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + &quot;/&quot; + this.resourcePattern; //这里的resouces代表的就是路径下的各个类了 Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath); boolean traceEnabled = logger.isTraceEnabled(); boolean debugEnabled = logger.isDebugEnabled(); for (Resource resource : resources) { if (traceEnabled) { logger.trace(&quot;Scanning &quot; + resource); } if (resource.isReadable()) { try { // 这一步的作用就是能够不必加载class但能拿到class各种属性 并且这里也不能载入class(有很多是单例模式) 还没到那一步 // 只是为了做匹配 生成bd而已 MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); // 根据includeFilters excludeFilters做匹配 因为篇幅的限制 不详谈 有兴趣的可以研究一下typeFilter的实现 if (isCandidateComponent(metadataReader)) { ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); if (isCandidateComponent(sbd)) { if (debugEnabled) { logger.debug(&quot;Identified candidate component class: &quot; + resource); } candidates.add(sbd); } else { if (debugEnabled) { logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource); } } } else { if (traceEnabled) { logger.trace(&quot;Ignored because not matching any filter: &quot; + resource); } } } catch (Throwable ex) { throw new BeanDefinitionStoreException( &quot;Failed to read candidate component class: &quot; + resource, ex); } } else { if (traceEnabled) { logger.trace(&quot;Ignored because not readable: &quot; + resource); } } } } catch (IOException ex) { throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, ex); } return candidates; } 到这里 我们算是差不多看完了scanner的扫描注册过程 扫描注册过程不过循环base-package路径下面的所有类 看是否有标注特定注解(硬编码)的类 将这些类转化成bd 供我们后续使用 这里要注意的就是这里不能将类实例化我们再回到ComponentScanBeanDefinitionParser的parse()方法 看下registerComponents()方法registerComponents()方法中除了组件外 还有一个比较重要的事情 就是注册我们后面属性填充(IOC)需要用到的一些BPP 例如@Resouce @Autowired等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 protected void registerComponents( XmlReaderContext readerContext, Set&lt;BeanDefinitionHolder&gt; beanDefinitions, Element element) &#123; Object source = readerContext.extractSource(element); CompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), source); for (BeanDefinitionHolder beanDefHolder : beanDefinitions) &#123; compositeDef.addNestedComponent(new BeanComponentDefinition(beanDefHolder)); &#125; // Register annotation config processors, if necessary. // 默认注册 boolean annotationConfig = true; if (element.hasAttribute(ANNOTATION_CONFIG_ATTRIBUTE)) &#123; annotationConfig = Boolean.valueOf(element.getAttribute(ANNOTATION_CONFIG_ATTRIBUTE)); &#125; if (annotationConfig) &#123; //这里注册我们需要的BPP Set&lt;BeanDefinitionHolder&gt; processorDefinitions = AnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source); for (BeanDefinitionHolder processorDefinition : processorDefinitions) &#123; compositeDef.addNestedComponent(new BeanComponentDefinition(processorDefinition)); &#125; &#125; readerContext.fireComponentRegistered(compositeDef); &#125; public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors( BeanDefinitionRegistry registry, Object source) &#123; Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(4); // @Configuration if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; //@Autowired @Value if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; //@Required if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; //@PostConsruct @Resouce 等java注解 // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor. if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; // // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor. if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(); try &#123; def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, AnnotationConfigUtils.class.getClassLoader())); &#125; catch (ClassNotFoundException ex) &#123; throw new IllegalStateException( &quot;Cannot load optional framework class: &quot; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex); &#125; def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; return beanDefs; &#125; 总的来说 component-scan 做了什么事情就比较清晰了 下面做一下总结 根据配置生成扫描类ClassPathBeanDefinitionScanner 扫描注册包下符合匹配规则的类 扫描注册被@Controller @Service @Respsitory @Component @Configuration等标注的类 因为@Controller @Service @Respsitory注解的元注解包含@Component 也就是说@Controller @Service @Respsitory本身被@Component标注 而匹配规则中有一条就是元注解包含@Component @Named 或者 @ManagedBean 注册处理如@Resouce @Autowired @PostConstruct等的BPP 当然由于篇幅限制 并没有把所有的知识点都讲到 很多也是点到 那些东西需要读者有时间的时候自己跟着代码走一遍了那么又出现一个问题：既然@Controller注解标注的类也被像普通bean一样注册了 那么在web项目中 又是怎么知道哪些是我们需要的Controller类呢?且听下回分析…","tags":[]},{"title":"Tomcat源码分析环境搭建","date":"2017-04-16T07:18:00.000Z","path":"2017/04/16/Tomcat源码分析环境搭建/","text":"","tags":[]},{"title":"2017阅读书单(持续更新)","date":"2017-04-16T05:46:48.000Z","path":"2017/04/16/2017阅读书单/","text":"技术书单 How Tomcat Works Spring源码深度解析 ActiveMQ in Action(英文版) 成长 巨婴国 被嫌弃的松子的一生 丘吉尔:我的早年生活 梦幻花 如何阅读一本书 黄金时代 月亮与六便士","tags":[]},{"title":"Spring源码分析环境搭建","date":"2017-04-15T13:28:22.000Z","path":"2017/04/15/Spring源码环境搭建/","text":"想研究spring源码的第一步当然是源码的搭建 推荐大家使用idea集成开发环境 下面的搭建过程也以idea为基础需要gradle git环境 不再叙述从github仓库中clone一份代码到本地git clone -b 3.2.x git@github.com:spring-projects/spring-framework.git这里需要注意的是你所使用的jdk版本与spring源码所需要的版本的匹配问题 如果你使用的jdk版本是1.7 而clone的是4以上的spring源码的话 那么comiple的时候就会报错查看源码目录下的 import-into-idea.md 文件 发现步骤可真简单 到spring源码的目录下cd your_spring_dir 执行命令 ./gradlew :spring-oxm:compileTestJava cleanIdea idea 这个过程可能比较慢 感觉卡住的话 ctrl+c 结束执行再重新执行命令 多试几次就好了 导入idea","tags":[]},{"title":"当我谈源码时,我谈些什么","date":"2017-04-15T07:06:19.000Z","path":"2017/04/15/当我谈源码时-我谈些什么/","text":"我们为什么要阅读源码 | 阅读源码给我们带来了什么 简单方面来说，阅读源码使我们更了解所使用的框架，深入其实现原理 更深入方面，我觉得阅读源码是一次提升的机会，提升自己抽象能力，学习大师们解决问题的思路. 阅读源码常见误区 每行代码都要搞懂是什么意思对于一个开源框架 以Tomcat 或者 Spring源码来说 每行代码都要理解的话 一方面会需要大量的时间 另一方面可能会被琐碎但又不那么重要的代码逻辑缠住 可谓是：捡了芝麻 丢了西瓜 要做到: 有的放矢 阅读源码的方法不对阅读源码并不是说把源码导入到集成开发环境中 就不管三七二十一的看起来 要找到切入点 借助开发工具提供的能力 多看看类的层次结构 多思考 学习大牛的抽象能力与分解|解决问题的能力 这两个能力在Tomcat，Spring源码中会达到让你惊叹的地步","tags":[]},{"title":"Unknown system variable 'storage_engine'解决办法","date":"2017-04-14T03:02:18.000Z","path":"2017/04/14/Unknown-system-variable-storage-engine-解决办法/","text":"安装MySQL employees数据库，出现问题，mysql版本为：mysql Ver 14.14 Distrib 5.7.10, for Linux (x86_64) using EditLine wrapper mysql默认的数据库存储引擎是innodb,正好出错的也是这行，提示没有storage_engine变量。好像14以后的msql storage_engine变量更名为default_storage_engine，可是我更改为set default_storage_engine = innodb,还是这行出错，没办法，只能注释掉这样了，反正默认就是innodb引擎。下面说注意事项： 在employees.sql文件中，注释掉(也就是让这行不生效)的时候除了在这行的最前面加’–’外，’–’要跟后面的字符空一个格才生效。即 12345678-- set default_storage_engine = InnoDB -- set storage_engine = InnoDB; -- set storage_engine = MyISAM; -- set storage_engine = Falcon; -- set storage_engine = PBXT; -- set storage_engine = Maria; -- select CONCAT(&apos;storage engine: &apos;, @@storage_engine) as INFO; 不要忘了把INFO那行注释掉，其实这行只是安装的时候提示你安装到哪里了，如果出错的话，好排查。像上面那样注释掉后，再安装就可以了.","tags":[]},{"title":"mac安装sequelpro","date":"2017-04-14T02:55:49.000Z","path":"2017/04/14/mac安装sequelpro/","text":"mac安装sequelpro遇到的问题： 不像其他dmg镜像一样 打开后有一个拖到应用程序的界面 下载sequelpro后 只能以挂载镜像的方式打开 这样的话 倒是可以用 但一直有一个挂载镜像在哪 不舒服 找来找去还是靠一句英文搞定的: how to install sequelpro on mac 然后让我找到了下面一个地址 http://macappstore.org/sequel-pro/照着上面的提示总算安装好了 不过过程中还是遇到了一些问题，安装brew的时候出现了问题 建议去homebrew官网去 官网有安装命令 照着那个安装 可能会因为网络因素什么的 会安装失败 多试几次就好了 终于安装成功 国人的博客啊 很多还是抄来抄去的 不着调 看来跟学生时代 作业抄多了有关系 学习英文 没坏处","tags":[]},{"title":"nginx反向代理解决mac上tomcat80端口问题","date":"2017-04-14T02:47:14.000Z","path":"2017/04/14/nginx反向代理解决mac上tomcat80端口问题/","text":"问题背景：mac的1024以下端口管理比较严格，搞了好久也没能让本地tomcat开启80端口，开启其他大于1024端口的倒是可以，但是这样不利用访问，访问web的时候，需要每次都带着端口访问，链接跳着跳着端口就有问题了，后来稍微了解了下nginx的知识，着手用nginx的反向代理能力去解决此问题。大概思路是让nginx开启80端口(这个倒是可以开启80端口 orz) 然后遇到自己设置的servername的时候再反向代理到本地tomcat开启的端口，比如8080 或者9090端口 mac安装nginx的功能就再说了，可以用brew安装也可以编译安装，自行百度，我好像是用brew安装的 我web开发工具用的是idea,怎么建tomcat也不说了，不是这篇文章的目的,tomcat的端口的话就用默认的8080就可以了。 修改nginx的配置文件nginx.conf 如果路径不一样的，自行更改 1$ sudo vim /usr/local/etc/nginx/nginx.conf 重要的都用箭头标出来了 listen 80：表示nginx监听80端口 server_name : 可以有多个 这里需要注意的是 每个域名要在hosts文件中绑定IP到127.0.0.1 不然还是拦截不到的 这点需要注意 access_log: 访问日志 可以打开 打开的话要把后面的main去掉 location： / 拦截所有访问本地80端口的路径 这是个正则表达式 有兴趣的可以去搜搜看 可以写成其他的正则 proxy_pass http://127.0.0.1:8080 这句就是核心了 将访问的80端口导到本地的8080端口(我的本地tomcat开启的端口) 开启nginx 1$ sudo nginx 大功告成！","tags":[]},{"title":"mysql禁用validate_password插件","date":"2017-04-14T02:36:01.000Z","path":"2017/04/14/mysql禁用validate_password插件/","text":"新版本的MySQL默认开启了validate_password插件，进行密码验证，需要很强的密码强度才能通过认证，如果是自己玩玩的话没必要那么复杂，如果是公司的话，还是不要禁用了。其实关闭插件很简单，在mysql配置文件(centos系统下是/etc/my.conf)里面[mysqld]选项下面添加下面一条语句即可 1validate_password=off 记得配置后要重启mysql.在shell下面运行下面两条语句： 12service mysqld stop service mysqld start 如果不想关闭，而是想修改密码强度的话，可以看看下面这篇文档，我就不多做解释了。http://dev.mysql.com/doc/refman/5.6/en/validate-password-plugin.html#option_mysqld_validate-password","tags":[]},{"title":"Hello World","date":"2017-04-13T16:00:00.000Z","path":"2017/04/14/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]