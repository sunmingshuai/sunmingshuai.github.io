[{"title":"Spring问题快问快答","date":"2017-12-31T12:21:34.000Z","path":"2017/12/31/Spring问题快问快答/","text":"这篇文章主要是博主平时遇到的问题 后来经过不断的学习 又被自己解决的问题 如果读者有什么问题的话 可以在下面留言 我会尽力解答 暂时没有目录 以后会想办法解决这个问题 @Controller与@Component注解有什么不同 文章 component-scan做了些什么 最后问出的问题@Controller注解的作用只是注册普通bean 这是spring团队为了适应mvc所写的一个注解 让人一看就知道这是个控制器 真正起到路由作用的是@RequestMapping注解 spring会根据这个类上面有没有@RequestMapping来最终判定这个类是不是控制器 Tomcat中DefaultServlet拦截的路径是/ 而spring中DispatcherServlet一般拦截的路径也是/ 那为什么最后请求会给DispatcherServlet而不是DefaultServlet呢 待解 servlet过滤器 spring过滤器有什么不同 待解 @Before @Around @After的执行顺序?如果我们把@Around注解方法拆分为三块：around_before,proxy_method(被代理的方法 即调用proceedingJoinPoint.proceed()那部分),around_after那么执行顺序为:before_advice-&gt;around_before-&gt;proxy_method-&gt;around-&gt;after-&gt;after至于执行结果为什么是这样的 可以看下面的博文@Before @Around @After的执行顺序源码解析","tags":[]},{"title":"aop源码解析二:寻找Advisor","date":"2017-04-21T04:34:05.000Z","path":"2017/04/21/aop源码解析二-寻找Advisor/","text":"写在前面这一部分的内容 会比较多 如果只是看代码的话 可能不够直观 所以这个时候我们就需要使出程序员必备技能DEBUG 当然前提是你已经搭建好了环境 如果没有话 请点击Spring源码分析环境搭建我们分析的这一部分的代码 spring中已经有了相关的测试类AspectJAutoProxyCreatorTests 相信结合下面的分析的话 读者是能够看懂这部分代码的.","tags":[{"name":"aop","slug":"aop","permalink":"http://yoursite.com/tags/aop/"}]},{"title":"aop源码解析一:注册BPP","date":"2017-04-20T05:25:52.000Z","path":"2017/04/20/aop源码解析一/","text":"本文目的如题,标签&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; expose-proxy=&quot;true&quot;/&gt;注册BPP(AspectJAutoProxyBeanDefinitionParser)源码分析 并没有介绍过BPP相关内容 这里简单的讲解下 读者心里有个概念就行 等有时间补写Bean的加载与读取的时候 会好好介绍这个重要的类!首先 spring在一些特殊的位置插入了一些处理代码(可能有些读者觉得这句话很眩 不太好理解 我换种表达方式:从加载配置文件到转换成对应的定义类 比如BeanDefinition 再到获取bean 这一整个过程都是spring在做的 他当然能够在任意想插的位置插入代码了) 例如在实例化前后 或者在初始化前后调的方法 这些类一般是BeanPostProcessor的子类 简称BPP 正文对于aop这样的非标准或者称为自定义命名空间的元素 spring会从spring.handlersspring.handlers文件中的对应关系找到相应的处理类 然后通过init()方法注册一些处理器 aop命名空间的处理类是AopNamespaceHandler 我们看一下他的init()方法 public void init() { // In 2.0 XSD as well as in 2.1 XSD. registerBeanDefinitionParser(&quot;config&quot;, new ConfigBeanDefinitionParser()); // registerBeanDefinitionParser(&quot;aspectj-autoproxy&quot;, new AspectJAutoProxyBeanDefinitionParser()); registerBeanDefinitionDecorator(&quot;scoped-proxy&quot;, new ScopedProxyBeanDefinitionDecorator()); // Only in 2.0 XSD: moved to context namespace as of 2.1 registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser()); } 从上面注册的处理器的关系我们知道 &lt;aop:aspectj-autoproxy&gt;标签的处理器是AspectJAutoProxyBeanDefinitionParser 同样 这是一个继承于BeanDefinitionParser的标准的解析器 我们看一下他的parse()方法 public BeanDefinition parse(Element element, ParserContext parserContext) { //注册BPP(AnnotationAwareAspectJAutoProxyCreator) AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element); // 如果有子元素的话 设置属性 extendBeanDefinition(element, parserContext); return null; } parse()方法可以说主要做了一件事情就是注册了一个BPP(BeanPostProcessor) 供后续使用 有些人看到这里可能就蒙圈了 这什么东西 名字这么长 看到后面的时候又会说这是什么东西 类的名字这么长 然后就会觉得好难 主要是读者阅读代码不多的原因 如果阅读的多了 你就会形成一个感觉：不管这个类名字多奇怪 名字多长 不过是一些基本类型(map list等)的包装而已 为了完成某一个功能所做的封装而已 //spring中的方法一般都比较清晰 短短的几行代码告诉了你这个方法要做什么事情 public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary( ParserContext parserContext, Element sourceElement) { //注册BPP(AnnotationAwareAspectJAutoProxyCreator) BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary( parserContext.getRegistry(), parserContext.extractSource(sourceElement)); //根据xml配置 设置AnnotationAwareAspectJAutoProxyCreator的proxyTargetClass exposeProxy属性 useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement); //注册组件bean 并暴露给外部 registerComponentIfNecessary(beanDefinition, parserContext); } 不断的追踪registerAspectJAnnotationAutoProxyCreatorIfNecessary()方法发现 就是注册了个BPP(AspectJAutoProxyBeanDefinitionParser) 不再贴出相关代码 我们看下useClassProxyingIfNecessary()方法 //处理proxy-target-class 以及 expose-proxy属性 private static void useClassProxyingIfNecessary(BeanDefinitionRegistry registry, Element sourceElement) { if (sourceElement != null) { //proxy-target-class true:强制使用CGLIB代理 推荐使用 boolean proxyTargetClass = Boolean.valueOf(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE)); if (proxyTargetClass) { AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry); } //expose-proxy true:暴露代理类 解决某些情况下 代理无法完成的情况 boolean exposeProxy = Boolean.valueOf(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE)); if (exposeProxy) { AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry); } } } 总结似乎&lt;aop:aspectj-autoproxy&gt;标签做的事情并不多 只是注册了一个BPP 但是这个BPP确实非常重要的! 我们用到的切面编程就依靠这个BPP去驱动实现 后面的文章会介绍这个BPP的源码是怎么实现AOP的","tags":[{"name":"aop","slug":"aop","permalink":"http://yoursite.com/tags/aop/"}]},{"title":"aop功能实现口述","date":"2017-04-19T10:22:15.000Z","path":"2017/04/19/aop功能实现口述/","text":"spring-aop功能 涉及到的东西很多 比如 切面 CGLIB 责任链等 这些东西会讲到 但不会详细讲解 一来是因为篇幅限制 另外博客的目的还是授人以鱼不如授人以渔 为了让大家能阅读下面几篇关于aop的文章更顺利些 这里先给读者讲一下 spring实现aop大概的流程以及涉及到的一些名词 因为注解形式的友好性 大家用的比较多 所以我们只谈这种形式的实现 aop 面向切面编程(AOP) :面向对象编程(OOP)的一种扩展 可以这样理解 我们之前所做的所有功能大体来说都是线性的(好比在流淌在水管里的水 一直是往前流动的 很难纵向扩展) 如果我们想加一些公共的服务 比如说日志 登录检查等 OOP将会有大量的重复代码 pointcut 连接点 就是这些额外的动作的发生点 advice 切面 就是我们上面说的那些公共服务 比如说日志 登录检查等 advisor 我们这里说的advisor 是实现代码里面的advisor 是一个封装类 包括了pointcut(验证是否跟指定方法匹配的功能) 与 advice 流程: 我们暂时把spring加载bean的过程笼统的分为两个阶段 spring加载配置文件并根据配置文件或者注解生成BeanDefinition的过程。 BeanDefinition看这个词的意思就略知一二 如果你看过tomcat的源码的话 应该会让你想起servletconfig 主要是用来保存bean的配置信息 如果bean是prototype类型的 那么下次就不用在加载了 spring提前加载非懒惰的bean的过程 很显然 aop的实现就是在第二个阶段 bean有几个比较特殊的阶段 比如实例化(instantiate) 初始化(initiate) 那么就可以在这几个特殊阶段的前后加一些方法 实现扩展 spring在bean初始化完成后的时机 完成了 找出所有切面类的切面方法 未完","tags":[{"name":"aop","slug":"aop","permalink":"http://yoursite.com/tags/aop/"}]},{"title":"component-scan做了些什么|源码解读","date":"2017-04-17T09:35:35.000Z","path":"2017/04/17/component-scan做了些什么/","text":"写在前面看spring代码中途的过程中才开始写博客的 所以这篇博客假设你看过spring读取配置文件 解析标准&lt;bean&gt;标签的功能 以后会把这部分内容补上 本文目的本文主要解决一个问题就是component-scan会扫描注册哪些注解标注的类 被@Controller标注的类会被扫描注册吗? 正文当遇到component-scan这样非标准或者称为自定义的元素标签时 spring会通过spring.handlers文件中的对应关系http\\://www.springframework.org/schema/context= org.springframework.context.config.ContextNamespaceHandler找到ContextNamespaceHandler 通过ContextNamespaceHandler类init()方法自动注册一些解析器 下面列出了所有以context为命名空间的组合 例如常见的&lt;context:componet-scan&gt;元素 根据注册对应关系 知道其对应的解析器为ComponentScanBeanDefinitionParser public void init() { registerBeanDefinitionParser(&quot;property-placeholder&quot;, new PropertyPlaceholderBeanDefinitionParser()); registerBeanDefinitionParser(&quot;property-override&quot;, new PropertyOverrideBeanDefinitionParser()); registerBeanDefinitionParser(&quot;annotation-config&quot;, new AnnotationConfigBeanDefinitionParser()); registerBeanDefinitionParser(&quot;component-scan&quot;, new ComponentScanBeanDefinitionParser()); registerBeanDefinitionParser(&quot;load-time-weaver&quot;, new LoadTimeWeaverBeanDefinitionParser()); registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser()); registerBeanDefinitionParser(&quot;mbean-export&quot;, new MBeanExportBeanDefinitionParser()); registerBeanDefinitionParser(&quot;mbean-server&quot;, new MBeanServerBeanDefinitionParser()); } 那我们看一下&lt;context:component-scan&gt;的解析器ComponentScanBeanDefinitionParser的源码 (ComponentScanBeanDefinitionParser继承自BeanDefinitionParser) spring解析&lt;context:component-scan&gt;的时候会调用ComponentScanBeanDefinitionParser的parse()函数 //element 代表的是完整的&lt;context:component-scan&gt;标签 //parserContext 解析的上下文环境 能拿到一些诸如readerContext registry等变量 public BeanDefinition parse(Element element, ParserContext parserContext) { //将指定base-package拆分成string数组的形式 String[] basePackages = StringUtils.tokenizeToStringArray(element.getAttribute(BASE_PACKAGE_ATTRIBUTE), ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); // 根据xml配置或者默认配置(如果没有指定的话)配置扫描器ClassPathBeanDefinitionScanner ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element); //scanner扫描包下面含有特殊注解标注的类 //@Component @Named @ManagedBean (@Controller @Service @Repository @Configuration)都会被注册 Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages); // 注册组件以及一些我们常见的注解处理器(BPP) 如@Resouce @Autowired @Configuration @Value @Required @PostConstruct //那么以后看到属性注入(IOC/DI)的时候 就不会奇怪 这些注解的处理器(BPP)是在哪里注册的了 在这里! registerComponents(parserContext.getReaderContext(), beanDefinitions, element); return null; } 看一下scanner的创建以及设置 protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) { XmlReaderContext readerContext = parserContext.getReaderContext(); boolean useDefaultFilters = true; if (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) { useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)); } // 生成scanner的时候 在其父类构造函数中调用了`registerDefaultFilters()`方法中加入了3个注解类型的typeFilter 分别是@Component // @ManagedBean @Named 意思也就是看类上面有没有这三个注解或者注解的元注解中是否含有这三个注解之一 // 这里虽然没有加入如@Service的注解 但看@Service的定义会发现@Service注解也被@Component给标注了 ClassPathBeanDefinitionScanner scanner = createScanner(readerContext, useDefaultFilters); scanner.setResourceLoader(readerContext.getResourceLoader()); scanner.setEnvironment(parserContext.getDelegate().getEnvironment()); // 利用spring 启动的时候根据xml文件或者默认配置(如果没有指定的话)生成的BeanDefinition规则 scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults()); scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns()); if (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) { scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE)); } try { // 扫描注解定义的bean 需要定义一种beanName的生成规则 一般是驼峰命名法 parseBeanNameGenerator(element, scanner); } catch (Exception ex) { readerContext.error(ex.getMessage(), readerContext.extractSource(element), ex.getCause()); } try { // bean的scope singleton?prototype? parseScope(element, scanner); } catch (Exception ex) { readerContext.error(ex.getMessage(), readerContext.extractSource(element), ex.getCause()); } // 根据xml配置生成includeFilter excludeFilter 在创建scanner类的时候 就硬编码进去了3个注解类型 // 的typeFilter到includeFilter里面 // 类必须满足以下条件才会被注册 因为@Component等是被硬编码进去的 所以只有下面一种情况才会被注册了 // 不被excludeFilter匹配 并且被includeFilter匹配 parseTypeFilters(element, scanner, readerContext, parserContext); return scanner; } 下面在看一下真正的扫描过程doScan 我们发现spirng中真正干活的一般都是以do开头 前面的那么多只是为了做铺垫 单一指责 protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) { Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;); Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(); for (String basePackage : basePackages) { //寻找被@Component或者@Named注解标注的类 或者 类的注解的元注解中含有这两个注解 例如常见的@Respsitory @Controller @Service Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); // 对于生成的AnnotatedBeanDefinition做一些转化工作 例如前面说到的应用bd(BeanDefinition)默认配置 // 处理@Primary @Lazy @DependsOn @Role注解等 // 转化成BeanDefinitionHolder对象 for (BeanDefinition candidate : candidates) { ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) { postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); } if (candidate instanceof AnnotatedBeanDefinition) { AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); } if (checkCandidate(beanName, candidate)) { BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); //注册到容器中 registerBeanDefinition(definitionHolder, this.registry); } } } return beanDefinitions; } 看一下findCandidateComponents方法 public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) { Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;BeanDefinition&gt;(); try { String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + &quot;/&quot; + this.resourcePattern; //这里的resouces代表的就是路径下的各个类了 Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath); boolean traceEnabled = logger.isTraceEnabled(); boolean debugEnabled = logger.isDebugEnabled(); for (Resource resource : resources) { if (traceEnabled) { logger.trace(&quot;Scanning &quot; + resource); } if (resource.isReadable()) { try { // 这一步的作用就是能够不必加载class但能拿到class各种属性 并且这里也不能载入class(有很多是单例模式) 还没到那一步 // 只是为了做匹配 生成bd而已 MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); // 根据includeFilters excludeFilters做匹配 因为篇幅的限制 不详谈 有兴趣的可以研究一下typeFilter的实现 if (isCandidateComponent(metadataReader)) { ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); if (isCandidateComponent(sbd)) { if (debugEnabled) { logger.debug(&quot;Identified candidate component class: &quot; + resource); } candidates.add(sbd); } else { if (debugEnabled) { logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource); } } } else { if (traceEnabled) { logger.trace(&quot;Ignored because not matching any filter: &quot; + resource); } } } catch (Throwable ex) { throw new BeanDefinitionStoreException( &quot;Failed to read candidate component class: &quot; + resource, ex); } } else { if (traceEnabled) { logger.trace(&quot;Ignored because not readable: &quot; + resource); } } } } catch (IOException ex) { throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, ex); } return candidates; } 到这里 我们算是差不多看完了scanner的扫描注册过程 扫描注册过程不过循环base-package路径下面的所有类 看是否有标注特定注解(硬编码)的类 将这些类转化成bd 供我们后续使用 这里要注意的就是这里不能将类实例化我们再回到ComponentScanBeanDefinitionParser的parse()方法 看下registerComponents()方法registerComponents()方法中除了组件外 还有一个比较重要的事情 就是注册我们后面属性填充(IOC)需要用到的一些BPP 例如@Resouce @Autowired等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 protected void registerComponents( XmlReaderContext readerContext, Set&lt;BeanDefinitionHolder&gt; beanDefinitions, Element element) &#123; Object source = readerContext.extractSource(element); CompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), source); for (BeanDefinitionHolder beanDefHolder : beanDefinitions) &#123; compositeDef.addNestedComponent(new BeanComponentDefinition(beanDefHolder)); &#125; // Register annotation config processors, if necessary. // 默认注册 boolean annotationConfig = true; if (element.hasAttribute(ANNOTATION_CONFIG_ATTRIBUTE)) &#123; annotationConfig = Boolean.valueOf(element.getAttribute(ANNOTATION_CONFIG_ATTRIBUTE)); &#125; if (annotationConfig) &#123; //这里注册我们需要的BPP Set&lt;BeanDefinitionHolder&gt; processorDefinitions = AnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source); for (BeanDefinitionHolder processorDefinition : processorDefinitions) &#123; compositeDef.addNestedComponent(new BeanComponentDefinition(processorDefinition)); &#125; &#125; readerContext.fireComponentRegistered(compositeDef); &#125; public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors( BeanDefinitionRegistry registry, Object source) &#123; Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(4); // @Configuration if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; //@Autowired @Value if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; //@Required if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; //@PostConsruct @Resouce 等java注解 // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor. if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; // // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor. if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(); try &#123; def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, AnnotationConfigUtils.class.getClassLoader())); &#125; catch (ClassNotFoundException ex) &#123; throw new IllegalStateException( &quot;Cannot load optional framework class: &quot; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex); &#125; def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; return beanDefs; &#125; 总的来说 component-scan 做了什么事情就比较清晰了 下面做一下总结 根据配置生成扫描类ClassPathBeanDefinitionScanner 扫描注册包下符合匹配规则的类 扫描注册被@Controller @Service @Respsitory @Component @Configuration等标注的类 因为@Controller @Service @Respsitory注解的元注解包含@Component 也就是说@Controller @Service @Respsitory本身被@Component标注 而匹配规则中有一条就是元注解包含@Component @Named 或者 @ManagedBean 注册处理如@Resouce @Autowired @PostConstruct等的BPP 当然由于篇幅限制 并没有把所有的知识点都讲到 很多也是点到 那些东西需要读者有时间的时候自己跟着代码走一遍了那么又出现一个问题：既然@Controller注解标注的类也被像普通bean一样注册了 那么在web项目中 又是怎么知道哪些是我们需要的Controller类呢?且听下回分析…","tags":[{"name":"component-scan","slug":"component-scan","permalink":"http://yoursite.com/tags/component-scan/"}]},{"title":"Tomcat源码分析环境搭建","date":"2017-04-16T07:18:00.000Z","path":"2017/04/16/Tomcat源码分析环境搭建/","text":"阅读源码的第一步就是把环境搭建起来 并能够调试 这样在某些情况下 能帮助你更好的阅读源代码 看起来比较直观 在这一点上 我将再次推荐idea这款集成开发环境 简直是神器 安利网上也有比较多的教程教你怎么把tomcat源代码导入到idea中的教程 我就不再浪费时间在重复写了 我当初也是按着那样的步骤来的 相信读者这些应该是自己能够搞定的我就直接把我搭建好的push到了我的github上面 上面有两个分枝 一个是master分支 这个分支是纯净版的 也就是没有我的注释的版本 另外一个分支是tomcat-with-docs 这个分支是我后来阅读源码的过程中写的注释 以后我会出一系列tomcat源码解析的教程所以 如果你想看纯净版的1$ git clone git@github.com:sunmingshuai/apache-tomcat-7.0.73-src.git 或者你想看有注释的1$ git clone -b tomcat-with-docs git@github.com:sunmingshuai/apache-tomcat-7.0.73-src.git 然后当成maven项目导入到idea中就可以了","tags":[]},{"title":"搭建spring web项目供debug使用","date":"2017-04-16T06:58:58.000Z","path":"2017/04/16/搭建spring-web项目供debug使用/","text":"随着阅读源码的深入 越来越了解debug的重要性 要让代码跑起来 想想自己也是阅读了Spring的核心功能模块 搭建起来应该不费劲 顺便说说感受想想刚毕业那会 进到公司 上手的都是已经搭建好的体系 这个阶段属于依胡萝画瓢阶段后来自己上网搜索搭建教程 虽然也能搭建好 但还是不了解其意 仍然是依胡萝画瓢阶段现在刚好有要搭建spring web项目 供我debug的需求 所以就花点时间搭建了一个 总的来说 比较顺畅 而且基本上每个配置都知道它到底干了什么 给我的感觉不一样了我debug总的来说有2个方面 打包放到tomcat的webapps目录 研究tomcat的源码 启动web项目 研究spring源码 具体的搭建过程我就不说了 我搭建的比较简洁 完全为了debug搭建的 没有多余代码 push到了github仓库 感兴趣的可以clone到本地使用 1$ git clone git@github.com:sunmingshuai/springmvcdemo.git 当成maven项目导入到idea/eclipse就可以了以后有需求的话 会不断的加入一些功能并推送","tags":[]},{"title":"2017阅读书单(持续更新)","date":"2017-04-16T05:46:48.000Z","path":"2017/04/16/2017阅读书单/","text":"技术书单 How Tomcat Works Spring源码深度解析 ActiveMQ in Action(英文版) 成长 巨婴国 被嫌弃的松子的一生 丘吉尔:我的早年生活 梦幻花 如何阅读一本书 黄金时代 月亮与六便士","tags":[]},{"title":"Spring源码分析环境搭建","date":"2017-04-15T13:28:22.000Z","path":"2017/04/15/Spring源码环境搭建/","text":"想研究spring源码的第一步当然是源码的搭建 推荐大家使用idea集成开发环境 下面的搭建过程也以idea为基础需要gradle git环境 不再叙述从github仓库中clone一份代码到本地git clone -b 3.2.x git@github.com:spring-projects/spring-framework.git这里需要注意的是你所使用的jdk版本与spring源码所需要的版本的匹配问题 如果你使用的jdk版本是1.7 而clone的是4以上的spring源码的话 那么comiple的时候就会报错查看源码目录下的 import-into-idea.md 文件 发现步骤可真简单 到spring源码的目录下cd your_spring_dir 执行命令 ./gradlew :spring-oxm:compileTestJava cleanIdea idea 这个过程可能比较慢 感觉卡住的话 ctrl+c 结束执行再重新执行命令 多试几次就好了 导入idea","tags":[]},{"title":"当我谈源码时,我谈些什么","date":"2017-04-15T07:06:19.000Z","path":"2017/04/15/当我谈源码时-我谈些什么/","text":"我们为什么要阅读源码 | 阅读源码给我们带来了什么 简单方面来说，阅读源码使我们更了解所使用的框架，深入其实现原理 更深入方面，我觉得阅读源码是一次提升的机会，提升自己抽象能力，学习大师们解决问题的思路. 阅读源码常见误区 每行代码都要搞懂是什么意思对于一个开源框架 以Tomcat 或者 Spring源码来说 每行代码都要理解的话 一方面会需要大量的时间 另一方面可能会被琐碎但又不那么重要的代码逻辑缠住 可谓是：捡了芝麻 丢了西瓜 要做到: 有的放矢 阅读源码的方法不对阅读源码并不是说把源码导入到集成开发环境中 就不管三七二十一的看起来 要找到切入点 借助开发工具提供的能力 多看看类的层次结构 多思考 学习大牛的抽象能力与分解|解决问题的能力 这两个能力在Tomcat，Spring源码中会达到让你惊叹的地步","tags":[]},{"title":"Unknown system variable 'storage_engine'解决办法","date":"2017-04-14T03:02:18.000Z","path":"2017/04/14/Unknown-system-variable-storage-engine-解决办法/","text":"安装MySQL employees数据库，出现问题，mysql版本为：mysql Ver 14.14 Distrib 5.7.10, for Linux (x86_64) using EditLine wrapper mysql默认的数据库存储引擎是innodb,正好出错的也是这行，提示没有storage_engine变量。好像14以后的msql storage_engine变量更名为default_storage_engine，可是我更改为set default_storage_engine = innodb,还是这行出错，没办法，只能注释掉这样了，反正默认就是innodb引擎。下面说注意事项： 在employees.sql文件中，注释掉(也就是让这行不生效)的时候除了在这行的最前面加’–’外，’–’要跟后面的字符空一个格才生效。即 12345678-- set default_storage_engine = InnoDB -- set storage_engine = InnoDB; -- set storage_engine = MyISAM; -- set storage_engine = Falcon; -- set storage_engine = PBXT; -- set storage_engine = Maria; -- select CONCAT(&apos;storage engine: &apos;, @@storage_engine) as INFO; 不要忘了把INFO那行注释掉，其实这行只是安装的时候提示你安装到哪里了，如果出错的话，好排查。像上面那样注释掉后，再安装就可以了.","tags":[]},{"title":"mac安装sequelpro","date":"2017-04-14T02:55:49.000Z","path":"2017/04/14/mac安装sequelpro/","text":"mac安装sequelpro遇到的问题： 不像其他dmg镜像一样 打开后有一个拖到应用程序的界面 下载sequelpro后 只能以挂载镜像的方式打开 这样的话 倒是可以用 但一直有一个挂载镜像在哪 不舒服 找来找去还是靠一句英文搞定的: how to install sequelpro on mac 然后让我找到了下面一个地址 http://macappstore.org/sequel-pro/照着上面的提示总算安装好了 不过过程中还是遇到了一些问题，安装brew的时候出现了问题 建议去homebrew官网去 官网有安装命令 照着那个安装 可能会因为网络因素什么的 会安装失败 多试几次就好了 终于安装成功 国人的博客啊 很多还是抄来抄去的 不着调 看来跟学生时代 作业抄多了有关系 学习英文 没坏处","tags":[]},{"title":"nginx反向代理解决mac上tomcat80端口问题","date":"2017-04-14T02:47:14.000Z","path":"2017/04/14/nginx反向代理解决mac上tomcat80端口问题/","text":"问题背景：mac的1024以下端口管理比较严格，搞了好久也没能让本地tomcat开启80端口，开启其他大于1024端口的倒是可以，但是这样不利用访问，访问web的时候，需要每次都带着端口访问，链接跳着跳着端口就有问题了，后来稍微了解了下nginx的知识，着手用nginx的反向代理能力去解决此问题。大概思路是让nginx开启80端口(这个倒是可以开启80端口 orz) 然后遇到自己设置的servername的时候再反向代理到本地tomcat开启的端口，比如8080 或者9090端口 mac安装nginx的功能就再说了，可以用brew安装也可以编译安装，自行百度，我好像是用brew安装的 我web开发工具用的是idea,怎么建tomcat也不说了，不是这篇文章的目的,tomcat的端口的话就用默认的8080就可以了。 修改nginx的配置文件nginx.conf 如果路径不一样的，自行更改 1$ sudo vim /usr/local/etc/nginx/nginx.conf 重要的都用箭头标出来了 listen 80：表示nginx监听80端口 server_name : 可以有多个 这里需要注意的是 每个域名要在hosts文件中绑定IP到127.0.0.1 不然还是拦截不到的 这点需要注意 access_log: 访问日志 可以打开 打开的话要把后面的main去掉 location： / 拦截所有访问本地80端口的路径 这是个正则表达式 有兴趣的可以去搜搜看 可以写成其他的正则 proxy_pass http://127.0.0.1:8080 这句就是核心了 将访问的80端口导到本地的8080端口(我的本地tomcat开启的端口) 开启nginx 1$ sudo nginx 大功告成！","tags":[]},{"title":"mysql禁用validate_password插件","date":"2017-04-14T02:36:01.000Z","path":"2017/04/14/mysql禁用validate_password插件/","text":"新版本的MySQL默认开启了validate_password插件，进行密码验证，需要很强的密码强度才能通过认证，如果是自己玩玩的话没必要那么复杂，如果是公司的话，还是不要禁用了。其实关闭插件很简单，在mysql配置文件(centos系统下是/etc/my.conf)里面[mysqld]选项下面添加下面一条语句即可 1validate_password=off 记得配置后要重启mysql.在shell下面运行下面两条语句： 12service mysqld stop service mysqld start 如果不想关闭，而是想修改密码强度的话，可以看看下面这篇文档，我就不多做解释了。http://dev.mysql.com/doc/refman/5.6/en/validate-password-plugin.html#option_mysqld_validate-password","tags":[]},{"title":"Hello World","date":"2017-04-13T16:00:00.000Z","path":"2017/04/14/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]