[{"title":"component-scan做了些什么","date":"2017-04-17T09:35:35.000Z","path":"2017/04/17/component-scan做了些什么/","text":"写在前面看spring代码中途的过程中才开始写博客的 所以这篇博客假设你看过spring读取配置文件 解析标准&lt;bean&gt;标签的功能 以后会把这部分内容补上 本文目的本文主要解决一个问题就是component-scan会扫描注册哪些注解标注的类 被@Controller标注的类会被扫描注册吗? 正文当遇到component-scan这样非标准或者称为自定义的元素标签时 spring会通过spring.handlers文件中的对应关系http\\://www.springframework.org/schema/context= org.springframework.context.config.ContextNamespaceHandler找到ContextNamespaceHandler 通过ContextNamespaceHandler类init()自动注册一些解析器 下面列出了context的所有的组合内容 例如常见的元素 根据注册对应关系 知道其对应的解析器为ComponentScanBeanDefinitionParser property-placeholder property-override annotation-config component-scan load-time-weaver spring-configured mbean-export mbean-server 那我们看一下&lt;context:component-scan&gt;的解析器ComponentScanBeanDefinitionParser的源码 ComponentScanBeanDefinitionParser继承自BeanDefinitionParser spring解析&lt;context:component-scan&gt;的时候会调用ComponentScanBeanDefinitionParser的parse()函数 //element 代表的是完整的&lt;context:component-scan&gt;标签 //parserContext 解析的上下文环境 能拿到一些诸如readerContext registry等变量 public BeanDefinition parse(Element element, ParserContext parserContext) { //将指定base-package拆分成string数组的形式 String[] basePackages = StringUtils.tokenizeToStringArray(element.getAttribute(BASE_PACKAGE_ATTRIBUTE), ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); // 根据xml配置或者默认配置(如果没有指定的话)配置扫描器ClassPathBeanDefinitionScanner ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element); //scanner扫描包下面含有特殊注解标注的类 //@Component @Named @ManagedBean (@Controller @Service @Repository)都会被注册 Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages); registerComponents(parserContext.getReaderContext(), beanDefinitions, element); return null; } 看一下scanner的创建以及设置 protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) { XmlReaderContext readerContext = parserContext.getReaderContext(); boolean useDefaultFilters = true; if (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) { useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)); } // 生成scanner的时候 在其父类构造函数中调用了`registerDefaultFilters()`方法中加入了3个注解类型的typeFilter 分别是@Component // @ManagedBean @Named 意思也就是看类上面有没有这三个注解或者注解的元注解中含有这三个注解之一 // 这里虽然没有加入如@Service的注解 但看@Service的定义会发现@Service注解也被@Component给标注了 ClassPathBeanDefinitionScanner scanner = createScanner(readerContext, useDefaultFilters); scanner.setResourceLoader(readerContext.getResourceLoader()); scanner.setEnvironment(parserContext.getDelegate().getEnvironment()); // 利用spring 启动的时候根据xml文件或者默认配置(如果没有指定的话)生成的BeanDefinition规则 scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults()); scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns()); if (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) { scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE)); } try { // 扫描注解定义的bean 需要定义一种beanName的生成规则 一般是驼峰命名法 parseBeanNameGenerator(element, scanner); } catch (Exception ex) { readerContext.error(ex.getMessage(), readerContext.extractSource(element), ex.getCause()); } try { // bean的scope singleton?prototype? parseScope(element, scanner); } catch (Exception ex) { readerContext.error(ex.getMessage(), readerContext.extractSource(element), ex.getCause()); } // 根据xml配置生成includeFilter excludeFilter 在创建scanner类的时候 就硬编码进去了3个注解类型 // 的typeFilter到includeFilter里面 // 类必须满足以下条件才会被注册 因为@Component等是被硬编码进去的 所以只有下面一种情况才会被注册了 // 不被excludeFilter匹配 并且被includeFilter匹配 parseTypeFilters(element, scanner, readerContext, parserContext); return scanner; } 下面在看一下真正的扫描过程doScan 我们发现spirng中真正干活的一般都是以do开头 前面的那么多只是为了做铺垫 单一指责 protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) { Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;); Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(); for (String basePackage : basePackages) { //寻找被@Component或者@Named注解标注的类 或者 类的注解的元注解中含有这两个注解 例如常见的@Respsitory @Controller @Service Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); // 对于生成的AnnotatedBeanDefinition做一些转化工作 例如前面说到的应用bd(BeanDefinition)默认配置 // 处理@Primary @Lazy @DependsOn @Role注解等 // 转化成BeanDefinitionHolder对象 for (BeanDefinition candidate : candidates) { ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) { postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); } if (candidate instanceof AnnotatedBeanDefinition) { AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); } if (checkCandidate(beanName, candidate)) { BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); //注册到容器中 registerBeanDefinition(definitionHolder, this.registry); } } } return beanDefinitions; } 看一下findCandidateComponents方法 public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) { Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;BeanDefinition&gt;(); try { String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + &quot;/&quot; + this.resourcePattern; //这里的resouces代表的就是路径下的各个类了 Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath); boolean traceEnabled = logger.isTraceEnabled(); boolean debugEnabled = logger.isDebugEnabled(); for (Resource resource : resources) { if (traceEnabled) { logger.trace(&quot;Scanning &quot; + resource); } if (resource.isReadable()) { try { // 这一步的作用就是能够不必加载class但能拿到class各种属性 并且这里也不能载入class(有很多是单例模式) 还没到那一步 // 只是为了做匹配 生成bd而已 MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); // 根据includeFilters excludeFilters做匹配 因为篇幅的限制 不详谈 有兴趣的可以研究一下typeFilter的实现 if (isCandidateComponent(metadataReader)) { ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); if (isCandidateComponent(sbd)) { if (debugEnabled) { logger.debug(&quot;Identified candidate component class: &quot; + resource); } candidates.add(sbd); } else { if (debugEnabled) { logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource); } } } else { if (traceEnabled) { logger.trace(&quot;Ignored because not matching any filter: &quot; + resource); } } } catch (Throwable ex) { throw new BeanDefinitionStoreException( &quot;Failed to read candidate component class: &quot; + resource, ex); } } else { if (traceEnabled) { logger.trace(&quot;Ignored because not readable: &quot; + resource); } } } } catch (IOException ex) { throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, ex); } return candidates; } 总的来说 component-scan 做了什么事情就比较清晰了 下面做一下总结 根据配置生成扫描类ClassPathBeanDefinitionScanner 扫描注册包下符合匹配规则的类 扫描注册被@Controller @Service @Respsitory @Component等标注的类 因为@Controller @Service @Respsitory注解的元注解包含@Component 也就是说@Controller @Service @Respsitory本身被@Component标注 而匹配规则中有一条就是元注解包含@Component @Named 或者 @ManagedBean 当然由于篇幅限制 并没有把所有的知识点都讲到 很多也是点到 那些东西需要读者有时间的时候自己跟着代码走一遍了","tags":[]},{"title":"Tomcat源码分析环境搭建","date":"2017-04-16T07:18:00.000Z","path":"2017/04/16/Tomcat源码分析环境搭建/","text":"","tags":[]},{"title":"2017阅读书单(持续更新)","date":"2017-04-16T05:46:48.000Z","path":"2017/04/16/2017阅读书单/","text":"技术书单 How Tomcat Works(英文) Spring源码深度解析 成长 巨婴国 被嫌弃的松子的一生 丘吉尔:我的早年生活 梦幻花 如何阅读一本书 黄金时代 月亮与六便士","tags":[]},{"title":"Spring源码分析环境搭建","date":"2017-04-15T13:28:22.000Z","path":"2017/04/15/Spring源码环境搭建/","text":"想研究spring源码的第一步当然是源码的搭建 推荐大家使用idea集成开发环境 下面的搭建过程也以idea为基础需要gradle git环境 不再叙述从github仓库中clone一份代码到本地git clone -b 3.2.x git@github.com:spring-projects/spring-framework.git这里需要注意的是你所使用的jdk版本与spring源码所需要的版本的匹配问题 如果你使用的jdk版本是1.7 而clone的是4以上的spring源码的话 那么comiple的时候就会报错查看源码目录下的 import-into-idea.md 文件 发现步骤可真简单 到spring源码的目录下cd your_spring_dir 执行命令 ./gradlew :spring-oxm:compileTestJava cleanIdea idea 这个过程可能比较慢 感觉卡住的话 ctrl+c 结束执行再重新执行命令 多试几次就好了 导入idea","tags":[]},{"title":"当我谈源码时,我谈些什么","date":"2017-04-15T07:06:19.000Z","path":"2017/04/15/当我谈源码时-我谈些什么/","text":"我们为什么要阅读源码 | 阅读源码给我们带来了什么 简单方面来说，阅读源码使我们更了解所使用的框架，深入其实现原理 更深入方面，我觉得阅读源码是一次提升的机会，提升自己抽象能力，学习大师们解决问题的思路. 阅读源码常见误区 每行代码都要搞懂是什么意思对于一个开源框架 以Tomcat 或者 Spring源码来说 每行代码都要理解的话 一方面会需要大量的时间 另一方面可能会被琐碎但又不那么重要的代码逻辑缠住 可谓是：捡了芝麻 丢了西瓜 要做到: 有的放矢 阅读源码的方法不对阅读源码并不是说把源码导入到集成开发环境中 就不管三七二十一的看起来 要找到切入点 借助开发工具提供的能力 多看看类的层次结构 多思考 学习大牛的抽象能力与分解|解决问题的能力 这两个能力在Tomcat，Spring源码中会达到让你惊叹的地步","tags":[]},{"title":"Hello World","date":"2017-04-14T09:35:35.000Z","path":"2017/04/14/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]