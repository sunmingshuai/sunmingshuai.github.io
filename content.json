[{"title":"Spring问题快问快答","date":"2017-12-31T12:21:34.000Z","path":"2017/12/31/Spring问题快问快答/","text":"这篇文章主要是博主平时遇到的问题 后来经过不断的学习 又被自己解决的问题 如果读者有什么问题的话 可以在下面留言 我会尽力解答 暂时没有目录 以后会想办法解决这个问题 1.@Controller与@Component注解有什么不同文章 component-scan做了些什么 最后问出的问题@Controller注解的作用只是注册普通bean 这是spring团队为了适应mvc所写的一个注解 让人一看就知道这是个控制器 真正起到路由作用的是@RequestMapping注解 spring会根据这个类上面有没有@RequestMapping来最终判定这个类是不是控制器 2.Tomcat中DefaultServlet拦截的路径是/ 而spring中DispatcherServlet一般拦截的路径也是/ 那为什么最后请求会给DispatcherServlet而不是DefaultServlet呢?如果有除了tomcat自带的DefaultServlet外的servlet的拦截路径也是/的话 这个servlet会被设置为默认servlet(defaultServlet) 相当于覆盖了tomcat自带的servlet 对于寻找请求的处理servlet 有专门的一套逻辑去处理 3.servlet过滤器 spring过滤器有什么不同 待解 4.@Before @Around @After的执行顺序?如果我们把@Around注解方法拆分为三块：around.before,proxyed_method(被代理的方法 即调用proceedingJoinPoint.proceed()那部分),around.after 那么执行顺序为: before_advice-&gt;around.before-&gt; proxyed_method-&gt;around.after-&gt;after 至于执行结果为什么是这样的 可以看下面的博文 @Before @Around @After的执行顺序源码解析 5.Spring的父子容器介绍我们通常说的父子容器是在web环境中 自然形成的 ContextLoaderListener加载的是父容器 而由DispatcherServlet加载的是子容器 就像java语言中父子关系一样 子类可以获得父类的属性 但父类不能活的子类的属性 详情请点击 spring web环境的加载 6.Spring类路径到底指的是什么路径网上的答案也是众说纷纭 让大家也是很苦恼 不知道相信哪一个 这个时候最好的解决办法就是找办法验证 通过测试去解决 在这里教大家一个更好的解决办法(maven spring web环境) 把你的web项目打包 然后看打包后的目录结构 你会发现main/resources目录下的配置文件都被放在了WEB_INF下 跟 classes 目录同级结构 这个时候我想一切就都明白了 7.控制器Controller 是单例模式吗默认情况下是的 Controller就是一个普通的Bean 只是在RequestMapping注解的作用下 具有了控制器的作用 但这并不改变Controller作为一个普通的Bean的作用 当一个控制器在类级别没有@RequestMapping注解的时候 而只有方法级别有的时候 那么这时类级别的注解必须为@Controller 8.为什么@Value(&quot;${name}&quot;)中 ${name}没有解析成对应的value值这个问题就需要知道@Value注解是怎么被处理的 博主先把碰到的问题的场景叙述出来 我遇到的这个场景可能稍微有点复杂 todo 9.为什么@Autowired注解不能用在静态成员变量不能 从源码的角度看 很简单 如果是static类型 直接continue了 10.Qualifier注解单独使用能实现注入吗 不能 注解工作原理源码解析 11.为什么我的controller不被切面代理 读者遇到这样的问题 基本上有两大原因 不了解切面的工作原理 推荐阅读 aop源码解析一:注册BPP aop源码解析二:寻找Advisor aop源码解析二:寻找Advisor 不了解容器的父子结构 推荐阅读 spring/mvc 容器的父子结构","tags":[]},{"title":"aop源码解析三:调用过程","date":"2017-07-17T01:10:46.000Z","path":"2017/07/17/aop源码解析四-调用过程/","text":"","tags":[]},{"title":"为什么要读书","date":"2017-07-15T06:21:14.000Z","path":"2017/07/15/为什么要读书/","text":"","tags":[]},{"title":"spring父子容器源码解析二","date":"2017-07-11T00:59:38.000Z","path":"2017/07/11/spring父子容器源码解析二/","text":"在spring父子容器源码解析一博文的最后 我们有讲到加载子容器的时候注册了一个ContextRefreshListener 继承自applicationListener 那么在容器加载的最后就会进行回调123456private class ContextRefreshListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123; public void onApplicationEvent(ContextRefreshedEvent event) &#123; FrameworkServlet.this.onApplicationEvent(event); &#125;&#125; 最后会调用DispatcherServlet的onRefresh方法1234@Overrideprotected void onRefresh(ApplicationContext context) &#123; initStrategies(context);&#125; 继续追踪123456789101112131415161718192021protected void initStrategies(ApplicationContext context) &#123; //文件上传相关处理 必须用户自己配置 没有默认 initMultipartResolver(context); //国际化相关 i18n initLocaleResolver(context); //主题相关 initThemeResolver(context); //default: handlermapping:BeanNmeUrlHandlerMapping &amp; DefaultAnnotationHandlerMapping(讲解) initHandlerMappings(context); //default: HttpRequestHandlerAdapter &amp; SimpleControllerHandlerAdapter &amp; AnnotationMethodHandlerAdapter initHandlerAdapters(context); initHandlerExceptionResolvers(context); //default: DefaultRequestToViewNameTranslator initRequestToViewNameTranslator(context); //default: InternalResourceViewResolver initViewResolvers(context); //缓存 initFlashMapManager(context);&#125; 这里就是spring-mvc相关的内容了 经过很多年的发展 spring提供的功能已经非常丰富 俨然已经是一个生态圈 所以我们阅读源代码的时候就要按需阅读 有的放矢 下面博主就挑选几个比较重要的类讲解 其中有些类阅读起来比较困难 希望读者能够注意阅读的方法initStrategies方法的作用就是加载一些类 包括文件上传处理相关 国际化相关 主题相关 mvc相关 缓存 方法本身比较简单 就是从beanfactory中找出特定类型的类并赋值 如果用户没有自己指定的话 就使用默认的策略 这个策略定义在DispatcherServlet.properties文件 关于加载的这部分也不再介绍initHandlerMappings(context)默认会加载BeanNmeUrlHandlerMapping DefaultAnnotationHandlerMapping 而用到的最多的应该是DefaultAnnotationHandlerMapping 也是提倡的形式 DefaultAnnotationHandlerMapping在initHandlerMappings(context)方法只是简单实例化了DefaultAnnotationHandlerMapping 并没有做更多的事情 这样一下子对于我们的阅读就造成了障碍 我们看下DefaultAnnotationHandlerMapping类的继承结构发现继承自ApplicationContextAware 那么我们知道加载完上下文的时候 如果一个类继承自这个接口 那么就会调用setXXX方法 那么我们在DefaultAnnotationHandlerMapping中搜索这个方法 发现在ApplicationObjectSupport中有这个方法实现1234567891011121314151617181920212223242526public final void setApplicationContext(ApplicationContext context) throws BeansException &#123; if (context == null &amp;&amp; !isContextRequired()) &#123; // Reset internal context state. this.applicationContext = null; this.messageSourceAccessor = null; &#125; else if (this.applicationContext == null) &#123; // Initialize with passed-in context. if (!requiredContextClass().isInstance(context)) &#123; throw new ApplicationContextException( &quot;Invalid application context: needs to be of type [&quot; + requiredContextClass().getName() + &quot;]&quot;); &#125; this.applicationContext = context; this.messageSourceAccessor = new MessageSourceAccessor(context); //执行这个方法 initApplicationContext(context); &#125; else &#123; // Ignore reinitialization if same context passed in. if (this.applicationContext != context) &#123; throw new ApplicationContextException( &quot;Cannot reinitialize with different application context: current one is [&quot; + this.applicationContext + &quot;], passed-in one is [&quot; + context + &quot;]&quot;); &#125; &#125;&#125; 又会调用initApplicationContext(context);方法 然后调用AbstractDetectingUrlHandlerMapping##initApplicationContext();方法1234567@Overridepublic void initApplicationContext() throws ApplicationContextException &#123; // 初始化拦截器 super.initApplicationContext(); // 探测handler 即我们的控制器 通过@RequestMapping注解识别 detectHandlers();&#125; 方法看起来很简洁 要做的就是两件事情 初始化拦截器 寻找控制器 我们着重看第二部分 寻找控制器123456789101112131415161718192021222324protected void detectHandlers() throws BeansException &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Looking for URL mappings in application context: &quot; + getApplicationContext()); &#125; //默认只在子容器中寻找控制器 所以控制器所在的配置文件需要指定给DispatcherServlet String[] beanNames = (this.detectHandlersInAncestorContexts ? BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) : getApplicationContext().getBeanNamesForType(Object.class)); // Take any bean name that we can determine URLs for. for (String beanName : beanNames) &#123; String[] urls = determineUrlsForHandler(beanName); if (!ObjectUtils.isEmpty(urls)) &#123; // URL paths found: Let&apos;s consider it a handler. // 注册路径与对应的handler的对应关系 registerHandler(urls, beanName); &#125; else &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Rejected bean name &apos;&quot; + beanName + &quot;&apos;: no URL paths identified&quot;); &#125; &#125; &#125;&#125; 看下determineUrlsForHandler(beanName);方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Overrideprotected String[] determineUrlsForHandler(String beanName) &#123; ApplicationContext context = getApplicationContext(); Class&lt;?&gt; handlerType = context.getType(beanName); // 类或者方法上面有@RequestMapping注解 RequestMapping mapping = context.findAnnotationOnBean(beanName, RequestMapping.class); if (mapping != null) &#123; // @RequestMapping found at type level this.cachedMappings.put(handlerType, mapping); Set&lt;String&gt; urls = new LinkedHashSet&lt;String&gt;(); String[] typeLevelPatterns = mapping.value(); if (typeLevelPatterns.length &gt; 0) &#123; // @RequestMapping specifies paths at type level String[] methodLevelPatterns = determineUrlsForHandlerMethods(handlerType, true); for (String typeLevelPattern : typeLevelPatterns) &#123; //所以路径是以&apos;/&apos;开头的 if (!typeLevelPattern.startsWith(&quot;/&quot;)) &#123; typeLevelPattern = &quot;/&quot; + typeLevelPattern; &#125; boolean hasEmptyMethodLevelMappings = false; for (String methodLevelPattern : methodLevelPatterns) &#123; if (methodLevelPattern == null) &#123; hasEmptyMethodLevelMappings = true; &#125; else &#123; String combinedPattern = getPathMatcher().combine(typeLevelPattern, methodLevelPattern); addUrlsForPath(urls, combinedPattern); &#125; &#125; if (hasEmptyMethodLevelMappings || org.springframework.web.servlet.mvc.Controller.class.isAssignableFrom(handlerType)) &#123; addUrlsForPath(urls, typeLevelPattern); &#125; &#125; return StringUtils.toStringArray(urls); &#125; else &#123; // actual paths specified by @RequestMapping at method level return determineUrlsForHandlerMethods(handlerType, false); &#125; &#125; //如果没有@RequestMapping注解 但是有@Controller注解 else if (AnnotationUtils.findAnnotation(handlerType, Controller.class) != null) &#123; // @RequestMapping to be introspected at method level return determineUrlsForHandlerMethods(handlerType, false); &#125; else &#123; return null; &#125;&#125; 这个方法会获取类级别(typeLevel) 方法级别(methodLevel)的RequestMapping注解 并获取path信息 并组合类,方法级别的路径信息 与对应的控制器形成映射 需要注意的是这里只是只是映射到了控制器级别 并没有指定某个路径对应与控制器的某个具体方法 这点还需要读者注意最后形成的对应信息见下示意图123456789101112131415161718192021222324252627282930@Controller@RequestMapping(&quot;blog&quot;)public class BlogController &#123; @Value(&quot;$&#123;name&#125;&quot;) private String name; @Autowired private BlogService blogService; @RequestMapping(&quot;helloBlog&quot;) public String helloBlog(BlogRequest request) &#123; String title = request.getTitle(); System.out.println(name); blogService.tip(); // 子容器拿不到父容器的bean// TestService testService = SpringContextsUtil.getBean(TestService.class); return &quot;blog&quot;; &#125;&#125;@Controller@RequestMapping(&quot;/&quot;)public class HelloSpringController &#123; @RequestMapping(&quot;helloSpring&quot;) public String helloSpring() &#123; return &quot;spring&quot;; &#125;&#125; RequestMapping提供的选项还有method(指定请求的方法 例如GET POST) headers等 但这里只关系Value也就是指定的路径信息如果读者能搭建起spring的debug环境 或者直接debug项目 那么会加快阅读的速度 AnnotationMethodHandlerAdapterinitHandlerAdapters(context);方法默认会加载HttpRequestHandlerAdapter SimpleControllerHandlerAdapter AnnotationMethodHandlerAdapter 我们这里只介绍AnnotationMethodHandlerAdapter我们发现AnnotationMethodHandlerAdapter这个类的也是继承自ApplicationObject 但追踪到最后发现是个空的实现体 并没有做什么事情 web请求过程博主后面会出tomcat系列源码阅读 这样大家对web系统的工作原理就会更加的深入 我们这里就从一个servlet说起 这个servlet大家应该并不陌生 就是DispatcherServlet 最常用的http请求类型 例如GET POST会分别调用doGet doPost方法 而在DispatcherServlet中都是调用一个方法processRequest(request, response)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; long startTime = System.currentTimeMillis(); Throwable failureCause = null; LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext(); LocaleContext localeContext = buildLocaleContext(request); RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);//异步组件 WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor()); initContextHolders(request, localeContext, requestAttributes); try &#123; doService(request, response); &#125; catch (ServletException ex) &#123; failureCause = ex; throw ex; &#125; catch (IOException ex) &#123; failureCause = ex; throw ex; &#125; catch (Throwable ex) &#123; failureCause = ex; throw new NestedServletException(\"Request processing failed\", ex); &#125; finally &#123; resetContextHolders(request, previousLocaleContext, previousAttributes); if (requestAttributes != null) &#123; requestAttributes.requestCompleted(); &#125; if (logger.isDebugEnabled()) &#123; if (failureCause != null) &#123; this.logger.debug(\"Could not complete request\", failureCause); &#125; else &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; logger.debug(\"Leaving response open for concurrent processing\"); &#125; else &#123; this.logger.debug(\"Successfully completed request\"); &#125; &#125; &#125; publishRequestHandledEvent(request, startTime, failureCause); &#125; &#125; 建了一些包装的ThreadLocal类 便于以后的获取使用 我们接着看doService方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overrideprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; if (logger.isDebugEnabled()) &#123; String resumed = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult() ? \" resumed\" : \"\"; logger.debug(\"DispatcherServlet with name '\" + getServletName() + \"'\" + resumed + \" processing \" + request.getMethod() + \" request for [\" + getRequestUri(request) + \"]\"); &#125; // Keep a snapshot of the request attributes in case of an include, // to be able to restore the original attributes after the include. Map&lt;String, Object&gt; attributesSnapshot = null; if (WebUtils.isIncludeRequest(request)) &#123; attributesSnapshot = new HashMap&lt;String, Object&gt;(); Enumeration&lt;?&gt; attrNames = request.getAttributeNames(); while (attrNames.hasMoreElements()) &#123; String attrName = (String) attrNames.nextElement(); if (this.cleanupAfterInclude || attrName.startsWith(\"org.springframework.web.servlet\")) &#123; attributesSnapshot.put(attrName, request.getAttribute(attrName)); &#125; &#125; &#125; // Make framework objects available to handlers and view objects. //每次请求都设置引用 request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext()); request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver); request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver); request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource()); FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response); if (inputFlashMap != null) &#123; request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap)); &#125; request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap()); request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager); try &#123; doDispatch(request, response); &#125; finally &#123; if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Restore the original attribute snapshot, in case of an include. if (attributesSnapshot != null) &#123; restoreAttributesAfterInclude(request, attributesSnapshot); &#125; &#125; &#125;&#125; 层层的处理 还是没有看到我们想看的部分 继续追踪1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; //springmvc 拦截器 由mvc:interceptors标签完成拦截器的注册 // 责任链模式是框架中用的很多的一种模式 这里可以配置一些拦截器 HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. // 根据uri寻找对应的handler 并返回HandlerExecutionChain mappedHandler = getHandler(processedRequest, false); if (mappedHandler == null || mappedHandler.getHandler() == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // todo Adapter的作用是什么 // @InitBinder @ModelAttributes @SessionAttribute处理 // handlermapping记录了path与handler的对应关系 但没有记录与handlermethod的对应关系 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = \"GET\".equals(method); // 缓存机制 if (isGet || \"HEAD\".equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (logger.isDebugEnabled()) &#123; logger.debug(\"Last-Modified value for [\" + getRequestUri(request) + \"] is: \" + lastModified); &#125; if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; // 执行拦截器前置链 如果不满足条件的话 直接返回 不执行控制器逻辑 if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. // 实际调用handler方法 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(request, mv); mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Error err) &#123; triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125; &#125; 这部分代码就是我们想看到的部分了先看返回HandlerExecutionChain的部分1234567891011121314protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; //BeanNameUrlHandlerMapping | DefaultAnnotationHandlerMapping for (HandlerMapping hm : this.handlerMappings) &#123; if (logger.isTraceEnabled()) &#123; logger.trace( \"Testing handler map [\" + hm + \"] in DispatcherServlet with name '\" + getServletName() + \"'\"); &#125; HandlerExecutionChain handler = hm.getHandler(request); if (handler != null) &#123; return handler; &#125; &#125; return null;&#125; 这里的handlerMappings就是前面讲到的注册的几个默认的handler 常用的就是DefaultAnnotationHandlerMapping123456789101112131415public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; Object handler = getHandlerInternal(request); if (handler == null) &#123; handler = getDefaultHandler(); &#125; if (handler == null) &#123; return null; &#125; // Bean name or resolved handler? if (handler instanceof String) &#123; String handlerName = (String) handler; handler = getApplicationContext().getBean(handlerName); &#125; return getHandlerExecutionChain(handler, request);&#125; getHandlerInternal(request)方法就是从从前加载出来的handlermap中根据请求路径信息寻找对应的handler 也就是我们的控制器 然后再从spring上下中获取对应的bean 然后构造责任链HandlerExecutionChain返回接下来是获取HandlerAdapter 找到支持对应handler的就可以了123public boolean supports(Object handler) &#123; return getMethodResolver(handler).hasHandlerMethods();&#125; 这是AnnotationMethodHandlerAdapter的supports方法 这个方法里面其实做了相当多的动作 看下getMethodResolver(handler)方法1234567891011121314private ServletHandlerMethodResolver getMethodResolver(Object handler) &#123; Class handlerClass = ClassUtils.getUserClass(handler); ServletHandlerMethodResolver resolver = this.methodResolverCache.get(handlerClass); if (resolver == null) &#123; synchronized (this.methodResolverCache) &#123; resolver = this.methodResolverCache.get(handlerClass); if (resolver == null) &#123; resolver = new ServletHandlerMethodResolver(handlerClass); this.methodResolverCache.put(handlerClass, resolver); &#125; &#125; &#125; return resolver;&#125; 构造了一个resolver 看看里面做了些什么1234567891011121314151617181920212223242526272829303132333435363738394041public void init(final Class&lt;?&gt; handlerType) &#123; Set&lt;Class&lt;?&gt;&gt; handlerTypes = new LinkedHashSet&lt;Class&lt;?&gt;&gt;(); Class&lt;?&gt; specificHandlerType = null; if (!Proxy.isProxyClass(handlerType)) &#123; handlerTypes.add(handlerType); specificHandlerType = handlerType; &#125; handlerTypes.addAll(Arrays.asList(handlerType.getInterfaces())); for (Class&lt;?&gt; currentHandlerType : handlerTypes) &#123; final Class&lt;?&gt; targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType); ReflectionUtils.doWithMethods(currentHandlerType, new ReflectionUtils.MethodCallback() &#123; public void doWith(Method method) &#123; Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass); // 桥接方法 Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod); // 方法上有@RequestMapping注解 if (isHandlerMethod(specificMethod) &amp;&amp; (bridgedMethod == specificMethod || !isHandlerMethod(bridgedMethod))) &#123; handlerMethods.add(specificMethod); &#125; // 方法上有InitBinder注解 else if (isInitBinderMethod(specificMethod) &amp;&amp; (bridgedMethod == specificMethod || !isInitBinderMethod(bridgedMethod))) &#123; initBinderMethods.add(specificMethod); &#125; // 方法上有ModelAttribute注解 else if (isModelAttributeMethod(specificMethod) &amp;&amp; (bridgedMethod == specificMethod || !isModelAttributeMethod(bridgedMethod))) &#123; modelAttributeMethods.add(specificMethod); &#125; &#125; &#125;, ReflectionUtils.USER_DECLARED_METHODS); &#125; this.typeLevelMapping = AnnotationUtils.findAnnotation(handlerType, RequestMapping.class); SessionAttributes sessionAttributes = AnnotationUtils.findAnnotation(handlerType, SessionAttributes.class); this.sessionAttributesFound = (sessionAttributes != null); if (this.sessionAttributesFound) &#123; this.sessionAttributeNames.addAll(Arrays.asList(sessionAttributes.value())); this.sessionAttributeTypes.addAll(Arrays.asList(sessionAttributes.types())); &#125;&#125; 处理所有的方法 并分别对RequestMapping,InitBinder,ModelAttribute 注解做处理再回到doDispatch方法 先执行拦截器的前置链 如果不符合条件的话 就再往下执行了 ha.handle(processedRequest, response, mappedHandler.getHandler())就是真正要执行控制器方法了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Class&lt;?&gt; clazz = ClassUtils.getUserClass(handler); Boolean annotatedWithSessionAttributes = this.sessionAnnotatedClassesCache.get(clazz); if (annotatedWithSessionAttributes == null) &#123; annotatedWithSessionAttributes = (AnnotationUtils.findAnnotation(clazz, SessionAttributes.class) != null); this.sessionAnnotatedClassesCache.put(clazz, annotatedWithSessionAttributes); &#125; if (annotatedWithSessionAttributes) &#123; // Always prevent caching in case of session attribute management. checkAndPrepare(request, response, this.cacheSecondsForSessionAttributeHandlers, true); // Prepare cached set of session attributes names. &#125; else &#123; // Uses configured default cacheSeconds setting. checkAndPrepare(request, response, true); &#125; // Execute invokeHandlerMethod in synchronized block if required. if (this.synchronizeOnSession) &#123; HttpSession session = request.getSession(false); if (session != null) &#123; Object mutex = WebUtils.getSessionMutex(session); synchronized (mutex) &#123; return invokeHandlerMethod(request, response, handler); &#125; &#125; &#125; return invokeHandlerMethod(request, response, handler); &#125; protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; ServletHandlerMethodResolver methodResolver = getMethodResolver(handler); // 查找出最匹配的那个方法 Method handlerMethod = methodResolver.resolveHandlerMethod(request); ServletHandlerMethodInvoker methodInvoker = new ServletHandlerMethodInvoker(methodResolver); ServletWebRequest webRequest = new ServletWebRequest(request, response); ExtendedModelMap implicitModel = new BindingAwareModelMap(); // 控制器handler是单例模式(默认情况下 普通bean) Object result = methodInvoker.invokeHandlerMethod(handlerMethod, handler, webRequest, implicitModel); ModelAndView mav = methodInvoker.getModelAndView(handlerMethod, handler.getClass(), result, implicitModel, webRequest); methodInvoker.updateModelAttributes(handler, (mav != null ? mav.getModel() : null), implicitModel, webRequest); return mav; &#125; 这里会涉及到方法参数解析 匹配 例如我们常见的PathVariable注解的解析就是在这里完成的未完待续…","tags":[{"name":"父子容器","slug":"父子容器","permalink":"http://yoursite.com/tags/父子容器/"}]},{"title":"spring父子容器源码解析一","date":"2017-07-11T00:54:30.000Z","path":"2017/07/11/spring父子容器源码解析一/","text":"大家用spring框架的时候 用的最多的应该是用到web项目中 但是在工作中发现有些人对spring父子容器的概念不了解 这样就导致一些问题 例如最常见的问题 切面不工作(e.g. aop切不到controller)或者控制器不工作 作为一名程序员 自然是不能逃避问题 遇到问题总要探个究竟web项目 有个很重要的配置文件 web.xml spring与web项目的结合点就在这个配置文件12345678910111213141516171819202122232425&lt;web-app&gt; &lt;display-name&gt;sunmingshuai&lt;/display-name&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:spring/*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- ／ 或者 ／* 有什么区别 --&gt; &lt;!-- /* 为什么不行 :又拦截了返回的页面请求 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 这是我花了几分钟自己搭建的一个web项目 项目在这里springmvcdemo有两个很重要的类ContextLoaderListener DispatcherServlet 这是spring/mvc项目与tomcat结合的关键 ContextLoaderListener加载contextConfigLocation指定的配置文件 创建父容器 DispatcherServlet默认加载${DispatcherServlet-servlet-name}-servlet.xml配置文件 在这里为springmvc-servlet.xml 当然也可以自己另外指定配置文件 创建子容器 可以通过子容器获取父容器中的bean 反之不成立 控制器必须在子容器加载的配置文件之中 父容器的加载ContextLoaderListener是一个监听器 继承自ServletContextListener ServletContextListener有两个重要的方法1234public interface ServletContextListener extends EventListener &#123; public void contextInitialized(ServletContextEvent sce); public void contextDestroyed(ServletContextEvent sce);&#125; 我们看下ContextLoaderListener对contextInitialized(xxx)方法的实现12345678910/** * 初始化web容器的根上下文环境-父容器上下文 */public void contextInitialized(ServletContextEvent event) &#123; this.contextLoader = createContextLoader(); if (this.contextLoader == null) &#123; this.contextLoader = this; &#125; this.contextLoader.initWebApplicationContext(event.getServletContext());&#125; contextloader##initWebApplicationContext123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123; if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) &#123; throw new IllegalStateException( &quot;Cannot initialize context because there is already a root application context present - &quot; + &quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;); &#125; Log logger = LogFactory.getLog(ContextLoader.class); servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;); if (logger.isInfoEnabled()) &#123; logger.info(&quot;Root WebApplicationContext: initialization started&quot;); &#125; long startTime = System.currentTimeMillis(); try &#123; // Store context in local instance variable, to guarantee that // it is available on ServletContext shutdown. if (this.context == null) &#123; // 利用默认的构造函数实例化一个XmlWebApplicationContext this.context = createWebApplicationContext(servletContext); &#125; if (this.context instanceof ConfigurableWebApplicationContext) &#123; ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context; if (!cwac.isActive()) &#123; // The context has not yet been refreshed -&gt; provide services such as // setting the parent context, setting the application context id, etc if (cwac.getParent() == null) &#123; // The context instance was injected without an explicit parent -&gt; // determine parent for root web application context, if any. ApplicationContext parent = loadParentContext(servletContext); //null cwac.setParent(parent); &#125; configureAndRefreshWebApplicationContext(cwac, servletContext); &#125; &#125; // 加入到ServletContext中 key为org.springframework.web.context.WebApplicationContext.ROOT servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context); ClassLoader ccl = Thread.currentThread().getContextClassLoader(); if (ccl == ContextLoader.class.getClassLoader()) &#123; currentContext = this.context; &#125; else if (ccl != null) &#123; currentContextPerThread.put(ccl, this.context); &#125; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Published root WebApplicationContext as ServletContext attribute with name [&quot; + WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + &quot;]&quot;); &#125; if (logger.isInfoEnabled()) &#123; long elapsedTime = System.currentTimeMillis() - startTime; logger.info(&quot;Root WebApplicationContext: initialization completed in &quot; + elapsedTime + &quot; ms&quot;); &#125; return this.context; &#125; catch (RuntimeException ex) &#123; logger.error(&quot;Context initialization failed&quot;, ex); servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex); throw ex; &#125; catch (Error err) &#123; logger.error(&quot;Context initialization failed&quot;, err); servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err); throw err; &#125;&#125; 总的来说 代码比较简单 代码中也有一些注释 相信读者完全可以无障碍阅读 创建了一个ApplicationContext 并放入到ServletContext中 key为org.springframework.web.context.WebApplicationContext.ROOT 我们还是来简单介绍下configureAndRefreshWebApplicationContext(xxx)方法1234567891011121314151617181920212223242526272829303132333435363738394041424344protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) &#123; //设置id if (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123; // The application context id is still set to its original default value // -&gt; assign a more useful id based on available information String idParam = sc.getInitParameter(CONTEXT_ID_PARAM); if (idParam != null) &#123; wac.setId(idParam); &#125; else &#123; // Generate default id... if (sc.getMajorVersion() == 2 &amp;&amp; sc.getMinorVersion() &lt; 5) &#123; // Servlet &lt;= 2.4: resort to name specified in web.xml, if any. wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + ObjectUtils.getDisplayString(sc.getServletContextName())); &#125; else &#123; wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + ObjectUtils.getDisplayString(sc.getContextPath())); &#125; &#125; &#125; //设置互相引用 wac.setServletContext(sc); // 设置要加载配置文件的地址为web.xml中指定的contextConfigLocation地址 String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM); if (configLocationParam != null) &#123; wac.setConfigLocation(configLocationParam); &#125; // The wac environment&apos;s #initPropertySources will be called in any case when the context // is refreshed; do it eagerly here to ensure servlet property sources are in place for // use in any post-processing or initialization that occurs below prior to #refresh ConfigurableEnvironment env = wac.getEnvironment(); if (env instanceof ConfigurableWebEnvironment) &#123; ((ConfigurableWebEnvironment) env).initPropertySources(sc, null); &#125; //如果有配置globalInitializerClasses或者contextInitializerClasses的话 在这里调用 customizeContext(sc, wac); //下面就是我们之前介绍的spring容器的加载过程了 spring获取bean的过程是了解其他功能的基础 wac.refresh();&#125; 代码的最后就是调用refresh()方法 这个方法我们前面花了很多篇幅介绍 就是加载spring的容器的过程 希望读者能多多阅读几遍这个过程 相信会每次都有新发现的 子容器的加载在web.xml中配置的另外一个类DispatcherServlet 负责子容器的启动 那么入口再什么地方呢?DispatcherServlet是配置成启动的时候就加载的 &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;那么我们来看一下他的init()方法HttpServletBean##init()1234567891011121314151617181920212223242526272829303132@Overridepublic final void init() throws ServletException &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Initializing servlet &apos;&quot; + getServletName() + &quot;&apos;&quot;); &#125; // Set bean properties from init parameters. try &#123; //转存dispatcherServlet在web.xml配置的init-parameter到pvs保存 //同时验证有没有缺少的必须元素 PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties); //将dispatcherServlet包装成bean BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext()); //注册Resource属性编辑器 bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment())); //留空 initBeanWrapper(bw); bw.setPropertyValues(pvs, true); &#125; catch (BeansException ex) &#123; logger.error(&quot;Failed to set bean properties on servlet &apos;&quot; + getServletName() + &quot;&apos;&quot;, ex); throw ex; &#125; // Let subclasses do whatever initialization they like. initServletBean(); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Servlet &apos;&quot; + getServletName() + &quot;&apos; configured successfully&quot;); &#125;&#125; 在这个方法中 DispatcherServlet被包装成了bean 这样做的好处就是可以方便管理initServletBean()方法最终会调用FrameworkServlet##initWebApplicationContext()方法 我们探究下这个方法做了些什么1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556protected WebApplicationContext initWebApplicationContext() &#123; //取出contextLoaderListener加载的父容器 WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; if (this.webApplicationContext != null) &#123; // A context instance was injected at construction time -&gt; use it wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) &#123; ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) &#123; // The context has not yet been refreshed -&gt; provide services such as // setting the parent context, setting the application context id, etc if (cwac.getParent() == null) &#123; // The context instance was injected without an explicit parent -&gt; set // the root application context (if any; may be null) as the parent cwac.setParent(rootContext); &#125; configureAndRefreshWebApplicationContext(cwac); &#125; &#125; &#125; if (wac == null) &#123; // No context instance was injected at construction time -&gt; see if one // has been registered in the servlet context. If one exists, it is assumed // that the parent context (if any) has already been set and that the // user has performed any initialization such as setting the context id wac = findWebApplicationContext(); &#125; if (wac == null) &#123; // No context instance is defined for this servlet -&gt; create a local one // 这里就呈现出了容器间的父子结构 contextloaderlistener创建的容器为父容器 dispatcherservlet创建的则为子容器 wac = createWebApplicationContext(rootContext); &#125; // 加载容器的时候 会调用onApplicationEvent方法 if (!this.refreshEventReceived) &#123; // Either the context is not a ConfigurableApplicationContext with refresh // support or the context injected at construction time had already been // refreshed -&gt; tger initial onRefresh manually here. onRefresh(wac); &#125; if (this.publishContext) &#123; // Publish the context as a servlet context attribute. String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); if (this.logger.isDebugEnabled()) &#123; this.logger.debug(&quot;Published WebApplicationContext of servlet &apos;&quot; + getServletName() + &quot;&apos; as ServletContext attribute with name [&quot; + attrName + &quot;]&quot;); &#125; &#125; return wac;&#125; 对于初始化的容器来说 创建容器wac的过程会走创建的分支1234if (wac == null) &#123; // 这里就呈现出了容器间的父子结构 contextloaderlistener创建的容器为父容器 dispatcherservlet创建的则为子容器 wac = createWebApplicationContext(rootContext);&#125; rootContext就是我们前面介绍父容器时加载的对象 这里再从servletContext中取出来12345678910111213141516171819202122232425protected WebApplicationContext createWebApplicationContext(ApplicationContext parent) &#123; Class&lt;?&gt; contextClass = getContextClass(); if (this.logger.isDebugEnabled()) &#123; this.logger.debug(&quot;Servlet with name &apos;&quot; + getServletName() + &quot;&apos; will try to create custom WebApplicationContext context of class &apos;&quot; + contextClass.getName() + &quot;&apos;&quot; + &quot;, using parent context [&quot; + parent + &quot;]&quot;); &#125; if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123; throw new ApplicationContextException( &quot;Fatal initialization error in servlet with name &apos;&quot; + getServletName() + &quot;&apos;: custom WebApplicationContext class [&quot; + contextClass.getName() + &quot;] is not of type ConfigurableWebApplicationContext&quot;); &#125; ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass); wac.setEnvironment(getEnvironment()); //设置父容器 wac.setParent(parent); wac.setConfigLocation(getContextConfigLocation()); configureAndRefreshWebApplicationContext(wac); return wac;&#125; 继续追踪代码configureAndRefreshWebApplicationContext(wac)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) &#123;//设置id if (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123; // The application context id is still set to its original default value // -&gt; assign a more useful id based on available information if (this.contextId != null) &#123; wac.setId(this.contextId); &#125; else &#123; // Generate default id... ServletContext sc = getServletContext(); if (sc.getMajorVersion() == 2 &amp;&amp; sc.getMinorVersion() &lt; 5) &#123; // Servlet &lt;= 2.4: resort to name specified in web.xml, if any. String servletContextName = sc.getServletContextName(); if (servletContextName != null) &#123; wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + servletContextName + &quot;.&quot; + getServletName()); &#125; else &#123; wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + getServletName()); &#125; &#125; else &#123; // Servlet 2.5&apos;s getContextPath available! wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + ObjectUtils.getDisplayString(sc.getContextPath()) + &quot;/&quot; + getServletName()); &#125; &#125; &#125; wac.setServletContext(getServletContext()); wac.setServletConfig(getServletConfig()); wac.setNamespace(getNamespace()); // wac容器创建好的时候 会调用ContextRefreshListener#onApplicationEvent方法 完成默认类的注册 wac.addApplicationListener(new SourceFilteringListener(wac, new ContextRefreshListener())); // The wac environment&apos;s #initPropertySources will be called in any case when the context // is refreshed; do it eagerly here to ensure servlet property sources are in place for // use in any post-processing or initialization that occurs below prior to #refresh ConfigurableEnvironment env = wac.getEnvironment(); if (env instanceof ConfigurableWebEnvironment) &#123; ((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig()); &#125; postProcessWebApplicationContext(wac); applyInitializers(wac); wac.refresh();&#125; 这里有一个重要的点就是加了一个ContextRefreshListener 并且是applicationListener 如果没有注意到这一点的话 后面阅读代码就不知道从哪里阅读了其他的就比较简单了 就不做介绍了","tags":[{"name":"父子容器","slug":"父子容器","permalink":"http://yoursite.com/tags/父子容器/"}]},{"title":"aop源码解析三:创建代理","date":"2017-06-01T13:21:02.000Z","path":"2017/06/01/aop源码解析三-创建代理/","text":"","tags":[{"name":"aop","slug":"aop","permalink":"http://yoursite.com/tags/aop/"}]},{"title":"aop源码解析二:寻找Advisor","date":"2017-05-23T04:34:05.000Z","path":"2017/05/23/aop源码解析二-寻找Advisor/","text":"我们就不再从bean的加载过程开始看了 在aop源码解析一:注册BPP中 介绍到了一个后置处理器 AnnotationAwareAspectJAutoProxyCreator 我们就从这个类入手aop先看postProcessBeforeInstantiation 很显然 是bean实例化前调用的 里面好像是处理了一些事情12345678910111213141516171819202122232425262728293031public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123; Object cacheKey = getCacheKey(beanClass, beanName); if (beanName == null || !this.targetSourcedBeans.containsKey(beanName)) &#123; if (this.advisedBeans.containsKey(cacheKey)) &#123; return null; &#125; //这里需要注意的是 shouldSkip方法被子类覆盖了 这个很容易忽略 if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123; this.advisedBeans.put(cacheKey, Boolean.FALSE); return null; &#125; &#125; // Create proxy here if we have a custom TargetSource. // Suppresses unnecessary default instantiation of the target bean: // The TargetSource will handle target instances in a custom fashion. if (beanName != null) &#123; //todo 这里返回null!!! TargetSource targetSource = getCustomTargetSource(beanClass, beanName); if (targetSource != null) &#123; this.targetSourcedBeans.put(beanName, Boolean.TRUE); Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource); Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; &#125; &#125; return null;&#125; 这里shouldSkip(beanClass, beanName)方法是一个很容易忽略的方法 可能是方法名字的原因或者复杂的继承关系吧 但在这个方法的实现过程中 已经把所有的切面加载完成了AspectJAwareAdvisorAutoProxyCreator##shouldSkip123456789101112protected boolean shouldSkip(Class beanClass, String beanName) &#123; // TODO: Consider optimization by caching the list of the aspect names List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors(); for (Advisor advisor : candidateAdvisors) &#123; if (advisor instanceof AspectJPointcutAdvisor) &#123; if (((AbstractAspectJAdvice) advisor.getAdvice()).getAspectName().equals(beanName)) &#123; return true; &#125; &#125; &#125; return super.shouldSkip(beanClass, beanName);&#125; 首先找出所有的advisor 如果要加载的这个bean是一个advisor的话 当然就不会代理了AnnotationAwareAspectJAutoProxyCreator##findCandidateAdvisors()123456789protected List&lt;Advisor&gt; findCandidateAdvisors() &#123; // Add all the Spring advisors found according to superclass rules. // 寻找bean的类型为Aspect.class的 我们更关心注解的形式 这里不过多的讲解 List&lt;Advisor&gt; advisors = super.findCandidateAdvisors(); // Build Advisors for all AspectJ aspects in the bean factory. // 处理注解(@Aspect)的形式 advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors()); return advisors;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public List&lt;Advisor&gt; buildAspectJAdvisors() &#123; List&lt;String&gt; aspectNames = null; synchronized (this) &#123; aspectNames = this.aspectBeanNames; if (aspectNames == null) &#123; List&lt;Advisor&gt; advisors = new LinkedList&lt;Advisor&gt;(); aspectNames = new LinkedList&lt;String&gt;(); // 根据类型取出beanFactory中所有的bean 包括父容器 然后循环判断 // todo 这样就可能造成重复加载 String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Object.class, true, false); for (String beanName : beanNames) &#123; // 提供可供扩展的模式匹配 if (!isEligibleBean(beanName)) &#123; continue; &#125; // We must be careful not to instantiate beans eagerly as in this // case they would be cached by the Spring container but would not // have been weaved Class beanType = this.beanFactory.getType(beanName); if (beanType == null) &#123; continue; &#125; // 带有@Aspect 注解 并且不是由ajc编译生成 code-style方式的切面spring aop不处理(在前面已经处理过了) if (this.advisorFactory.isAspect(beanType)) &#123; aspectNames.add(beanName); //包装类 AspectMetadata amd = new AspectMetadata(beanType, beanName); if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123; //包装类 MetadataAwareAspectInstanceFactory factory = new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName); //将切面类中的所有的切面方法拆解出来 List&lt;Advisor&gt; classAdvisors = this.advisorFactory.getAdvisors(factory); if (this.beanFactory.isSingleton(beanName)) &#123; this.advisorsCache.put(beanName, classAdvisors); &#125; else &#123; this.aspectFactoryCache.put(beanName, factory); &#125; advisors.addAll(classAdvisors); &#125; else &#123; // Per target or per this. if (this.beanFactory.isSingleton(beanName)) &#123; throw new IllegalArgumentException(\"Bean with name '\" + beanName + \"' is a singleton, but aspect instantiation model is not singleton\"); &#125; MetadataAwareAspectInstanceFactory factory = new PrototypeAspectInstanceFactory(this.beanFactory, beanName); this.aspectFactoryCache.put(beanName, factory); advisors.addAll(this.advisorFactory.getAdvisors(factory)); &#125; &#125; &#125; this.aspectBeanNames = aspectNames; return advisors; &#125; &#125; if (aspectNames.isEmpty()) &#123; return Collections.EMPTY_LIST; &#125; List&lt;Advisor&gt; advisors = new LinkedList&lt;Advisor&gt;(); for (String aspectName : aspectNames) &#123; List&lt;Advisor&gt; cachedAdvisors = this.advisorsCache.get(aspectName); if (cachedAdvisors != null) &#123; advisors.addAll(cachedAdvisors); &#125; else &#123; MetadataAwareAspectInstanceFactory factory = this.aspectFactoryCache.get(aspectName); advisors.addAll(this.advisorFactory.getAdvisors(factory)); &#125; &#125; return advisors;&#125; 对于bean工厂中的所有的bean 判断是否有Aspect注解 并且不是由ajc编译 code-style编程的方式 再前面已经处理过了 这里就不再处理 对于下面部分的代码阅读来说 有些读者可能会觉得困难 看着这么多陌生的名字很长的类就觉得好难 其实这些类只是一些包装util而已 为的就是不会在一个方法里面代码过多显得臃肿 AspectMetadata MetadataAwareAspectInstanceFactory都是起到这样的作用 下面的部分就是本文的重头戏了 寻找advisor123456789101112131415161718192021222324252627282930313233343536public List&lt;Advisor&gt; getAdvisors(MetadataAwareAspectInstanceFactory maaif) &#123; final Class&lt;?&gt; aspectClass = maaif.getAspectMetadata().getAspectClass(); final String aspectName = maaif.getAspectMetadata().getAspectName(); validate(aspectClass); // We need to wrap the MetadataAwareAspectInstanceFactory with a decorator // so that it will only instantiate once. final MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory = new LazySingletonAspectInstanceFactoryDecorator(maaif); final List&lt;Advisor&gt; advisors = new LinkedList&lt;Advisor&gt;(); // 循环所有的切面方法 for (Method method : getAdvisorMethods(aspectClass)) &#123; // 将切面方法转化为advisor Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName); if (advisor != null) &#123; advisors.add(advisor); &#125; &#125; // If it's a per target aspect, emit the dummy instantiating aspect. if (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123; Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory); advisors.add(0, instantiationAdvisor); &#125; // Find introduction fields. for (Field field : aspectClass.getDeclaredFields()) &#123; Advisor advisor = getDeclareParentsAdvisor(field); if (advisor != null) &#123; advisors.add(advisor); &#125; &#125; return advisors;&#125; 我们这里先列举一个切面的例子 这样可能更有助于读者阅读 这个例子可以从github-springmvcdemo中clone下来123456789101112131415161718192021222324252627282930313233343536@Component@Aspectpublic class LogTipAspect &#123; @Around(\"@annotation(com.sunmingshuai.annotation.LogTip)\") public void aroundEntry(ProceedingJoinPoint pjp)&#123; System.out.print(\"before aroundEntry\"); try &#123; pjp.proceed(); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; System.out.print(\"before aroundEntry\"); &#125; @Before(\"@annotation(com.sunmingshuai.annotation.LogTip)\") public void beforeEntry()&#123; System.out.print(\"beforeEntry\"); &#125; @After(\"@annotation(com.sunmingshuai.annotation.LogTip)\") public void afterEntry()&#123; System.out.print(\"afterEntry\"); &#125; @AfterThrowing(\"@annotation(com.sunmingshuai.annotation.LogTip)\") public void afterThrowing()&#123; System.out.print(\"afterEntry\"); &#125; @AfterReturning(\"@annotation(com.sunmingshuai.annotation.LogTip)\") public void afterReturning()&#123; System.out.print(\"afterReturning\"); &#125;&#125; getAdvisorMethods(aspectClass)方法就是找出切面类中的所有的切面方法 看下这里的实现1234567891011121314151617181920private List&lt;Method&gt; getAdvisorMethods(Class&lt;?&gt; aspectClass) &#123; final List&lt;Method&gt; methods = new LinkedList&lt;Method&gt;(); // 筛选出没有Pointcut注解的方法 其实就是为了想获取所有的@Before @After @Around等注解标注的方法 // 这里的实现是直接排除Pointcut注解 这样代码更简洁些吧 ReflectionUtils.doWithMethods(aspectClass, new ReflectionUtils.MethodCallback() &#123; public void doWith(Method method) throws IllegalArgumentException &#123; // Exclude pointcuts if (AnnotationUtils.getAnnotation(method, Pointcut.class) == null) &#123; methods.add(method); &#125; &#125; &#125;); /** * 多个comparator的排序: 多个comparator组成一个排序链 程序执行这个排序链 有一个comparator返回非0数字则返回 或者直到执行完排序链 返回0 * 有点类似与sql中多个列的排序算法 * 最后排序结果 Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class */ Collections.sort(methods, METHOD_COMPARATOR); return methods;&#125; 代码里面的注释已经很清晰了 找出被切面所注释的方法 注意在方法返回前对方法进行了排序 这个排序算法阅读起来不太容易 主要是因为有多重排序 读者可以学习一下这个方法 也许在工作中能用的到 最后的排序顺序是Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class 这个顺序是很重要的 影响到后面方法调用过程中执行链的顺序然后再把找到的方法转化成advisor保存 我们可以想象的出来 这样一个advisor保存了非常多的信息在里面123456789101112131415public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aif, int declarationOrderInAspect, String aspectName) &#123; validate(aif.getAspectMetadata().getAspectClass()); // 包装类: 拆解出切面的切点表达式 AspectJExpressionPointcut ajexp = getPointcut(candidateAdviceMethod, aif.getAspectMetadata().getAspectClass()); if (ajexp == null) &#123; return null; &#125; //从构造函数中可以看出Advisor的组成结构 pointcut advice return new InstantiationModelAwarePointcutAdvisorImpl( this, ajexp, aif, candidateAdviceMethod, declarationOrderInAspect, aspectName);&#125; 对于切面来说 肯定要指定切点的 也就是这个方法在什么地点执行? getPointcut方法就比较简单了 首先查看是否有切面方法注解 然后根据切点构造AspectJExpressionPointcut1234567891011private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass) &#123; AspectJAnnotation&lt;?&gt; aspectJAnnotation = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod); if (aspectJAnnotation == null) &#123; return null; &#125; AspectJExpressionPointcut ajexp = new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class[0]); ajexp.setExpression(aspectJAnnotation.getPointcutExpression()); return ajexp;&#125; 然后再看最后一步构造advisor 可以看到是直接调用构造函数构造了一个实现类InstantiationModelAwarePointcutAdvisorImpl12345678910111213141516171819202122232425262728public InstantiationModelAwarePointcutAdvisorImpl(AspectJAdvisorFactory af, AspectJExpressionPointcut ajexp, MetadataAwareAspectInstanceFactory aif, Method method, int declarationOrderInAspect, String aspectName) &#123; this.declaredPointcut = ajexp; this.method = method; this.atAspectJAdvisorFactory = af; this.aspectInstanceFactory = aif; this.declarationOrder = declarationOrderInAspect; this.aspectName = aspectName; if (aif.getAspectMetadata().isLazilyInstantiated()) &#123; // Static part of the pointcut is a lazy type. Pointcut preInstantiationPointcut = Pointcuts.union(aif.getAspectMetadata().getPerClausePointcut(), this.declaredPointcut); // Make it dynamic: must mutate from pre-instantiation to post-instantiation state. // If it's not a dynamic pointcut, it may be optimized out // by the Spring AOP infrastructure after the first evaluation. this.pointcut = new PerTargetInstantiationModelPointcut(this.declaredPointcut, preInstantiationPointcut, aif); this.lazy = true; &#125; else &#123; // A singleton aspect. this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut); this.pointcut = declaredPointcut; this.lazy = false; &#125;&#125; 方法的内部就是各种赋值操作 但有一个方法需要看一下 instantiateAdvice(this.declaredPointcut) 我们往下追踪1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut ajexp, MetadataAwareAspectInstanceFactory aif, int declarationOrderInAspect, String aspectName) &#123; Class&lt;?&gt; candidateAspectClass = aif.getAspectMetadata().getAspectClass(); validate(candidateAspectClass); AspectJAnnotation&lt;?&gt; aspectJAnnotation = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod); if (aspectJAnnotation == null) &#123; return null; &#125; // If we get here, we know we have an AspectJ method. // Check that it's an AspectJ-annotated class if (!isAspect(candidateAspectClass)) &#123; throw new AopConfigException(\"Advice must be declared inside an aspect type: \" + \"Offending method '\" + candidateAdviceMethod + \"' in class [\" + candidateAspectClass.getName() + \"]\"); &#125; if (logger.isDebugEnabled()) &#123; logger.debug(\"Found AspectJ method: \" + candidateAdviceMethod); &#125; AbstractAspectJAdvice springAdvice; switch (aspectJAnnotation.getAnnotationType()) &#123; case AtBefore: springAdvice = new AspectJMethodBeforeAdvice(candidateAdviceMethod, ajexp, aif); break; case AtAfter: springAdvice = new AspectJAfterAdvice(candidateAdviceMethod, ajexp, aif); break; case AtAfterReturning: springAdvice = new AspectJAfterReturningAdvice(candidateAdviceMethod, ajexp, aif); AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation(); if (StringUtils.hasText(afterReturningAnnotation.returning())) &#123; springAdvice.setReturningName(afterReturningAnnotation.returning()); &#125; break; case AtAfterThrowing: springAdvice = new AspectJAfterThrowingAdvice(candidateAdviceMethod, ajexp, aif); AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation(); if (StringUtils.hasText(afterThrowingAnnotation.throwing())) &#123; springAdvice.setThrowingName(afterThrowingAnnotation.throwing()); &#125; break; case AtAround: springAdvice = new AspectJAroundAdvice(candidateAdviceMethod, ajexp, aif); break; case AtPointcut: if (logger.isDebugEnabled()) &#123; logger.debug(\"Processing pointcut '\" + candidateAdviceMethod.getName() + \"'\"); &#125; return null; default: throw new UnsupportedOperationException( \"Unsupported advice type on method \" + candidateAdviceMethod); &#125; // Now to configure the advice... springAdvice.setAspectName(aspectName); springAdvice.setDeclarationOrder(declarationOrderInAspect); // argNames String[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod); if (argNames != null) &#123; springAdvice.setArgumentNamesFromStringArray(argNames); &#125; springAdvice.calculateArgumentBindings(); return springAdvice;&#125; 可以看到生成了对应的advice 下面又对方法的参数进行处理argNames指的是注解的argNames参数提供的值 这里会考虑JoinPoint ProceedingJoinPoint特殊参数 这些参数是框架默认支持提供的 一般约定放到参数的第一位带了读者绕了这么久 读者可能已经不知道我们是从哪里进来的 进来的目的又是什么了 让我们再回到最开始的代码 我们进行了这么多步的操作其实就是为了要验证是不是应该要跳过这个bean 如果这个bean本身就是切面类的话 那么就不会被代理了继续往下执行 如果没有beanclass所对应的targetsource的话 也一样不会代理的 targetsource相关的知识不再介绍 创建代理的地方其实是在postProcessAfterInitialization中预知后事如何 且听下回分析…","tags":[{"name":"aop","slug":"aop","permalink":"http://yoursite.com/tags/aop/"}]},{"title":"aop源码解析一:注册BPP","date":"2017-05-22T05:25:52.000Z","path":"2017/05/22/aop源码解析一-注册BPP/","text":"本文目的如题,标签&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; expose-proxy=&quot;true&quot;/&gt;注册BPP(AspectJAutoProxyBeanDefinitionParser)源码分析 并没有介绍过BPP相关内容 这里简单的讲解下 读者心里有个概念就行 等有时间补写Bean的加载与读取的时候 会好好介绍这个重要的类!首先 spring在一些特殊的位置插入了一些处理代码(可能有些读者觉得这句话很眩 不太好理解 我换种表达方式:从加载配置文件到转换成对应的定义类 比如BeanDefinition 再到获取bean 这一整个过程都是spring在做的 他当然能够在任意想插的位置插入代码了) 例如在实例化前后 或者在初始化前后调的方法 这些类一般是BeanPostProcessor的子类 简称BPP 正文对于aop这样的非标准或者称为自定义命名空间的元素 spring会从spring.handlersspring.handlers文件中的对应关系找到相应的处理类 然后通过init()方法注册一些处理器 aop命名空间的处理类是AopNamespaceHandler 我们看一下他的init()方法 public void init() { // In 2.0 XSD as well as in 2.1 XSD. registerBeanDefinitionParser(&quot;config&quot;, new ConfigBeanDefinitionParser()); // registerBeanDefinitionParser(&quot;aspectj-autoproxy&quot;, new AspectJAutoProxyBeanDefinitionParser()); registerBeanDefinitionDecorator(&quot;scoped-proxy&quot;, new ScopedProxyBeanDefinitionDecorator()); // Only in 2.0 XSD: moved to context namespace as of 2.1 registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser()); } 从上面注册的处理器的关系我们知道 &lt;aop:aspectj-autoproxy&gt;标签的处理器是AspectJAutoProxyBeanDefinitionParser 同样 这是一个继承于BeanDefinitionParser的标准的解析器 我们看一下他的parse()方法 public BeanDefinition parse(Element element, ParserContext parserContext) { //注册BPP(AnnotationAwareAspectJAutoProxyCreator) AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element); // 如果有子元素的话 设置属性 extendBeanDefinition(element, parserContext); return null; } parse()方法可以说主要做了一件事情就是注册了一个BPP(BeanPostProcessor) 供后续使用 有些人看到这里可能就蒙圈了 这什么东西 名字这么长 看到后面的时候又会说这是什么东西 类的名字这么长 然后就会觉得好难 主要是读者阅读代码不多的原因 如果阅读的多了 你就会形成一个感觉：不管这个类名字多奇怪 名字多长 不过是一些基本类型(map list等)的包装而已 为了完成某一个功能所做的封装而已 //spring中的方法一般都比较清晰 短短的几行代码告诉了你这个方法要做什么事情 public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary( ParserContext parserContext, Element sourceElement) { //注册BPP(AnnotationAwareAspectJAutoProxyCreator) BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary( parserContext.getRegistry(), parserContext.extractSource(sourceElement)); //根据xml配置 设置AnnotationAwareAspectJAutoProxyCreator的proxyTargetClass exposeProxy属性 useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement); //注册组件bean 并暴露给外部 registerComponentIfNecessary(beanDefinition, parserContext); } 不断的追踪registerAspectJAnnotationAutoProxyCreatorIfNecessary()方法发现 就是注册了个BPP(AspectJAutoProxyBeanDefinitionParser) 不再贴出相关代码 我们看下useClassProxyingIfNecessary()方法 //处理proxy-target-class 以及 expose-proxy属性 private static void useClassProxyingIfNecessary(BeanDefinitionRegistry registry, Element sourceElement) { if (sourceElement != null) { //proxy-target-class true:强制使用CGLIB代理 推荐使用 boolean proxyTargetClass = Boolean.valueOf(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE)); if (proxyTargetClass) { AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry); } //expose-proxy true:暴露代理类 解决某些情况下 代理无法完成的情况 boolean exposeProxy = Boolean.valueOf(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE)); if (exposeProxy) { AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry); } } } 总结似乎&lt;aop:aspectj-autoproxy&gt;标签做的事情并不多 只是注册了一个BPP 但是这个BPP确实非常重要的! 我们用到的切面编程就依靠这个BPP去驱动实现 后面的文章会介绍这个BPP的源码是怎么实现AOP的","tags":[{"name":"aop","slug":"aop","permalink":"http://yoursite.com/tags/aop/"}]},{"title":"aop基本概念","date":"2017-05-20T10:22:15.000Z","path":"2017/05/20/aop基本概念/","text":"spring-aop功能 涉及到的东西很多 比如 切面 CGLIB 责任链等 这些东西会讲到 但不会详细讲解 一来是因为篇幅限制 另外博客的目的还是授人以鱼不如授人以渔 为了让大家能阅读下面几篇关于aop的文章更顺利些 这里先给读者讲一下 spring实现aop大概的流程以及涉及到的一些名词 因为注解形式的友好性 大家用的比较多 所以我们只谈这种形式的实现 aop 面向切面编程(AOP) :面向对象编程(OOP)的一种扩展 可以这样理解 我们之前所做的所有功能大体来说都是线性的(好比在流淌在水管里的水 一直是往前流动的 很难纵向扩展) 如果我们想加一些公共的服务 比如说日志 登录检查等 OOP将会有大量的重复代码 pointcut 连接点 就是这些额外的动作的发生点 (在什么地方) advice 切面 就是我们上面说的那些公共服务 比如说日志 登录检查等 (做什么) advisor 我们这里说的advisor 是实现代码里面的advisor 是一个封装类 包括了pointcut(验证是否跟指定方法匹配的功能) 与 advice 流程: 我们暂时把spring加载bean的过程笼统的分为两个阶段 spring加载配置文件并根据配置文件或者注解生成BeanDefinition的过程。 BeanDefinition看这个词的意思就略知一二 如果你看过tomcat的源码的话 应该会让你想起servletconfig 主要是用来保存bean的配置信息 spring提前加载非懒惰bean 很显然 aop的实现就是在第二个阶段 bean有几个比较特殊的阶段 比如实例化(instantiate) 初始化(initiate) 那么就可以在这几个特殊阶段的前后加一些方法 实现扩展 这些扩展点也就是我们属性的BPP的由来了","tags":[{"name":"aop","slug":"aop","permalink":"http://yoursite.com/tags/aop/"}]},{"title":"注解工作原理源码解析","date":"2017-05-14T03:31:11.000Z","path":"2017/05/14/注解工作原理源码解析/","text":"spring框架提供的注解方式的注入 大大方便了程序员的编程 但从另外一个方面来看 spring把功能细节隐藏的更深了 对技术有点追求的人 一定会很好奇spring注解的工作的方式 这篇博客以讲解@Value``@Autowired``@Qualifier注解为例来讲解注解是怎么工作的 (其他注解如@Resource @Required注解的工作原理类似)component-scan做了些什么:源码解读这篇博客的最后有介绍到 注册了一些注解处理器BPP 我们再看下这个方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors( BeanDefinitionRegistry registry, Object source) &#123; Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(4); // @Configuration if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; //@Autowired @Value if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; //@Required if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; //@PostConsruct @Resouce 等java注解 // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor. if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; // // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor. if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(); try &#123; def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, AnnotationConfigUtils.class.getClassLoader())); &#125; catch (ClassNotFoundException ex) &#123; throw new IllegalStateException( &quot;Cannot load optional framework class: &quot; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex); &#125; def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; return beanDefs;&#125; 注解以及对应的后置处理器如下表所示 注解 BPP @Configuration ConfigurationClassPostProcessor @Autowired(@Qualifier),@Value,@Inject AutowiredAnnotationBeanPostProcessor @Required RequiredAnnotationBeanPostProcessor @Postconstruct,PreDestroy,@Resource CommonAnnotationBeanPostProcessor @Persistence PersistenceAnnotationBeanPostProcessor 我们看下AutowiredAnnotationBeanPostProcessor这个处理器 @Autowired``@Qualifier``@Value注解的解析就是在postProcessMergedBeanDefinition以及postProcessPropertyValues这两个方法中完成的 postProcessMergedBeanDefinition这个方法执行时间的节点是在创建bean的实例后 在populateBean()方法调用前调用的这个方法主要完成的功能就是找出带有特定注解的field method 并记录在数据结构中123456789// 执行的时间节点是bean刚刚初始化完 但在属性填充之前public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) &#123; if (beanType != null) &#123; //找出所有的字段或者方法上的@Autowired @Value @Inject注解 并保存 InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null); //加入到BeanDefinition metadata.checkConfigMembers(beanDefinition); &#125;&#125; 最后会调用buildAutowiringMetadata(clazz)完成检查1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 分别对field method做检查 是否存在相应注解 * * @param clazz * @return */private InjectionMetadata buildAutowiringMetadata(Class&lt;?&gt; clazz) &#123; LinkedList&lt;InjectionMetadata.InjectedElement&gt; elements = new LinkedList&lt;InjectionMetadata.InjectedElement&gt;(); Class&lt;?&gt; targetClass = clazz; do &#123; LinkedList&lt;InjectionMetadata.InjectedElement&gt; currElements = new LinkedList&lt;InjectionMetadata.InjectedElement&gt;(); // 循环所有的field for (Field field : targetClass.getDeclaredFields()) &#123; // 寻找@Autowired @Value @Inject注解 只处理一个 Annotation ann = findAutowiredAnnotation(field); if (ann != null) &#123; //忽略静态属性的注入 if (Modifier.isStatic(field.getModifiers())) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(&quot;Autowired annotation is not supported on static fields: &quot; + field); &#125; continue; &#125; boolean required = determineRequiredStatus(ann); currElements.add(new AutowiredFieldElement(field, required)); &#125; &#125; // 循环所有的方法 比如setxxx方法注入 for (Method method : targetClass.getDeclaredMethods()) &#123; Annotation ann = null; Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method); if (BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123; ann = findAutowiredAnnotation(bridgedMethod); &#125; if (ann != null &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123; if (Modifier.isStatic(method.getModifiers())) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(&quot;Autowired annotation is not supported on static methods: &quot; + method); &#125; continue; &#125; if (method.getParameterTypes().length == 0) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(&quot;Autowired annotation should be used on methods with actual parameters: &quot; + method); &#125; &#125; boolean required = determineRequiredStatus(ann); PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz); currElements.add(new AutowiredMethodElement(method, required, pd)); &#125; &#125; elements.addAll(0, currElements); targetClass = targetClass.getSuperclass(); &#125; while (targetClass != null &amp;&amp; targetClass != Object.class); return new InjectionMetadata(clazz, elements);&#125; 特定注解指的就是@Autowired @Value @Inject(较少用) @Qualifier注解是跟@Autowired注解搭配使用的 单独使用是不起作用的特定的数据结构指的就是InjectionMetadata 博主前面说过 阅读源代码千万不要对这样的代码感到畏惧 就把他当成一个包装类或者工具类就可以了 为了完成或者包装某些功能写出的一些类而已再具体的代码就不带着一起看了 相信读者阅读这样的代码应该没有任何问题我们接着看下另外一个方法postProcessPropertyValues(xxx)这个方法的执行的时间节点是在populateBean(xxx)之后123456789101112131415@Overridepublic PropertyValues postProcessPropertyValues( PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException &#123; //从缓存中读取出 InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs); try &#123; //注入 metadata.inject(bean, beanName, pvs); &#125; catch (Throwable ex) &#123; throw new BeanCreationException(beanName, &quot;Injection of autowired dependencies failed&quot;, ex); &#125; return pvs;&#125; 在postProcessMergedBeanDefinition(xxx)方法中把循环检查出的特定注解修饰的field``method以特定的数据结构以beanName为key保存在了一个map中 在postProcessPropertyValues(xxx)方法中取出来处理这里我们以field注入讲解 进入方法AutowiredFieldElement#inject(xxx)1234567891011121314151617181920212223242526272829303132333435363738394041424344@Overrideprotected void inject(Object bean, String beanName, PropertyValues pvs) throws Throwable &#123; Field field = (Field) this.member; try &#123; Object value; if (this.cached) &#123; value = resolvedCachedArgument(beanName, this.cachedFieldValue); &#125; else &#123; DependencyDescriptor desc = new DependencyDescriptor(field, this.required); Set&lt;String&gt; autowiredBeanNames = new LinkedHashSet&lt;String&gt;(1); TypeConverter typeConverter = beanFactory.getTypeConverter(); value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter); synchronized (this) &#123; if (!this.cached) &#123; if (value != null || this.required) &#123; this.cachedFieldValue = desc; registerDependentBeans(beanName, autowiredBeanNames); if (autowiredBeanNames.size() == 1) &#123; String autowiredBeanName = autowiredBeanNames.iterator().next(); if (beanFactory.containsBean(autowiredBeanName)) &#123; if (beanFactory.isTypeMatch(autowiredBeanName, field.getType())) &#123; this.cachedFieldValue = new RuntimeBeanReference(autowiredBeanName); &#125; &#125; &#125; &#125; else &#123; this.cachedFieldValue = null; &#125; this.cached = true; &#125; &#125; &#125; // 通过反射设置值 if (value != null) &#123; ReflectionUtils.makeAccessible(field); field.set(bean, value); &#125; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(&quot;Could not autowire field: &quot; + field, ex); &#125;&#125; 这里 DependencyDescriptor同样是为了方便操作 对field进行的包装beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter)方法完成解析 最后会调用doResolveDependency(xxx)方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107protected Object doResolveDependency(DependencyDescriptor descriptor, Class&lt;?&gt; type, String beanName, Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter) throws BeansException &#123; //处理@Value注解 Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor); if (value != null) &#123; if (value instanceof String) &#123; // 这里会处理掉&quot;$&#123;&#125;&quot; String strVal = resolveEmbeddedValue((String) value); BeanDefinition bd = (beanName != null &amp;&amp; containsBean(beanName) ? getMergedBeanDefinition(beanName) : null); value = evaluateBeanDefinitionString(strVal, bd); &#125; TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter()); return (descriptor.getField() != null ? converter.convertIfNecessary(value, type, descriptor.getField()) : converter.convertIfNecessary(value, type, descriptor.getMethodParameter())); &#125; //处理@Autowired注解 if (type.isArray()) &#123; Class&lt;?&gt; componentType = type.getComponentType(); Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, componentType, descriptor); if (matchingBeans.isEmpty()) &#123; if (descriptor.isRequired()) &#123; raiseNoSuchBeanDefinitionException(componentType, &quot;array of &quot; + componentType.getName(), descriptor); &#125; return null; &#125; if (autowiredBeanNames != null) &#123; autowiredBeanNames.addAll(matchingBeans.keySet()); &#125; TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter()); return converter.convertIfNecessary(matchingBeans.values(), type); &#125; else if (Collection.class.isAssignableFrom(type) &amp;&amp; type.isInterface()) &#123; Class&lt;?&gt; elementType = descriptor.getCollectionType(); if (elementType == null) &#123; if (descriptor.isRequired()) &#123; throw new FatalBeanException(&quot;No element type declared for collection [&quot; + type.getName() + &quot;]&quot;); &#125; return null; &#125; Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, elementType, descriptor); if (matchingBeans.isEmpty()) &#123; if (descriptor.isRequired()) &#123; raiseNoSuchBeanDefinitionException(elementType, &quot;collection of &quot; + elementType.getName(), descriptor); &#125; return null; &#125; if (autowiredBeanNames != null) &#123; autowiredBeanNames.addAll(matchingBeans.keySet()); &#125; TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter()); return converter.convertIfNecessary(matchingBeans.values(), type); &#125; else if (Map.class.isAssignableFrom(type) &amp;&amp; type.isInterface()) &#123; Class&lt;?&gt; keyType = descriptor.getMapKeyType(); if (keyType == null || !String.class.isAssignableFrom(keyType)) &#123; if (descriptor.isRequired()) &#123; throw new FatalBeanException(&quot;Key type [&quot; + keyType + &quot;] of map [&quot; + type.getName() + &quot;] must be assignable to [java.lang.String]&quot;); &#125; return null; &#125; Class&lt;?&gt; valueType = descriptor.getMapValueType(); if (valueType == null) &#123; if (descriptor.isRequired()) &#123; throw new FatalBeanException(&quot;No value type declared for map [&quot; + type.getName() + &quot;]&quot;); &#125; return null; &#125; Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, valueType, descriptor); if (matchingBeans.isEmpty()) &#123; if (descriptor.isRequired()) &#123; raiseNoSuchBeanDefinitionException(valueType, &quot;map with value type &quot; + valueType.getName(), descriptor); &#125; return null; &#125; if (autowiredBeanNames != null) &#123; autowiredBeanNames.addAll(matchingBeans.keySet()); &#125; return matchingBeans; &#125; else &#123; Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor); if (matchingBeans.isEmpty()) &#123; if (descriptor.isRequired()) &#123; raiseNoSuchBeanDefinitionException(type, &quot;&quot;, descriptor); &#125; return null; &#125; if (matchingBeans.size() &gt; 1) &#123; String primaryBeanName = determinePrimaryCandidate(matchingBeans, descriptor); if (primaryBeanName == null) &#123; throw new NoUniqueBeanDefinitionException(type, matchingBeans.keySet()); &#125; if (autowiredBeanNames != null) &#123; autowiredBeanNames.add(primaryBeanName); &#125; return matchingBeans.get(primaryBeanName); &#125; // We have exactly one match. Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next(); if (autowiredBeanNames != null) &#123; autowiredBeanNames.add(entry.getKey()); &#125; return entry.getValue(); &#125;&#125; 我们先看对@Value注解的解析@Value注解有两种使用方法 除了可以直接指出我们想要的值外 还可以1@Value(&quot;$&#123;xxx&#125;&quot;) 这个功能在spring3.x以后才能使用 3.x以前的版本取出来的就是${xxx}而不会再被解析 其背后的原因就是3.x以后的代码 通过PropertyPlaceholderConfigurer向beanFactory加入了一个处理器 PropertyPlaceholderConfigurer源码解析 这篇文章的最后又指出 getAutowireCandidateResolver()这个方法返回的是在初始化beanFactory的过程中加入的QualifierAnnotationAutowireCandidateResolver类12345678910protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123; if (this.allowBeanDefinitionOverriding != null) &#123; beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; if (this.allowCircularReferences != null) &#123; beanFactory.setAllowCircularReferences(this.allowCircularReferences); &#125; //设置Qualifier注解解析类 beanFactory.setAutowireCandidateResolver(new QualifierAnnotationAutowireCandidateResolver());&#125; QualifierAnnotationAutowireCandidateResolver#getSuggestedValue(xxx) 12345678910public Object getSuggestedValue(DependencyDescriptor descriptor) &#123; Object value = findValue(descriptor.getAnnotations()); if (value == null) &#123; MethodParameter methodParam = descriptor.getMethodParameter(); if (methodParam != null) &#123; value = findValue(methodParam.getMethodAnnotations()); &#125; &#125; return value;&#125; 如果有@Value注解的话 返回设置的value值 如果没有就返回null如果返回的value不为null的话 就需要进一步处理这个原始值 因为这个值可能不是我们最终想要的 例如我们前面讲到的@Value(&quot;${xxx}&quot;) 这个时候返回的就是${xxx} 显然不是我们想要的 当然spring还提供了处理表达式的支持 这里不再讲解最后再通过converter处理一遍返回 如果返回的是null 说明没有@Value注解 spring增加了对array collection map注入的支持 有兴趣的可以看看 我们就选一个最简单最基础的注入为例来讲解 @Autowired的工作原理 也就是最后一个else分支12345678910111213141516171819202122232425&#123; Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor); if (matchingBeans.isEmpty()) &#123; if (descriptor.isRequired()) &#123; raiseNoSuchBeanDefinitionException(type, &quot;&quot;, descriptor); &#125; return null; &#125; if (matchingBeans.size() &gt; 1) &#123; String primaryBeanName = determinePrimaryCandidate(matchingBeans, descriptor); if (primaryBeanName == null) &#123; throw new NoUniqueBeanDefinitionException(type, matchingBeans.keySet()); &#125; if (autowiredBeanNames != null) &#123; autowiredBeanNames.add(primaryBeanName); &#125; return matchingBeans.get(primaryBeanName); &#125; // We have exactly one match. Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next(); if (autowiredBeanNames != null) &#123; autowiredBeanNames.add(entry.getKey()); &#125; return entry.getValue(); &#125; 进入findAutowireCandidates(xxx)方法1234567891011121314151617181920212223protected Map&lt;String, Object&gt; findAutowireCandidates( String beanName, Class&lt;?&gt; requiredType, DependencyDescriptor descriptor) &#123; String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( this, requiredType, true, descriptor.isEager()); Map&lt;String, Object&gt; result = new LinkedHashMap&lt;String, Object&gt;(candidateNames.length); for (Class&lt;?&gt; autowiringType : this.resolvableDependencies.keySet()) &#123; if (autowiringType.isAssignableFrom(requiredType)) &#123; Object autowiringValue = this.resolvableDependencies.get(autowiringType); autowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType); if (requiredType.isInstance(autowiringValue)) &#123; result.put(ObjectUtils.identityToString(autowiringValue), autowiringValue); break; &#125; &#125; &#125; for (String candidateName : candidateNames) &#123; if (!candidateName.equals(beanName) &amp;&amp; isAutowireCandidate(candidateName, descriptor)) &#123; result.put(candidateName, getBean(candidateName)); &#125; &#125; return result;&#125; 首先从beanFactory中取出所有符合requiredType类型的bean的名称 requiredType是要被注入的字段的类型(其实这一步就已经完成了@Autowired注解的功能) 然后循环判断这些bean中有哪些是符合条件的 哪些是不符合条件的(想一想为什么还要继续判断?)123456789101112131415161718192021222324public boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor) throws NoSuchBeanDefinitionException &#123; // Consider FactoryBeans as autowiring candidates. boolean isFactoryBean = (descriptor != null &amp;&amp; descriptor.getDependencyType() != null &amp;&amp; FactoryBean.class.isAssignableFrom(descriptor.getDependencyType())); if (isFactoryBean) &#123; beanName = BeanFactoryUtils.transformedBeanName(beanName); &#125; if (containsBeanDefinition(beanName)) &#123; return isAutowireCandidate(beanName, getMergedLocalBeanDefinition(beanName), descriptor); &#125; else if (containsSingleton(beanName)) &#123; return isAutowireCandidate(beanName, new RootBeanDefinition(getType(beanName)), descriptor); &#125; else if (getParentBeanFactory() instanceof ConfigurableListableBeanFactory) &#123; // No bean definition found in this factory -&gt; delegate to parent. return ((ConfigurableListableBeanFactory) getParentBeanFactory()).isAutowireCandidate(beanName, descriptor); &#125; else &#123; return true; &#125;&#125; 这个方法里面是考虑是很多中情况了 比如是不是factoryBean等 这里我们还是以最简单的情况分析最后会进入方法QualifierAnnotationAutowireCandidateResolver#isAutowireCandidate(xxx)方法123456789101112131415161718192021public boolean isAutowireCandidate(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor) &#123; if (!bdHolder.getBeanDefinition().isAutowireCandidate()) &#123; // 如果已经设置了非候选类 直接返回 return false; &#125; if (descriptor == null) &#123; // no qualification necessary return true; &#125; boolean match = checkQualifiers(bdHolder, descriptor.getAnnotations()); if (match) &#123; MethodParameter methodParam = descriptor.getMethodParameter(); if (methodParam != null) &#123; Method method = methodParam.getMethod(); if (method == null || void.class.equals(method.getReturnType())) &#123; match = checkQualifiers(bdHolder, methodParam.getMethodAnnotations()); &#125; &#125; &#125; return match;&#125; 对于@Autowired注解 是按类型匹配的 前面已经筛选出了beanFactory中所有的符合条件的类型 这里为什么还要继续筛选呢 原因就是可能还会有@Qualifier注解1234567891011121314151617181920212223242526272829303132333435363738protected boolean checkQualifiers(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch) &#123; if (ObjectUtils.isEmpty(annotationsToSearch)) &#123; return true; &#125; SimpleTypeConverter typeConverter = new SimpleTypeConverter(); for (Annotation annotation : annotationsToSearch) &#123; Class&lt;? extends Annotation&gt; type = annotation.annotationType(); boolean checkMeta = true; boolean fallbackToMeta = false; if (isQualifier(type)) &#123; if (!checkQualifier(bdHolder, annotation, typeConverter)) &#123; fallbackToMeta = true; &#125; else &#123; checkMeta = false; &#125; &#125; if (checkMeta) &#123; boolean foundMeta = false; for (Annotation metaAnn : type.getAnnotations()) &#123; Class&lt;? extends Annotation&gt; metaType = metaAnn.annotationType(); if (isQualifier(metaType)) &#123; foundMeta = true; // Only accept fallback match if @Qualifier annotation has a value... // Otherwise it is just a marker for a custom qualifier annotation. if ((fallbackToMeta &amp;&amp; StringUtils.isEmpty(AnnotationUtils.getValue(metaAnn))) || !checkQualifier(bdHolder, metaAnn, typeConverter)) &#123; return false; &#125; &#125; &#125; if (fallbackToMeta &amp;&amp; !foundMeta) &#123; return false; &#125; &#125; &#125; return true;&#125; 这个方法做的工作就是检查有没有@Qualifier注解 如果有的话 再检查是不是符合条件例如虽然有多个候选的符合条件的类型 但是@Qualifier指出了特定的名称 这样就实现了按照名称的匹配最后返回通过最终筛选的bean","tags":[]},{"title":"LimitLatch源码解析","date":"2017-05-13T09:59:57.000Z","path":"2017/05/13/LimitLatch源码解析/","text":"","tags":[]},{"title":"PropertyPlaceholderConfigurer源码解析","date":"2017-05-13T07:36:05.000Z","path":"2017/05/13/PropertyPlaceholderConfigurer源码解析/","text":"这篇文章我们介绍一个常用的BFPP来消除我们心中的对BFPP的陌生感在spring配置文件中 读者一定经常遇到过${xxx}的写法 然后spring会帮我们替换成properties中对应的value值 那么这个变量是什么时候又是被哪个类替换的呢在文章ClassPathXmlApplicationContext源码解析三:BFPP中我们提到了BFPP的概念 BFPP的全称是BeanFactoryPostProcessor是工厂级别的处理器 它的调用时间点是在将配置文件转化为BeanDefinition之后 加载成bean之前调用的我们先看下配置文件123456789&lt;bean id=&quot;dev_propertyPlace&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;2&quot;/&gt; &lt;property name=&quot;ignoreUnresolvablePlaceholders&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;locations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:config-sunms-dev.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 在使用这个bfpp之前当然是先获取这个bean 处理一些事情 比如将locations对应的string转化成需要的resource类型既然是bfpp 那么我们的阅读入口就好找了 PropertyResourceConfigurer##postProcessBeanFactory()方法12345678910111213public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; try &#123; //加载properties文件 Properties mergedProps = mergeProperties(); convertProperties(mergedProps); //替换 processProperties(beanFactory, mergedProps); &#125; catch (IOException ex) &#123; throw new BeanInitializationException(&quot;Could not load properties&quot;, ex); &#125;&#125; spring的代码一直这么优雅 高度抽象 让人一看就知道要做什么事情第一步就是加载我们指定的properties文件 第二步默认没有做什么事情最后一步就是重点了123456protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess, Properties props) throws BeansException &#123; StringValueResolver valueResolver = new PlaceholderResolvingStringValueResolver(props); doProcessProperties(beanFactoryToProcess, valueResolver);&#125; 先是构建一个处理类 处理类不过是提供一些方法 定义了诸如前缀${ 后缀} 使后面的代码更简洁 然后交给doProcessProperties处理123456789101112131415161718192021222324252627protected void doProcessProperties(ConfigurableListableBeanFactory beanFactoryToProcess, StringValueResolver valueResolver) &#123; BeanDefinitionVisitor visitor = new BeanDefinitionVisitor(valueResolver); String[] beanNames = beanFactoryToProcess.getBeanDefinitionNames(); for (String curName : beanNames) &#123; // Check that we&apos;re not parsing our own bean definition, // to avoid failing on unresolvable placeholders in properties file locations. if (!(curName.equals(this.beanName) &amp;&amp; beanFactoryToProcess.equals(this.beanFactory))) &#123; BeanDefinition bd = beanFactoryToProcess.getBeanDefinition(curName); try &#123; visitor.visitBeanDefinition(bd); &#125; catch (Exception ex) &#123; throw new BeanDefinitionStoreException(bd.getResourceDescription(), curName, ex.getMessage(), ex); &#125; &#125; &#125; // New in Spring 2.5: resolve placeholders in alias target names and aliases as well. beanFactoryToProcess.resolveAliases(valueResolver); // New in Spring 3.0: resolve placeholders in embedded values such as annotation attributes. // 处理如@Value(&quot;$&#123;name&#125;&quot;) beanFactoryToProcess.addEmbeddedValueResolver(valueResolver); &#125; 下面的代码就比较简单了 就是处理所有的BeanDefinitioin 不包含本身 将诸如parentName等属性中的${xxx}变量替换掉1234567891011public void visitBeanDefinition(BeanDefinition beanDefinition) &#123; visitParentName(beanDefinition); visitBeanClassName(beanDefinition); visitFactoryBeanName(beanDefinition); visitFactoryMethodName(beanDefinition); visitScope(beanDefinition); visitPropertyValues(beanDefinition.getPropertyValues()); ConstructorArgumentValues cas = beanDefinition.getConstructorArgumentValues(); visitIndexedArgumentValues(cas.getIndexedArgumentValues()); visitGenericArgumentValues(cas.getGenericArgumentValues());&#125; 有趣的是最后一行代码1beanFactoryToProcess.addEmbeddedValueResolver(valueResolver); 这句代码把构建好的工具类加入到了beanFactory中 是spring3.0加入的 加入的作用就是处理诸如@Value注解的时候 如果有${xxx}的形式的话 会被这个工具类给替换掉 这个在@Autowired注解工作原理源码解析的时候 我们会再提到","tags":[{"name":"BFPP","slug":"BFPP","permalink":"http://yoursite.com/tags/BFPP/"}]},{"title":"ClassPathXmlApplicationContext源码解析五:加载单例","date":"2017-05-12T01:03:38.000Z","path":"2017/05/12/ClassPathXmlApplicationContext源码解析五-加载单例/","text":"在refresh()方法中 最重要的方法有两个 分别是obtainFreshBeanFactory()与 finishBeanFactoryInitialization(beanFactory) 第一个方法我们已经讲解过了 现在我们看下第二个方法123456789101112131415protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123; if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123; beanFactory.setConversionService( beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)); &#125; String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false); for (String weaverAwareName : weaverAwareNames) &#123; getBean(weaverAwareName); &#125; beanFactory.setTempClassLoader(null); beanFactory.freezeConfiguration(); //重要 实例化所有的非懒惰加载的bean beanFactory.preInstantiateSingletons();&#125; 到beanFactory.freezeConfiguration()这里的时候 就不再允许改变配置文件了 因为可能会影响到后面的加载过程如果bean是单例模式 并且没有设置懒惰加载的话 就预先实例化这个bean 调用DefaultListableBeanFactory#preInstantiateSingletons()方法 DefaultListableBeanFactory是个很重要的类 承载了很多功能 读者可以借助编辑器查看下这个类的继承关系12345678910111213141516171819202122232425262728293031323334353637public void preInstantiateSingletons() throws BeansException &#123; if (this.logger.isInfoEnabled()) &#123; this.logger.info(&quot;Pre-instantiating singletons in &quot; + this); &#125; List&lt;String&gt; beanNames; synchronized (this.beanDefinitionMap) &#123; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames); &#125; // 循环检查所有的bean 并按情况加载 for (String beanName : beanNames) &#123; RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123; //如果是工厂bean if (isFactoryBean(beanName)) &#123; final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName); boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123; isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123; public Boolean run() &#123; return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit(); &#125; &#125;, getAccessControlContext()); &#125; else &#123; isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit()); &#125; if (isEagerInit) &#123; getBean(beanName); &#125; &#125; else &#123; getBean(beanName); &#125; &#125; &#125;&#125; 对于beanFactory中的每一个bean 先根据beanName获取BeanDefinition 因为我们所需要的属性等都在这个类里面了 调用getMergedLocalBeanDefinition(beanName) 方法获得 这里需要考虑的一个问题就是如果设置了parent属性的话(在由xml文件载入BeanDefinition的时候 parent属性被当作普通属性来对待 并没有做什么特殊处理)1&lt;bean id=&quot;xxx&quot; class=&quot;com.xxx.xxx&quot; parent=&quot;TestXXX&quot;/&gt; 那么就需要跟parent所指向的BeanDefinition的配置属性合并后再返回了. 当然这里肯定是个递归调用 因为parent本身可能也定义了自己的parent属性 合并的原则是先拷贝父类的所有属性元素,然后与子类的合并,如果有属性名一样的话,则覆盖.在满足下面三个条件的时候 才会尝试加载 不是抽象类 单例模式 没有设置懒惰加载 如果是FactoryBean的话 那么就需要考虑是返回FactoryBean本身 还是返回FactoryBean#getObect()方法返回的对象 spring约定 如果要返回FactoryBean本身 那么需要在beanName前加上约定的&amp;符号 否则就是返回T getObject() 我们看一下FactoryBean的接口定义 很显然 这是利用了工厂方法12345public interface FactoryBean &#123; T getObject() throws Exception; Class&lt;?&gt; getObjectType(); boolean isSingleton();&#125; 下面的源码内容 对于读者来说 比较难理解 对于作者本人来说比较难讲解 一个是涉及到的内容比较多 比如 FactoryBean 循环依赖 代理 属性填充 BPP 寻找构造函数等 另外一个是功能间咬合比较多 下文介绍的时候 我们就不考虑那么多 先把最简单的情况介绍到 如下面的代码实例:第一次加载 有默认构造函数 TestA中有一个java基本类型 一个引用类型 init-method属性, 在了解加载TestA的加载的基础上 再去了解那些扩展功能 当然对于TestA的加载其实过程很简单 简单叙述来说 就是根据TestA.class实例化TestA 这里用的是默认的构造函数 然后是属性的填充 调用init()方法等 1234567891011121314151617181920212223242526272829303132public class TestA&#123; private String a; private TestB b; @Autowired private TestC c; // getXXX setXXX public void init()&#123; System.out.println(&quot;Hello World&quot;); &#125;&#125;public class TestB&#123; private int c;&#125;____________________________......&lt;!-- --&gt; &lt;component:scan basepackage=&quot;com.xxx.xxx&quot;/&gt;&lt;bean id=&quot;testA&quot; class=&quot;com.xxx.xxx.TestA&quot;&gt; &lt;property name=&quot;b&quot; ref=&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;testB&quot; class=&quot;com.xxx.xxx.TestB&quot;/&gt;&lt;bean id=&quot;testC&quot; class=&quot;com.xxx.xxx.TestC&quot;/&gt;...... AbstractBeanFactory#doGetBean(...)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152protected &lt;T&gt; T doGetBean( final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123; // 如果是别名 就返回对应的真实的beanName // 如果以&amp;开头 先去除 final String beanName = transformedBeanName(name); Object bean; // Eagerly check singleton cache for manually registered singletons. Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isDebugEnabled()) &#123; if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.debug(&quot;Returning eagerly cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos; that is not fully initialized yet - a consequence of a circular reference&quot;); &#125; else &#123; logger.debug(&quot;Returning cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;); &#125; &#125; //todo 待看 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; //依赖分为三种依赖: 原型循环依赖 构造器循环依赖 单例循环依赖 //只有单例依赖才能解决 其他情况只能抛出异常 //原型循环依赖 无法解决 抛异常 if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; // Check if bean definition exists in this factory. BeanFactory parentBeanFactory = getParentBeanFactory(); //如果这个容器中没有bean的定义的话 去父容器中加载 if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // Not found -&gt; check parent. //还原beanName String nameToLookup = originalBeanName(name); if (args != null) &#123; // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else &#123; // No args -&gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; &#125; if (!typeCheckOnly) &#123; markBeanAsCreated(beanName); &#125; try &#123; //返回配置文件定义的bean的定义信息 GenericBeanDefinition-&gt;RootBeanDefinition final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // 先加载配置中`depend-on`属性中配置的`bean` String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; for (String dependsOnBean : dependsOn) &#123; getBean(dependsOnBean); registerDependentBean(dependsOnBean, beanName); &#125; &#125; // 单例模式 if (mbd.isSingleton()) &#123; sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; public Object getObject() throws BeansException &#123; try &#123; //核心加载部分 return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; &#125; &#125; &#125;); //获取到的bean可能是FactoryBean类型的bean bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; // 原型模式 else if (mbd.isPrototype()) &#123; // It&apos;s a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; else &#123; String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) &#123; throw new IllegalStateException(&quot;No Scope registered for scope &apos;&quot; + scopeName + &quot;&apos;&quot;); &#125; try &#123; Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123; public Object getObject() throws BeansException &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123; throw new BeanCreationException(beanName, &quot;Scope &apos;&quot; + scopeName + &quot;&apos; is not active for the current thread; &quot; + &quot;consider defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;, ex); &#125; &#125; &#125; catch (BeansException ex) &#123; cleanupAfterBeanCreationFailure(beanName); throw ex; &#125; &#125; // Check if required type matches the type of the actual bean instance. if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123; try &#123; return getTypeConverter().convertIfNecessary(bean, requiredType); &#125; catch (TypeMismatchException ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Failed to convert bean &apos;&quot; + name + &quot;&apos; to required type [&quot; + ClassUtils.getQualifiedName(requiredType) + &quot;]&quot;, ex); &#125; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; &#125; return (T) bean;&#125; 在getSingleton(beanName)的调用中 其实处理了好几种情况 是否已经加载完成过 bean的加载是个耗时的过程 加载完成后就放到map中保存 有就直接返回 没有加载完成 并且知道正在创建中 那么说明是遇到了循环依赖问题对于循环依赖问题 以后有时间会单独开一个博客讲解 这里简单介绍下 首先对于都是单例模式来说 会遇到两种循环依赖问题 构造器循环依赖 set循环依赖 举例如下 1234567891011121314//构造器循环依赖public class TestA()&#123; ... public TestA(TestB b)&#123; &#125; ...&#125;public class TestB()&#123; ... public TestB(TestA a)&#123; &#125; ...&#125; 123456789101112131415//set循环依赖public class TestA()&#123; ... @Autowired private TestB b; ...&#125;public class TestB()&#123; ... @Autowired private TestA a; ...&#125; 构造器循环依赖 是不能够被解决的 原因如下：在实例化TestA的时候需要去实例化TestB 然后去实例化TestB 然后这个时候又发现需要TestA 所以两个都不能完成实例化而对于set依赖来说 虽然也存在循环依赖 但问题却能够得到解决 解释如下：TestA实例化完成后 在给TestA填充属性的过程中发现需要TestB 存下TestA的引用 然后去获取TestB 实例化TestB后 给TestB填充属性的过程中发现需要TestA 然后再去获取TestA 之前埋入了TestA的引用 （虽然还没加载完整） 这个时候返回TestA的引用 这个时候TestB加载完成 回去继续加载TestA 这个时候循环依赖也就没有了Spring通过记录不同状态下的引用 即提前暴露地址的方式解决循环依赖在第一次讲解的时候 我们暂且不考虑那么多 我们就当成我们现在的情况是第一次加载这个bean 并且不存在循环依赖的情况 当然我们还是可以看下他们额外做了写什么 大概有个印象我们回到getSingleton(...)方法 里面有两个map 一个是earlySingletonObjects 另外一个是singletonFactories 这两个map中的东西似乎是互斥的.如果这个时候获得到了的话 就返回 然后再通过getObjectForBeanInstance处理 这个方法主要判断返回的是不是我们最终想要的 如果是FactoryBean类型的话 还需要进一步处理我们看下单例模式下的bean的加载123456789101112131415sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; public Object getObject() throws BeansException &#123; try &#123; //核心加载部分 return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; &#125; &#125; &#125;); 12345678910111213141516171819202122232425262728293031323334353637383940public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123; Assert.notNull(beanName, &quot;&apos;beanName&apos; must not be null&quot;); synchronized (this.singletonObjects) &#123; Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) &#123; if (this.singletonsCurrentlyInDestruction) &#123; throw new BeanCreationNotAllowedException(beanName, &quot;Singleton bean creation not allowed while the singletons of this factory are in destruction &quot; + &quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;); &#125; //时间节点 放入singletonsCurrentlyInCreation 代表这个bean正在加载中 beforeSingletonCreation(beanName); boolean recordSuppressedExceptions = (this.suppressedExceptions == null); if (recordSuppressedExceptions) &#123; this.suppressedExceptions = new LinkedHashSet&lt;Exception&gt;(); &#125; try &#123; singletonObject = singletonFactory.getObject(); &#125; catch (BeanCreationException ex) &#123; if (recordSuppressedExceptions) &#123; for (Exception suppressedException : this.suppressedExceptions) &#123; ex.addRelatedCause(suppressedException); &#125; &#125; throw ex; &#125; finally &#123; if (recordSuppressedExceptions) &#123; this.suppressedExceptions = null; &#125; //时间节点 从singletonsCurrentlyInCreation中清除 代表创建完成 afterSingletonCreation(beanName); &#125; //加入到singletonObjects中 从singletonFactories earlySingletonObjects中去除 addSingleton(beanName, singletonObject); &#125; return (singletonObject != NULL_OBJECT ? singletonObject : null); &#125;&#125; 我们看下singletonFactory回调方法createBean1234567891011121314151617181920212223242526272829303132333435protected Object createBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) throws BeanCreationException &#123; // 获取class属性 resolveBeanClass(mbd, beanName); // Prepare method overrides. try &#123; //look-method replace-method配置项检查处理 如果不清楚的可以先搜索相关使用demo mbd.prepareMethodOverrides(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, &quot;Validation of method overrides failed&quot;, ex); &#125; try &#123; // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. // todo AOP功能实现 `AnnotationAwareAspectJAutoProxyCreator` // [看另外一篇博客](http://www.sunmingshuai.cn/2017/05/22/aop%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%80/) Object bean = resolveBeforeInstantiation(beanName, mbd); if (bean != null) &#123; return bean; &#125; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex); &#125; Object beanInstance = doCreateBean(beanName, mbd, args); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Finished creating instance of bean &apos;&quot; + beanName + &quot;&apos;&quot;); &#125; return beanInstance;&#125; 如果我们有对类进行代理的话 那么返回的就是代理类 而不是裸类 这个处理就是在resolveBeforeInstantiation方法中处理的 这里不深入研究 想了解的可以看博主的另外的博客介绍 aop源码解析一:注册BPP aop源码解析二:寻找Advisor方法又转到了doCreateBean(beanName,mnb,args)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) &#123; // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) &#123; instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; //判断采用哪种实例化方法 factoryMethod | 构造器(如果有多个构造器还需要根据args判断采用哪个构造器构造) //如果有配置replace-method lookup-method 会创建代理 //注册属性编辑器 instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); // Allow post-processors to modify the merged bean definition. synchronized (mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; //todo ## BPP触发的另一个地方 如处理@AutoWired注解的AutowiredAnnotationBeanPostProcessor#postProcessMergedBeanDefinition() // [component-scan做了些什么:源码解读](http://www.sunmingshuai.cn/2017/04/28/component-scan%E5%81%9A%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/) applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); mbd.postProcessed = true; &#125; &#125; // 提前加入缓存 以辩能够解决循环引用问题 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Eagerly caching bean &apos;&quot; + beanName + &quot;&apos; to allow for resolving potential circular references&quot;); &#125; // 解决循环依赖问题的关键 提前把ObjectFactory加入进来 如果有碰到循环依赖的话 通过ObjectFactory获取bean // 因为他们代表的地址是一样的 addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123; public Object getObject() throws BeansException &#123; return getEarlyBeanReference(beanName, mbd, bean); &#125; &#125;); &#125; // 初始化bean的实例 Object exposedObject = bean; try &#123; // bean属性的填充(xml文件定义的属性 被@Autowired @Value等注解修饰 以及一些其他属性 IOC的直接体现 populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) &#123; exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; &#125; catch (Throwable ex) &#123; if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123; throw (BeanCreationException) ex; &#125; else &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex); &#125; &#125; if (earlySingletonExposure) &#123; // 再一次调用`getSingleton()`方法 只是这一次`allowEarlyReference`为false Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) &#123; if (exposedObject == bean) &#123; exposedObject = earlySingletonReference; &#125; else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123; String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length); for (String dependentBean : dependentBeans) &#123; if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123; actualDependentBeans.add(dependentBean); &#125; &#125; if (!actualDependentBeans.isEmpty()) &#123; throw new BeanCurrentlyInCreationException(beanName, &quot;Bean with name &apos;&quot; + beanName + &quot;&apos; has been injected into other beans [&quot; + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + &quot;] in its raw version as part of a circular reference, but has eventually been &quot; + &quot;wrapped. This means that said other beans do not use the final version of the &quot; + &quot;bean. This is often the result of over-eager type matching - consider using &quot; + &quot;&apos;getBeanNamesOfType&apos; with the &apos;allowEagerInit&apos; flag turned off, for example.&quot;); &#125; &#125; &#125; &#125; // Register bean as disposable. try &#123; registerDisposableBeanIfNecessary(beanName, bean, mbd); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex); &#125; return exposedObject; &#125; 这里会判断采用哪种方式实例化bean 如果采用有参构造函数的形式的话 匹配逻辑稍微有点复杂 实例化后会注册一些属性编辑器 就是把string类型的参数值能够转化为我们想要的类型值applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName)方法是spring的一个扩展方法 例如我们常用的@Autowired就在这个方法里预先处理了一下 找出该bean的标注有@Autowited所有的field与method 并放入合适的数据结构保存 我们这里就不展开讲解了addSingletonFactory这个方法逻辑不难 却意义重大 到这个阶段的时候 就把这个bean提前暴露出来了 就能够解决我们前面所说的第二种依赖了populateBean(beanName, mbd, instanceWrapper)方法的作用就是bean属性的填充 我们说的IOC DI的体现就是在这里了 由spring框架给我们注入我们想要的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) &#123; PropertyValues pvs = mbd.getPropertyValues(); if (bw == null) &#123; if (!pvs.isEmpty()) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;); &#125; else &#123; // Skip property population phase for null instance. return; &#125; &#125; // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the // state of the bean before properties are set. This can be used, for example, // to support styles of field injection. boolean continueWithPropertyPopulation = true; //实例化后的后置处理器 spring框架的扩展点 if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123; continueWithPropertyPopulation = false; break; &#125; &#125; &#125; &#125; if (!continueWithPropertyPopulation) &#123; return; &#125; if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123; MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // xml文件中定义的非java基本类型依赖 在这里就注入了 byName if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123; autowireByName(beanName, mbd, bw, newPvs); &#125; // xml文件中定义的非java基本类型依赖 在这里就注入了 byType if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123; autowireByType(beanName, mbd, bw, newPvs); &#125; pvs = newPvs; &#125; boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE); // @Autowired注解实现注入就是在这里 if (hasInstAwareBpps || needsDepCheck) &#123; PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); if (hasInstAwareBpps) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvs == null) &#123; return; &#125; &#125; &#125; &#125; if (needsDepCheck) &#123; checkDependencies(beanName, mbd, filteredPds, pvs); &#125; &#125; // applyPropertyValues(beanName, mbd, bw, pvs); &#125; 这里涉及到的几个BPP我们后面会挑一个出来讲解 如@Autowired注解的实现过程 这里就不深入讨论了 属性填充完后就到了init的环节 initializeBean(beanName, exposedObject, mbd)123456789101112131415161718192021222324252627282930313233343536protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123; // 这个时间点是属性填充完了 但是还没有调用initMethod方法的阶段 if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; public Object run() &#123; invokeAwareMethods(beanName, bean); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; //如果有继承xxxAware的话 调用setXXX相应的方法 invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; //initMethod方法调用前 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; //调用initMethod 或者 afterPropertiesSet方法 invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, &quot;Invocation of init method failed&quot;, ex); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean;&#125; 这个方法相对来说比较简单 有几点说一下 读者可能用过xxxAware 然后继承setXXX方法就可以了 那么是怎么实现的呢 答案很简单 spring会判断是哪个aware 然后调用响应的set方法 即invokeAwareMethods的方法实现我们前面说过初始化方法执行前后是个特殊的时间节点 spring自然不会忘记在其执行前后添加一些扩展点 就是调用BPP的扩展方法对于初始化来说 spring提供了一个类似功能的接口供我们继承InitializingBean123public interface InitializingBean &#123; void afterPropertiesSet() throws Exception;&#125; 跟init-method要实现的功能差不多初始化完成后 bean的加载基本上就算完成了","tags":[{"name":"context","slug":"context","permalink":"http://yoursite.com/tags/context/"}]},{"title":"常用命令行命令详解","date":"2017-05-07T01:58:35.000Z","path":"2017/05/07/常用命令行命令详解/","text":"","tags":[]},{"title":"ClassPathXmlApplicationContext源码解析四","date":"2017-05-04T03:38:03.000Z","path":"2017/05/04/ClassPathXmlApplicationContext源码解析四/","text":"我们回到refresh()方法 继续往下解读 下面这几个方法比较简洁 或者说简单 我们只是简单的列出 就不再作过多解读饿了1234567891011// spring可扩展的另一个实现:BeanPostProcessor 在调用beanClass实例化前后或者调用initMethod方法的前后会调用接口方法// 较常见的硬编码的BPP:ApplicationContextAwareProcessor,ApplicationListenerDetectorregisterBeanPostProcessors(beanFactory);//国际化initMessageSource();//广播initApplicationEventMulticaster();//emptyonRefresh();// 注册listenerregisterListeners(); registerBeanPostProcessors(beanFactory)方法是把BeanFactory中声明的BeanPostProcessor的实例加入到beanFactory中 注意此时的BeanPostProcessor并没有成形 还停留在BeanDefinition初级阶段 这个时候我们要通过beanFactory.getBean(name,requiredType)方法获取BeanPostProcessor实例 然后再加入到beanFactory中 getBean(name,requiredtype)是个很复杂很重要的方法 后面我们会讲到 component-scan做了些什么:源码解读 文章最后介绍的一个方法registerComponents()有介绍到注册的一些处理注解的BPPinitApplicationEventMulticaster()方法用来注册一个广播器onRefresh()方法留空 留给字类继承实现registerListeners() 将相关listener加入到我们上面生成的applicationEventMulticaster中","tags":[{"name":"context","slug":"context","permalink":"http://yoursite.com/tags/context/"}]},{"title":"ClassPathXmlApplicationContext源码解析三:BFPP","date":"2017-04-29T01:31:38.000Z","path":"2017/04/29/ClassPathXmlApplicationContext源码解析三-BFPP/","text":"让我们再回到refresh()方法 继续往下看 看下面两个方法123456789...//如果是XmlWebApplicationContext的话 会注册一些BPP 例如ServletContextAwareProcessor// 这里留空 postProcessBeanFactory(beanFactory); // spring扩展的实现(容器级别) BeanFactoryPostProcessor 在实例化任何用户定义的bean之前 会首先调用BFPP的接口方法 // 常见的BFPP:PropertyPlaceholderConfigurer invokeBeanFactoryPostProcessors(beanFactory);... 12345//BFPP接口public interface BeanFactoryPostProcessor &#123; void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;&#125; invokeBeanFactoryPostProcessors方法逻辑就比较简单了 就是调用BFPP的接口方法 这些BFPP的来源途径有 硬编码方式 用户配置 容器自身为了完成某些功能添加这些BFPP支持排序 排序大的先调用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123; // Invoke BeanDefinitionRegistryPostProcessors first, if any. Set&lt;String&gt; processedBeans = new HashSet&lt;String&gt;(); if (beanFactory instanceof BeanDefinitionRegistry) &#123; BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory; //BFPP(postProcessBeanFactory) List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new LinkedList&lt;BeanFactoryPostProcessor&gt;(); //BeanDefinitionRegistryPostProcessor 是BFPP的子类 List&lt;BeanDefinitionRegistryPostProcessor&gt; registryPostProcessors = new LinkedList&lt;BeanDefinitionRegistryPostProcessor&gt;(); //硬编码方式加入的BFPP 例如通过addXXX for (BeanFactoryPostProcessor postProcessor : getBeanFactoryPostProcessors()) &#123; if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123; BeanDefinitionRegistryPostProcessor registryPostProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor; registryPostProcessor.postProcessBeanDefinitionRegistry(registry); registryPostProcessors.add(registryPostProcessor); &#125; else &#123; regularPostProcessors.add(postProcessor); &#125; &#125; //处理配置中的BDRPP Map&lt;String, BeanDefinitionRegistryPostProcessor&gt; beanMap = beanFactory.getBeansOfType(BeanDefinitionRegistryPostProcessor.class, true, false); List&lt;BeanDefinitionRegistryPostProcessor&gt; registryPostProcessorBeans = new ArrayList&lt;BeanDefinitionRegistryPostProcessor&gt;(beanMap.values()); OrderComparator.sort(registryPostProcessorBeans); for (BeanDefinitionRegistryPostProcessor postProcessor : registryPostProcessorBeans) &#123; postProcessor.postProcessBeanDefinitionRegistry(registry); &#125; invokeBeanFactoryPostProcessors(registryPostProcessors, beanFactory); invokeBeanFactoryPostProcessors(registryPostProcessorBeans, beanFactory); invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory); processedBeans.addAll(beanMap.keySet()); &#125; else &#123; // Invoke factory processors registered with the context instance. invokeBeanFactoryPostProcessors(getBeanFactoryPostProcessors(), beanFactory); &#125; // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false); // Separate between BeanFactoryPostProcessors that implement PriorityOrdered, // Ordered, and the rest. List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;BeanFactoryPostProcessor&gt;(); List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;String&gt;(); List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;String&gt;(); for (String ppName : postProcessorNames) &#123; if (processedBeans.contains(ppName)) &#123; // skip - already processed in first phase above &#125; else if (isTypeMatch(ppName, PriorityOrdered.class)) &#123; priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)); &#125; else if (isTypeMatch(ppName, Ordered.class)) &#123; orderedPostProcessorNames.add(ppName); &#125; else &#123; nonOrderedPostProcessorNames.add(ppName); &#125; &#125; // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered. OrderComparator.sort(priorityOrderedPostProcessors); invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory); // Next, invoke the BeanFactoryPostProcessors that implement Ordered. List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;BeanFactoryPostProcessor&gt;(); for (String postProcessorName : orderedPostProcessorNames) &#123; orderedPostProcessors.add(getBean(postProcessorName, BeanFactoryPostProcessor.class)); &#125; OrderComparator.sort(orderedPostProcessors); invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory); // Finally, invoke all other BeanFactoryPostProcessors. List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;BeanFactoryPostProcessor&gt;(); for (String postProcessorName : nonOrderedPostProcessorNames) &#123; nonOrderedPostProcessors.add(getBean(postProcessorName, BeanFactoryPostProcessor.class)); &#125; invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);&#125; 上面的代码逻辑很简单 就不再解释了 下面我们介绍一个常用的BFPP: PropertyPlaceholderConfigurer 先看一下常用的配置123456789&lt;bean name=&quot;official&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;100&quot; /&gt; &lt;property name=&quot;ignoreUnresolvablePlaceholders&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;locations&quot;&gt; &lt;list&gt; &lt;value&gt;file:$&#123;user.home&#125;/config/official.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; PropertyPlaceholderConfigurer是用来在BeanClass实例化之前调用的,通过载入指定properties文件,替换诸如${}这种形式的变量.PropertyPlaceholderConfigurer可以用来区分生产环境与开发环境 例如我们在生产环境部署official.properties文件 这个文件中的参数值 如jdbc.url 代表的是生产环境的value 然后我们在开发环境中部署developer.properties文件 这个文件中的参数值 如jdbc.url 代表的是开发环境的value 这样我们的项目发布在什么环境读取的就是相应环境的变量值 不需要每次改代码去解决PropertyPlaceholderConfigurer的功能实现我们大概能猜的到 首先肯定是先获取这个Bean 这个步骤会涉及到Bean的实例化 属性填充等操作 我们暂且略过这个步骤 后面会详细介绍 然后就是读取配置的properties文件 再然后就是替换Bean属性中的${xx}","tags":[{"name":"context","slug":"context","permalink":"http://yoursite.com/tags/context/"}]},{"title":"component-scan做了些什么:源码解读","date":"2017-04-28T09:35:35.000Z","path":"2017/04/28/component-scan做了些什么/","text":"本文目的本文主要解决一个问题就是component-scan会扫描注册哪些注解标注的类 被@Controller标注的类会被扫描注册吗? 当然本文也可以当作spring解析非默认空间下元素的一个教程 正文当遇到component-scan这样非标准或者称为自定义的元素标签时 spring会通过spring.handlers文件中的对应关系http\\://www.springframework.org/schema/context= org.springframework.context.config.ContextNamespaceHandler找到ContextNamespaceHandler 通过ContextNamespaceHandler类init()方法自动注册一些解析器 下面列出了所有以context为命名空间的组合 例如常见的&lt;context:componet-scan&gt;元素 根据注册对应关系 知道其对应的解析器为ComponentScanBeanDefinitionParser public void init() { registerBeanDefinitionParser(&quot;property-placeholder&quot;, new PropertyPlaceholderBeanDefinitionParser()); registerBeanDefinitionParser(&quot;property-override&quot;, new PropertyOverrideBeanDefinitionParser()); registerBeanDefinitionParser(&quot;annotation-config&quot;, new AnnotationConfigBeanDefinitionParser()); registerBeanDefinitionParser(&quot;component-scan&quot;, new ComponentScanBeanDefinitionParser()); registerBeanDefinitionParser(&quot;load-time-weaver&quot;, new LoadTimeWeaverBeanDefinitionParser()); registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser()); registerBeanDefinitionParser(&quot;mbean-export&quot;, new MBeanExportBeanDefinitionParser()); registerBeanDefinitionParser(&quot;mbean-server&quot;, new MBeanServerBeanDefinitionParser()); } 那我们看一下&lt;context:component-scan&gt;的解析器ComponentScanBeanDefinitionParser的源码 (ComponentScanBeanDefinitionParser继承自BeanDefinitionParser) spring解析&lt;context:component-scan&gt;的时候会调用ComponentScanBeanDefinitionParser的parse()函数 //element 代表的是完整的&lt;context:component-scan&gt;标签 //parserContext 解析的上下文环境 能拿到一些诸如readerContext registry等变量 public BeanDefinition parse(Element element, ParserContext parserContext) { //将指定base-package拆分成string数组的形式 String[] basePackages = StringUtils.tokenizeToStringArray(element.getAttribute(BASE_PACKAGE_ATTRIBUTE), ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); // 根据xml配置或者默认配置(如果没有指定的话)配置扫描器ClassPathBeanDefinitionScanner ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element); //scanner扫描包下面含有特殊注解标注的类 //@Component @Named @ManagedBean (@Controller @Service @Repository @Configuration)都会被注册 Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages); // 注册组件以及一些我们常见的注解处理器(BPP) 如@Resouce @Autowired @Configuration @Value @Required @PostConstruct //那么以后看到属性注入(IOC/DI)的时候 就不会奇怪 这些注解的处理器(BPP)是在哪里注册的了 在这里! registerComponents(parserContext.getReaderContext(), beanDefinitions, element); return null; } 看一下scanner的创建以及设置 protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) { XmlReaderContext readerContext = parserContext.getReaderContext(); boolean useDefaultFilters = true; if (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) { useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)); } // 生成scanner的时候 在其父类构造函数中调用了`registerDefaultFilters()`方法中加入了3个注解类型的typeFilter 分别是@Component // @ManagedBean @Named 意思也就是看类上面有没有这三个注解或者注解的元注解中是否含有这三个注解之一 // 这里虽然没有加入如@Service的注解 但看@Service的定义会发现@Service注解也被@Component给标注了 ClassPathBeanDefinitionScanner scanner = createScanner(readerContext, useDefaultFilters); scanner.setResourceLoader(readerContext.getResourceLoader()); scanner.setEnvironment(parserContext.getDelegate().getEnvironment()); // 利用spring 启动的时候根据xml文件或者默认配置(如果没有指定的话)生成的BeanDefinition规则 scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults()); scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns()); if (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) { scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE)); } try { // 扫描注解定义的bean 需要定义一种beanName的生成规则 一般是驼峰命名法 parseBeanNameGenerator(element, scanner); } catch (Exception ex) { readerContext.error(ex.getMessage(), readerContext.extractSource(element), ex.getCause()); } try { // bean的scope singleton?prototype? parseScope(element, scanner); } catch (Exception ex) { readerContext.error(ex.getMessage(), readerContext.extractSource(element), ex.getCause()); } // 根据xml配置生成includeFilter excludeFilter 在创建scanner类的时候 就硬编码进去了3个注解类型 // 的typeFilter到includeFilter里面 // 类必须满足以下条件才会被注册 因为@Component等是被硬编码进去的 所以只有下面一种情况才会被注册了 // 不被excludeFilter匹配 并且被includeFilter匹配 parseTypeFilters(element, scanner, readerContext, parserContext); return scanner; } 下面在看一下真正的扫描过程doScan 我们发现spirng中真正干活的一般都是以do开头 前面的那么多只是为了做铺垫 单一职责 protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) { Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;); Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(); for (String basePackage : basePackages) { //寻找被@Component或者@Named注解标注的类 或者 类的注解的元注解中含有这两个注解 例如常见的@Respsitory @Controller @Service Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); // 对于生成的AnnotatedBeanDefinition做一些转化工作 例如前面说到的应用bd(BeanDefinition)默认配置 // 处理@Primary @Lazy @DependsOn @Role注解等 // 转化成BeanDefinitionHolder对象 for (BeanDefinition candidate : candidates) { ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) { postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); } if (candidate instanceof AnnotatedBeanDefinition) { AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); } if (checkCandidate(beanName, candidate)) { BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); //注册到容器中 registerBeanDefinition(definitionHolder, this.registry); } } } return beanDefinitions; } 看一下findCandidateComponents方法 public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) { Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;BeanDefinition&gt;(); try { String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + &quot;/&quot; + this.resourcePattern; //这里的resouces代表的就是路径下的各个类了 Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath); boolean traceEnabled = logger.isTraceEnabled(); boolean debugEnabled = logger.isDebugEnabled(); for (Resource resource : resources) { if (traceEnabled) { logger.trace(&quot;Scanning &quot; + resource); } if (resource.isReadable()) { try { // 这一步的作用就是能够不必加载class但能拿到class各种属性 并且这里也不能载入class(有很多是单例模式) 还没到那一步 // 只是为了做匹配 生成bd而已 MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); // 根据includeFilters excludeFilters做匹配 因为篇幅的限制 不详谈 有兴趣的可以研究一下typeFilter的实现 if (isCandidateComponent(metadataReader)) { ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); if (isCandidateComponent(sbd)) { if (debugEnabled) { logger.debug(&quot;Identified candidate component class: &quot; + resource); } candidates.add(sbd); } else { if (debugEnabled) { logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource); } } } else { if (traceEnabled) { logger.trace(&quot;Ignored because not matching any filter: &quot; + resource); } } } catch (Throwable ex) { throw new BeanDefinitionStoreException( &quot;Failed to read candidate component class: &quot; + resource, ex); } } else { if (traceEnabled) { logger.trace(&quot;Ignored because not readable: &quot; + resource); } } } } catch (IOException ex) { throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, ex); } return candidates; } 到这里 我们算是差不多看完了scanner的扫描注册过程 扫描注册过程不过循环base-package路径下面的所有类 看是否有标注特定注解(硬编码)的类 将这些类转化成bd 供我们后续使用 这里要注意的就是这里不能将类实例化我们再回到ComponentScanBeanDefinitionParser的parse()方法 看下registerComponents()方法registerComponents()方法中除了组件外 还有一个比较重要的事情 就是注册我们后面属性填充(IOC)需要用到的一些BPP 例如@Resouce @Autowired等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 protected void registerComponents( XmlReaderContext readerContext, Set&lt;BeanDefinitionHolder&gt; beanDefinitions, Element element) &#123; Object source = readerContext.extractSource(element); CompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), source); for (BeanDefinitionHolder beanDefHolder : beanDefinitions) &#123; compositeDef.addNestedComponent(new BeanComponentDefinition(beanDefHolder)); &#125; // Register annotation config processors, if necessary. // 默认注册 boolean annotationConfig = true; if (element.hasAttribute(ANNOTATION_CONFIG_ATTRIBUTE)) &#123; annotationConfig = Boolean.valueOf(element.getAttribute(ANNOTATION_CONFIG_ATTRIBUTE)); &#125; if (annotationConfig) &#123; //这里注册我们需要的BPP Set&lt;BeanDefinitionHolder&gt; processorDefinitions = AnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source); for (BeanDefinitionHolder processorDefinition : processorDefinitions) &#123; compositeDef.addNestedComponent(new BeanComponentDefinition(processorDefinition)); &#125; &#125; readerContext.fireComponentRegistered(compositeDef); &#125; public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors( BeanDefinitionRegistry registry, Object source) &#123; Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(4); // @Configuration if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; //@Autowired @Value if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; //@Required if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; //@PostConsruct @Resouce 等java注解 // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor. if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; // // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor. if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(); try &#123; def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, AnnotationConfigUtils.class.getClassLoader())); &#125; catch (ClassNotFoundException ex) &#123; throw new IllegalStateException( &quot;Cannot load optional framework class: &quot; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex); &#125; def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; return beanDefs; &#125; 总的来说 component-scan 做了什么事情就比较清晰了 下面做一下总结 根据配置生成扫描类ClassPathBeanDefinitionScanner 扫描注册包下符合匹配规则的类 扫描注册被@Controller @Service @Respsitory @Component @Configuration等标注的类 因为@Controller @Service @Respsitory注解的元注解包含@Component 也就是说@Controller @Service @Respsitory本身被@Component标注 而匹配规则中有一条就是元注解包含@Component @Named 或者 @ManagedBean 注册处理如@Resouce @Autowired @PostConstruct等的BPP 当然由于篇幅限制 并没有把所有的知识点都讲到 很多也是点到 那些东西需要读者有时间的时候自己跟着代码走一遍了那么又出现一个问题：既然@Controller注解标注的类也被像普通bean一样注册了 那么在web项目中 又是怎么知道哪些是我们需要的Controller类呢?且听下回分析…","tags":[{"name":"component-scan","slug":"component-scan","permalink":"http://yoursite.com/tags/component-scan/"}]},{"title":"ClassPathXmlApplicationContext源码解析二:默认空间元素解析","date":"2017-04-21T12:15:44.000Z","path":"2017/04/21/ClassPathXmlApplicationContext源码解析二-默认空间元素解析/","text":"写在前面在 ClassPathXmlApplicationContext源码解析一 中 我们用了很长的篇幅 介绍了加载上下文环境前的各种准备工作 spring是个世界级的项目框架 由精英团队打造 全世界的测试人员测试 即使如果读者感觉有点吃力 对突然冒出来的代码有点不习惯的话 也不要气馁 继续往下读 刚阅读源代码的时候 最怕纠结于一些琐碎单却不重要的事情 下面我们看一下parseBeanDefinitions(root, this.delegate)方法12345678910111213141516171819202122232425262728//对于`delegate` 我们暂时只要知道这个类中含有我们需要的一些environment,beanfactory等信息就可以了 当然他还提供一些解析方法 protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; /** * 如果是默认命名空间 也就是&quot;http://www.springframework.org/schema/beans&quot;这个空间下的元素 调用parseDefaultElement * 否则调用parseCustomElement 例如aop context tx等标签的解析 * 也就是parseDefaultElement 解析import alias bean beans标签元素 * parseCustomElement 解析aop context tx 或者是用户自定义命名空间的元素 */ if (delegate.isDefaultNamespace(root)) &#123; NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) &#123; //继续这个方法研究 parseDefaultElement(ele, delegate); &#125; else &#123; delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; delegate.parseCustomElement(root); &#125; &#125; 我们这篇文章只看默认命名空间的解析 也就是http://www.springframework.org/schema/beans这个空间下的定义的元素定义 对于非默认空间下的元素的解析的话 请看component-scan做了些什么 这篇文章讲解了component空间下的元素解析1234567891011121314151617181920private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123; //解析import元素标签 通过调用`loadBeanDefinitions`模块方法完成元素加载&lt;import resource=&quot;url&quot;/&gt; if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; importBeanDefinitionResource(ele); &#125; //解析alias元素标签 &lt;alias name=&quot;&quot; alias=&quot;&quot; /&gt; else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; //注册别名 说白点就是把name alias的对应关系加入到一个map中 processAliasRegistration(ele); &#125; //解析bean元素标签 最核心 &lt;bean &gt; else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; processBeanDefinition(ele, delegate); &#125; //解析beans元素标签 又调用了`doRegisterBeanDefinitions(element)`方法去解析&lt;beans&gt; else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; // recurse doRegisterBeanDefinitions(ele); &#125;&#125; 到达这个方法的时候 ele代表的就是一个bean标签元素了 例如1&lt;bean id=&quot;&quot; class=&quot;&quot;&gt; 我们不必深入了解xml文档的解析 也是能看的懂的 当然如果了解解析的过程 是更好的了我们可以很清晰的看到beans空间下的元素标签有import alias bean beans 我们当然是重点讲解bean标签的解析了 继续跟踪代码123456789101112131415161718protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;//继续跟踪 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) &#123; //处理非默认命名空间的元素 如果有的话 这里不继续跟踪下去了 bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; // 也就是放到一个map中去 key为beanName value为BeanDefinition BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error(&quot;Failed to register bean definition with name &apos;&quot; + bdHolder.getBeanName() + &quot;&apos;&quot;, ele, ex); &#125; // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125;&#125; 跟踪进BeanDefinitionParserDelegate.parseBeanDefinitionElement方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123; String id = ele.getAttribute(ID_ATTRIBUTE); String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); //bean标签中的name其实会被划分成alias List&lt;String&gt; aliases = new ArrayList&lt;String&gt;(); if (StringUtils.hasLength(nameAttr)) &#123; String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); &#125; String beanName = id; if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123; beanName = aliases.remove(0); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;No XML &apos;id&apos; specified - using &apos;&quot; + beanName + &quot;&apos; as bean name and &quot; + aliases + &quot; as aliases&quot;); &#125; &#125; if (containingBean == null) &#123; //beanName唯一性校验 checkNameUniqueness(beanName, aliases, ele); &#125; AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);//GenericBeanDefinition if (beanDefinition != null) &#123; // 阅读源代码要做到有的放矢 像下面这样的代码就没有太大的必要去看了 if (!StringUtils.hasText(beanName)) &#123; try &#123; if (containingBean != null) &#123; beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); &#125; else &#123; beanName = this.readerContext.generateBeanName(beanDefinition); String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123; aliases.add(beanClassName); &#125; &#125; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Neither XML &apos;id&apos; nor &apos;name&apos; specified - &quot; + &quot;using generated bean name [&quot; + beanName + &quot;]&quot;); &#125; &#125; catch (Exception ex) &#123; error(ex.getMessage(), ele); return null; &#125; &#125; //返回BeanDefinitionHolder String[] aliasesArray = StringUtils.toStringArray(aliases); return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); &#125; return null;&#125; id 就是beanName了 必须要唯一才行 其实parseBeanDefinitionElement这个方法的目的就很明确了 就是要把bean的配置读取并保存起来 保存到GenericBeanDefinition中 例如我们常见的property constructor-arg等 无非就是构造合适的结构 然后读取数据并保存起来 供以后使用 虽然目的明确 但过程确实是很繁琐的 因为spring支持多种复杂数据结构 例如list map等我们就不再深入解读了 读者可以自己找几个解析方法阅读1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 在这个方法中会遇到我们之前可能没有遇到的标签/属性元素 最好的解决办法就是先搜索这个元素/属性的用法,然后再看解析, 再看他们的应用处理等 * 我们这里不对这些不常用的元素/属性进行详解 这里主要就是解析出来并保存到BeanDefinitiion中 */public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, BeanDefinition containingBean) &#123; this.parseState.push(new BeanEntry(beanName)); String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123; className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); &#125; try &#123; String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123; parent = ele.getAttribute(PARENT_ATTRIBUTE); &#125; //GenericBeanDefinition 设置className parentName变量 parent属性目前只是作为一个普通属性放倒BeanDefinition中去了 后面加载单例的时候会用到 AbstractBeanDefinition bd = createBeanDefinition(className, parent);// //解析元素属性 例如scope lazy-init factory-method等属性的解析 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); //解析元素子元素开始 bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); //&lt;meta key=&quot;&quot; value=&quot;&quot; /&gt; 作为对bd的额外参数使用 parseMetaElements(ele, bd); //&lt;lookup-method name=&quot;&quot; bean=&quot;&quot; /&gt; 插拔式设计 方法根据配置 动态返回不同的bean 感兴趣的可以自行搜索相关使用demo parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); //&lt;replaced-method name=&quot;&quot; replacer=&quot;&quot;/&gt; 根据配置 替换/更改原来的方法逻辑 interesting 感兴趣的可以自行搜索相关使用demo parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); //todo &lt;constructor-arg index=&quot;i&quot;&gt;&lt;/constructor-arg&gt; parseConstructorArgElements(ele, bd); //&lt;property name=&quot;&quot; value=&quot;&quot;/&gt; or more complex property such as list,map 阅读源代码 我们要有的放矢 // 没必要把每一行都看懂 就像下面的解析构造参数 与 property一样 都是很复杂的 但我们没必要都读懂才行 parsePropertyElements(ele, bd); //&lt;qualifier /&gt; parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; &#125; catch (ClassNotFoundException ex) &#123; error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex); &#125; catch (NoClassDefFoundError err) &#123; error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err); &#125; catch (Throwable ex) &#123; error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex); &#125; finally &#123; this.parseState.pop(); &#125; return null;&#125; 生成beanDefinition后 再用BeanDefinitionHolder封装后返回注册 至此xml配置文件中的设置就转化为了java对象保存我们在回到refresh()方法 继续往下看prepareBeanFactory()方法123456789101112131415161718192021222324252627282930313233343536373839404142434445protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; // Tell the internal bean factory to use the context&apos;s class loader etc. beanFactory.setBeanClassLoader(getClassLoader()); // beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver()); // 我们知道xml文档中的都是字符串形式的值 但我们可能需要的是其他的类型 比如Float Date等 // 这里注册一些常用的属性编辑器 去解决类型转化问题 beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); //BPP 作用是如果bean实现了Aware接口的话 自动调用`setXXX`方法 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); //忽略特殊类`ResourceLoaderAware` 等的依赖 beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); beanFactory.ignoreDependencyInterface(EnvironmentAware.class); // BeanFactory interface not registered as resolvable type in a plain factory. // MessageSource registered (and found for autowiring) as a bean. beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // Detect a LoadTimeWeaver and prepare for weaving, if found. // @AspectJ相关 不常用 后面会专门讲解Spring AOP if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123; beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // Set a temporary ClassLoader for type matching. beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); &#125; // Register default environment beans. if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123; beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); &#125; if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123; beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); &#125; if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123; beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); &#125;&#125; 代码里面的注释应该是很详细了 我们来分析一个很有趣的事情如果我们想在我们自己类中 获取如ApplicationContext的话 我们一般会继承ApplicationContextAware 然后有个回调方法会让我们实现 例如setApplicationContext 那么为什么我们只要实现了这个接口 我们实现的回调方法就会调用呢 奥秘就在这句代码beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this))BPP(BeanFactoryPostProcessor)是个很重要的知识点 我们这里大概了解一下 不管是单例模式还是原型模式 我们定义的class肯定是要实例化的 如果有定义初始化方法的话 还会调用初始化方法 对于一个类来说 实例化 初始化都是很重要的时间节点 我们的class又是托管给spring进行管理的 那么spring就有能力 有机会在这些时间节点前后添加一些处理方法 spring中代表这一类操作的接口是BeanPostProcessor 简称BPP 中文翻译是后置处理器 当然spring中还有一种PostProcessor是容器级别的 BeanFactoryPostProcessor 就是在容器加载前后做一些特殊的操作 在ApplicationContextAwareProcessor.postProcessBeforeInitialization(final Object bean, String beanName)方法中 会调用invokeAwareInterfaces(bean)方法1234567891011121314151617181920212223private void invokeAwareInterfaces(Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof EnvironmentAware) &#123; ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment()); &#125; if (bean instanceof EmbeddedValueResolverAware) &#123; ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver( new EmbeddedValueResolver(this.applicationContext.getBeanFactory())); &#125; if (bean instanceof ResourceLoaderAware) &#123; ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext); &#125; if (bean instanceof ApplicationEventPublisherAware) &#123; ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext); &#125; if (bean instanceof MessageSourceAware) &#123; ((MessageSourceAware) bean).setMessageSource(this.applicationContext); &#125; if (bean instanceof ApplicationContextAware) &#123; ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext); &#125; &#125;&#125; 看起来很神秘的东西 它的实现是不是很一般 而且还感觉有点low 竟然没有魔法","tags":[{"name":"context","slug":"context","permalink":"http://yoursite.com/tags/context/"}]},{"title":"ClassPathXmlApplicationContext源码解析一:准备工作","date":"2017-04-17T10:00:36.000Z","path":"2017/04/17/ClassPathXmlApplicationContext源码解析一/","text":"其实在web环境中 用到的上下文环境是 XmlWebApplicationContext 但其实对于我们要讲解的内容来说 核心逻辑是一样的 在后面讲解到web环境加载的时候 会讲到XmlWebApplicationContext类的解析 下面几篇博客的内容我们会介绍Spring是怎么构建上下文环境的 也就是ClassPathXmlApplicationContext的源码的过程ClassPathXmlApplicationContext类的测试类是ClassPathXmlApplicationContextTests 如果读者能好好利用这个测试类的话 能节省不少阅读源码的时间构造函数123456789 //接收配置文件的地址 默认刷新 父容器为null 讲解web环境加载的时候 会讲到父容器的概念public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException &#123; super(parent); setConfigLocations(configLocations); if (refresh) &#123; refresh(); &#125;&#125; 以后讲解web环境加载的时候我们会讲到父子容器的概念 这里只考虑父容器为null的情况 如果路径中含有如${user.dir}的变量 会被处理替换掉 对替换这部分感兴趣的读者可以深入阅读 然后就进入最重要的一个方法refresh()refresh()refresh()方法从总体上看 还算比较清晰 用几个大的方法高度概括了refresh()要完成的工作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. // 加载前的准备工作:active标记为true；资源必要性验证等 prepareRefresh(); // 创建DefaultListableBeanFactory 并加载配置文件 转化为BeanDefinition保存 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); prepareBeanFactory(beanFactory); try &#123; //empty postProcessBeanFactory(beanFactory); // spring扩展的实现(容器级别) BeanFactoryPostProcessor 在实例化任何用户定义的bean之前 会首先调用BFPP的接口方法 // 常见的BFPP:PropertyPlaceholderConfigurer invokeBeanFactoryPostProcessors(beanFactory); // spring可扩展的另一个实现:BeanPostProcessor 在调用bean的init-method方法的前后会调用接口方法 // 较常见的硬编码的BPP:ApplicationContextAwareProcessor,ApplicationListenerDetector registerBeanPostProcessors(beanFactory); //国际化 initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. //empty onRefresh(); // Check for listener beans and register them. // 注册listener registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. // 实例化所有的非懒惰加载的单例 finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt&quot;, ex); // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset &apos;active&apos; flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; &#125;&#125; 下面我们看obtainFreshBeanFactory()#AbstractRefreshableApplicationContext.refreshBeanFactory()方法(obtainFreshBeanFactory()方法中主要逻辑是在refreshBeanFactory()方法 我们就不再列出完整的obtainFreshBeanFactory()方法 以后这样的格式我们用#区分)再此感叹spring代码的优秀 每个方法都是那么的简短清晰 一层一层的深入12345678910111213141516171819202122protected final void refreshBeanFactory() throws BeansException &#123;// 如果已经加载过的话 先销毁再重新加载 if (hasBeanFactory()) &#123; destroyBeans(); closeBeanFactory(); &#125; try &#123; //实例化一个DefaultListableBeanFactory 这是一个很重要的类 DefaultListableBeanFactory beanFactory = createBeanFactory(); //设置id beanFactory.setSerializationId(getId()); customizeBeanFactory(beanFactory); loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) &#123; this.beanFactory = beanFactory; &#125; &#125; catch (IOException ex) &#123; throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex); &#125;&#125; 12345678910/** * 忽略BeanNameAware BeanFactoryAware BeanClassLoaderAware的依赖 spring有设置专门调用setXXX方法的地方 * Create a new AbstractAutowireCapableBeanFactory. */ public AbstractAutowireCapableBeanFactory() &#123; super(); ignoreDependencyInterface(BeanNameAware.class); ignoreDependencyInterface(BeanFactoryAware.class); ignoreDependencyInterface(BeanClassLoaderAware.class); &#125; 对于这样的代码 如果不跟踪进去的话 可能会对有些变量的值感到困惑createBeanFactory()实例化了一个DefaultListableBeanFactory 在实例化的过程中 其父类 AbstractAutowireCapableBeanFactory的构造函数注册了几个忽略依赖注入的接口 就是说以后对于bean的属性注入的时候 如果在我们注册的忽略接口里面的话 就不再依赖注入12345678910111213// protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123; //是否允许覆盖 if (this.allowBeanDefinitionOverriding != null) &#123; beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; //是否允许循环引用 循环引用是很重要的一个知识点 我们后面会专门讲解 if (this.allowCircularReferences != null) &#123; beanFactory.setAllowCircularReferences(this.allowCircularReferences); &#125; //设置Qualifier注解解析类 beanFactory.setAutowireCandidateResolver(new QualifierAnnotationAutowireCandidateResolver()); &#125; 我们看下beanFactory.setAutowireCandidateResolver(new QualifierAnnotationAutowireCandidateResolver())方法 这个方法就是设置autowireCandidateResolver变量 顺便做了一件事情 就是如果该变量继承了BeanFactoryAware的话 调用setBeanFactory()方法 我们从这里就可以看到sping代码优秀的另一个方面是约定习俗1234567891011121314151617181920public void setAutowireCandidateResolver(final AutowireCandidateResolver autowireCandidateResolver) &#123; Assert.notNull(autowireCandidateResolver, &quot;AutowireCandidateResolver must not be null&quot;); if (autowireCandidateResolver instanceof BeanFactoryAware) &#123; if (System.getSecurityManager() != null) &#123; final BeanFactory target = this; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; public Object run() &#123; ((BeanFactoryAware) autowireCandidateResolver).setBeanFactory(target); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; // 调用`setBeanFactory()`方法 this作为参数 ((BeanFactoryAware) autowireCandidateResolver).setBeanFactory(this); &#125; &#125; //设置变量 this.autowireCandidateResolver = autowireCandidateResolver;&#125; 下面就进入很重要的一个方法了AbstractXmlApplicationContext#loadBeanDefinitions(beanFactory); 载入配置文件 就是根据配置文件做相应的处理 例如将&lt;bean&gt;转化为BeanDefinition保存 这跟Tomcat将server.xml转化为StandardServer是一样的 阅读这部分代码并不需要你很了解是怎么解析xml文档的 因为方法包装的很好的 当然如果读者比较了解xml文档解析的话 那么就更好了 123456789101112131415protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123; // Create a new XmlBeanDefinitionReader for the given BeanFactory. XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context&apos;s // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // Allow a subclass to provide custom initialization of the reader, // then proceed with actually loading the bean definitions. initBeanDefinitionReader(beanDefinitionReader); loadBeanDefinitions(beanDefinitionReader);&#125; tips 前面几行代码一直在做准备工作 刚阅读源码的读者一定会被这错综复杂的关系所困扰 spring中模块众多,继承 组合关系也是错综复杂 第一次阅读的话 读者可不必太在意这些类之间的委托关系 跟着代码走就可以了 以后阅读第二遍第三遍的时候 再好好研究 比如到现在为止我们都是顺着代码走 并没有从代码设计的角度去讲解loadBeanDefinitions()方法最终会调用AbstractBeanDefinitionReader#loadBeanDefinitions()方法123456789101112131415161718192021222324252627282930313233343536373839404142public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException &#123;//ClassPathXmlApplicationContext ResourceLoader resourceLoader = getResourceLoader(); if (resourceLoader == null) &#123; throw new BeanDefinitionStoreException( &quot;Cannot import bean definitions from location [&quot; + location + &quot;]: no ResourceLoader available&quot;); &#125; if (resourceLoader instanceof ResourcePatternResolver) &#123; // Resource pattern matching available. try &#123; // 把String类型的地址封装成Resource类型 方便后续操作 Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location); int loadCount = loadBeanDefinitions(resources); if (actualResources != null) &#123; for (Resource resource : resources) &#123; actualResources.add(resource); &#125; &#125; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location pattern [&quot; + location + &quot;]&quot;); &#125; return loadCount; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( &quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex); &#125; &#125; else &#123; // Can only load single resources by absolute URL. Resource resource = resourceLoader.getResource(location); int loadCount = loadBeanDefinitions(resource); if (actualResources != null) &#123; actualResources.add(resource); &#125; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location [&quot; + location + &quot;]&quot;); &#125; return loadCount; &#125;&#125; 方法调用AbstractBeanDefinitionReader#loadBeanDefinitions(resource)#loadBeanDefinitions(encodedResource) 我们发现方法调来调去的 却一直没有看到我们想看的内容 一直做的都是准备工作 不急 慢慢来 我们继续往下看12345678910111213141516171819202122232425262728293031323334353637383940public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;); if (logger.isInfoEnabled()) &#123; logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource()); &#125; Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) &#123; currentResources = new HashSet&lt;EncodedResource&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); &#125; if (!currentResources.add(encodedResource)) &#123; throw new BeanDefinitionStoreException( &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;); &#125; try &#123; InputStream inputStream = encodedResource.getResource().getInputStream(); try &#123; InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding()); &#125; // return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); &#125; finally &#123; inputStream.close(); &#125; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex); &#125; finally &#123; currentResources.remove(encodedResource); if (currentResources.isEmpty()) &#123; this.resourcesCurrentlyBeingLoaded.remove(); &#125; &#125;&#125; 也是做各种准备工作 终于让我们遇到了我们想要看的代码doLoadBeanDefinitions 代码读到后面 读者就会注意到spring中以do开头的方法才是真正的核心逻辑的开始123456789101112protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException &#123; try &#123; //获取验证模式 dtd or xsd int validationMode = getValidationModeForResource(resource); //为SAX应用程序提供寻找本地验证文件(dtd/xsd文件) 并将配置文件加载为document保存 Document doc = this.documentLoader.loadDocument( inputSource, getEntityResolver(), this.errorHandler, validationMode, isNamespaceAware()); return registerBeanDefinitions(doc, resource); &#125; ......&#125; 当然还是山路十八弯123456789public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;//DefaultBeanDefinitionDocumentReader BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); documentReader.setEnvironment(getEnvironment()); int countBefore = getRegistry().getBeanDefinitionCount(); // documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125; 1234567public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; this.readerContext = readerContext; logger.debug(&quot;Loading bean definitions&quot;); Element root = doc.getDocumentElement(); //解析的核心部分开始 doRegisterBeanDefinitions(root);&#125; 12345678910111213141516171819protected void doRegisterBeanDefinitions(Element root) &#123; String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);//profile attribute if (StringUtils.hasText(profileSpec)) &#123; String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; return; &#125; &#125; BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(this.readerContext, root, parent); preProcessXml(root); parseBeanDefinitions(root, this.delegate); postProcessXml(root); this.delegate = parent;&#125; 在方法createDelegate(this.readerContext, root, parent);中 通过populateDefaults()方法设置了一些例如default-lazy-init default-autowire的值 如果根元素中有设置这些变量的话 将会覆盖默认值 起到全局变量的作用preProcessXml(root) postProcessXml(root)都被留空 留给子类实现终于 finally 最终 我们看到了我们一直想看到的代码的影子 parseBeanDefinitions(root, this.delegate)要知后事如何 且听下回分解","tags":[{"name":"context","slug":"context","permalink":"http://yoursite.com/tags/context/"}]},{"title":"Tomcat源码分析环境搭建","date":"2017-04-16T07:18:00.000Z","path":"2017/04/16/Tomcat源码分析环境搭建/","text":"阅读源码的第一步就是把环境搭建起来 并能够调试 这样在某些情况下 能帮助你更好的阅读源代码 看起来比较直观 在这一点上 我将再次推荐idea这款集成开发环境 简直是神器 安利网上也有比较多的教程教你怎么把tomcat源代码导入到idea中的教程 我就不再浪费时间在重复写了 我当初也是按着那样的步骤来的 相信读者这些应该是自己能够搞定的我就直接把我搭建好的push到了我的github上面 上面有两个分枝 一个是master分支 这个分支是纯净版的 也就是没有我的注释的版本 另外一个分支是tomcat-with-docs 这个分支是我后来阅读源码的过程中写的注释 以后我会出一系列tomcat源码解析的教程所以 如果你想看纯净版的1$ git clone git@github.com:sunmingshuai/apache-tomcat-7.0.73-src.git 或者你想看有注释的1$ git clone -b tomcat-with-docs git@github.com:sunmingshuai/apache-tomcat-7.0.73-src.git 然后当成maven项目导入到idea中就可以了","tags":[]},{"title":"搭建spring web项目供debug使用","date":"2017-04-16T06:58:58.000Z","path":"2017/04/16/搭建spring-web项目供debug使用/","text":"随着阅读源码的深入 越来越了解debug的重要性 要让代码跑起来 想想自己也是阅读了Spring的核心功能模块 搭建起来应该不费劲 顺便说说感受想想刚毕业那会 进到公司 上手的都是已经搭建好的体系 这个阶段属于依胡萝画瓢阶段后来自己上网搜索搭建教程 虽然也能搭建好 但还是不了解其意 仍然是依胡萝画瓢阶段现在刚好有要搭建spring web项目 供我debug的需求 所以就花点时间搭建了一个 总的来说 比较顺畅 而且基本上每个配置都知道它到底干了什么 给我的感觉不一样了我debug总的来说有2个方面 打包放到tomcat的webapps目录 研究tomcat的源码 启动web项目 研究spring源码 具体的搭建过程我就不说了 我搭建的比较简洁 完全为了debug搭建的 没有多余代码 push到了github仓库 感兴趣的可以clone到本地使用 1$ git clone git@github.com:sunmingshuai/springmvcdemo.git 当成maven项目导入到idea/eclipse就可以了以后有需求的话 会不断的加入一些功能并推送","tags":[]},{"title":"2017阅读书单(持续更新)","date":"2017-04-16T05:46:48.000Z","path":"2017/04/16/2017阅读书单/","text":"技术书单 How Tomcat Works Spring源码深度解析 ActiveMQ in Action 成长 巨婴国 丘吉尔:我的早年生活 梦幻花 如何阅读一本书 黄金时代 月亮与六便士 枪炮 病菌与钢铁 这本书能让你戒烟(一本伟大的书令人信服的书)","tags":[]},{"title":"Spring源码分析环境搭建","date":"2017-04-15T13:28:22.000Z","path":"2017/04/15/Spring源码环境搭建/","text":"想研究spring源码的第一步当然是源码的搭建 推荐大家使用idea集成开发环境 下面的搭建过程也以idea为基础需要gradle git环境 不再叙述从github仓库中clone一份代码到本地git clone -b 3.2.x git@github.com:spring-projects/spring-framework.git这里需要注意的是你所使用的jdk版本与spring源码所需要的版本的匹配问题 如果你使用的jdk版本是1.7 而clone的是4以上的spring源码的话 那么comiple的时候就会报错查看源码目录下的 import-into-idea.md 文件 发现步骤可真简单 到spring源码的目录下cd your_spring_dir 执行命令 ./gradlew :spring-oxm:compileTestJava cleanIdea idea 这个过程可能比较慢 感觉卡住的话 ctrl+c 结束执行再重新执行命令 多试几次就好了 导入idea","tags":[]},{"title":"当我谈源码时,我谈些什么","date":"2017-04-15T07:06:19.000Z","path":"2017/04/15/当我谈源码时-我谈些什么/","text":"我们为什么要阅读源码 | 阅读源码给我们带来了什么 简单方面来说，阅读源码使我们更了解所使用的框架，深入其实现原理 更深入方面，我觉得阅读源码是一次提升的机会，提升自己抽象能力，学习大师们解决问题的思路. 阅读源码常见误区 每行代码都要搞懂是什么意思对于一个开源框架 以Tomcat 或者 Spring源码来说 每行代码都要理解的话 一方面会需要大量的时间 另一方面可能会被琐碎但又不那么重要的代码逻辑缠住 可谓是：捡了芝麻 丢了西瓜 要做到: 有的放矢 阅读源码的方法不对阅读源码并不是说把源码导入到集成开发环境中 就不管三七二十一的看起来 要找到切入点 借助开发工具提供的能力 多看看类的层次结构 多思考 学习大牛的抽象能力与分解|解决问题的能力 这两个能力在Tomcat，Spring源码中会达到让你惊叹的地步","tags":[]},{"title":"Unknown system variable 'storage_engine'解决办法","date":"2017-04-14T03:02:18.000Z","path":"2017/04/14/Unknown-system-variable-storage-engine-解决办法/","text":"安装MySQL employees数据库，出现问题，mysql版本为：mysql Ver 14.14 Distrib 5.7.10, for Linux (x86_64) using EditLine wrapper mysql默认的数据库存储引擎是innodb,正好出错的也是这行，提示没有storage_engine变量。好像14以后的msql storage_engine变量更名为default_storage_engine，可是我更改为set default_storage_engine = innodb,还是这行出错，没办法，只能注释掉这样了，反正默认就是innodb引擎。下面说注意事项： 在employees.sql文件中，注释掉(也就是让这行不生效)的时候除了在这行的最前面加’–’外，’–’要跟后面的字符空一个格才生效。即 12345678-- set default_storage_engine = InnoDB -- set storage_engine = InnoDB; -- set storage_engine = MyISAM; -- set storage_engine = Falcon; -- set storage_engine = PBXT; -- set storage_engine = Maria; -- select CONCAT(&apos;storage engine: &apos;, @@storage_engine) as INFO; 不要忘了把INFO那行注释掉，其实这行只是安装的时候提示你安装到哪里了，如果出错的话，好排查。像上面那样注释掉后，再安装就可以了.","tags":[]},{"title":"mac安装sequelpro","date":"2017-04-14T02:55:49.000Z","path":"2017/04/14/mac安装sequelpro/","text":"mac安装sequelpro遇到的问题： 不像其他dmg镜像一样 打开后有一个拖到应用程序的界面 下载sequelpro后 只能以挂载镜像的方式打开 这样的话 倒是可以用 但一直有一个挂载镜像在哪 不舒服 找来找去还是靠一句英文搞定的: how to install sequelpro on mac 然后让我找到了下面一个地址 http://macappstore.org/sequel-pro/照着上面的提示总算安装好了 不过过程中还是遇到了一些问题，安装brew的时候出现了问题 建议去homebrew官网去 官网有安装命令 照着那个安装 可能会因为网络因素什么的 会安装失败 多试几次就好了 终于安装成功 国人的博客啊 很多还是抄来抄去的 不着调 看来跟学生时代 作业抄多了有关系 学习英文 没坏处","tags":[]},{"title":"nginx反向代理解决mac上tomcat80端口问题","date":"2017-04-14T02:47:14.000Z","path":"2017/04/14/nginx反向代理解决mac上tomcat80端口问题/","text":"后来发现一个比较容易的解决方案 灵光乍现 orz…这个方法不用nginx去解决 只要绑定hosts就可以了 tomcat绑定不了80端口 那么我们绑定8080端口 然后在hosts中绑定 1$ 127.0.0.1:8080 yourwebsite 在这里安利大家一个好用的编辑hosts的chrome插件 Host Switch Plus 不担心缓存 使用方便问题背景：mac的1024以下端口管理比较严格，搞了好久也没能让本地tomcat开启80端口，开启其他大于1024端口的倒是可以，但是这样不利用访问，访问web的时候，需要每次都带着端口访问，链接跳着跳着端口就有问题了，后来稍微了解了下nginx的知识，着手用nginx的反向代理能力去解决此问题。大概思路是让nginx开启80端口(这个倒是可以开启80端口 orz) 然后遇到自己设置的servername的时候再反向代理到本地tomcat开启的端口，比如8080 或者9090端口 mac安装nginx的功能就再说了，可以用brew安装也可以编译安装，自行百度，我好像是用brew安装的 我web开发工具用的是idea,怎么建tomcat也不说了，不是这篇文章的目的,tomcat的端口的话就用默认的8080就可以了。 修改nginx的配置文件nginx.conf 如果路径不一样的，自行更改 1$ sudo vim /usr/local/etc/nginx/nginx.conf 重要的都用箭头标出来了 listen 80：表示nginx监听80端口 server_name : 可以有多个 这里需要注意的是 每个域名要在hosts文件中绑定IP到127.0.0.1 不然还是拦截不到的 这点需要注意 access_log: 访问日志 可以打开 打开的话要把后面的main去掉 location： / 拦截所有访问本地80端口的路径 这是个正则表达式 有兴趣的可以去搜搜看 可以写成其他的正则 proxy_pass http://127.0.0.1:8080 这句就是核心了 将访问的80端口导到本地的8080端口(我的本地tomcat开启的端口) 开启nginx 1$ sudo nginx 大功告成！","tags":[]},{"title":"mysql禁用validate_password插件","date":"2017-04-14T02:36:01.000Z","path":"2017/04/14/mysql禁用validate_password插件/","text":"新版本的MySQL默认开启了validate_password插件，进行密码验证，需要很强的密码强度才能通过认证，如果是自己玩玩的话没必要那么复杂，如果是公司的话，还是不要禁用了。其实关闭插件很简单，在mysql配置文件(centos系统下是/etc/my.conf)里面[mysqld]选项下面添加下面一条语句即可 1validate_password=off 记得配置后要重启mysql.在shell下面运行下面两条语句： 12service mysqld stop service mysqld start 如果不想关闭，而是想修改密码强度的话，可以看看下面这篇文档，我就不多做解释了。http://dev.mysql.com/doc/refman/5.6/en/validate-password-plugin.html#option_mysqld_validate-password","tags":[]}]