[{"title":"Spring问题快问快答","date":"2017-12-31T12:21:34.000Z","path":"2017/12/31/Spring问题快问快答/","text":"这篇文章主要是博主平时遇到的问题 后来经过不断的学习 又被自己解决的问题 如果读者有什么问题的话 可以在下面留言 我会尽力解答 暂时没有目录 以后会想办法解决这个问题 @Controller与@Component注解有什么不同 文章 component-scan做了些什么 最后问出的问题@Controller注解的作用只是注册普通bean 这是spring团队为了适应mvc所写的一个注解 让人一看就知道这是个控制器 真正起到路由作用的是@RequestMapping注解 spring会根据这个类上面有没有@RequestMapping来最终判定这个类是不是控制器 Tomcat中DefaultServlet拦截的路径是/ 而spring中DispatcherServlet一般拦截的路径也是/ 那为什么最后请求会给DispatcherServlet而不是DefaultServlet呢?如果有除了tomcat自带的DefaultServlet外的servlet的拦截路径也是/的话 这个servlet会被设置为默认servlet(defaultServlet) 相当于覆盖了tomcat自带的servlet 对于寻找请求的处理servlet 有专门的一套逻辑去处理 servlet过滤器 spring过滤器有什么不同 待解 @Before @Around @After的执行顺序?如果我们把@Around注解方法拆分为三块：around.before,proxyed_method(被代理的方法 即调用proceedingJoinPoint.proceed()那部分),around.after那么执行顺序为:before_advice-&gt;around.before-&gt; proxyed_method-&gt;around.after-&gt;after至于执行结果为什么是这样的 可以看下面的博文@Before @Around @After的执行顺序源码解析 Spring的父子容器介绍我们通常说的父子容器是在web环境中 自然形成的 ContextLoaderListener加载的是父容器 而由DispatcherServlet加载的是子容器 就像java语言中父子关系一样 子类可以获得父类的属性 但父类不能活的子类的属性 详情请点击spring web环境的加载 Spring类路径到底指的是什么路径网上的答案也是众说纷纭 让大家也是很苦恼 不知道相信哪一个 这个时候最好的解决办法就是找办法验证 通过测试去解决 在这里教大家一个更好的解决办法(maven spring web环境) 把你的web项目打包 然后看打包后的目录结构 你会发现main/resources目录下的配置文件都被放在了WEB_INF下 跟 classes 目录同级结构 这个时候我想一切就都明白了 控制器Controller 是单例模式吗 默认情况下是的 Controller就是一个普通的Bean 只是在RequestMapping注解的作用下 具有了控制器的作用 但这并不改变Controller作为一个普通的Bean的作用","tags":[]},{"title":"常用命令行命令详解","date":"2017-05-07T01:58:35.000Z","path":"2017/05/07/常用命令行命令详解/","text":"","tags":[]},{"title":"aop源码解析二:寻找Advisor","date":"2017-04-21T04:34:05.000Z","path":"2017/04/21/aop源码解析二-寻找Advisor/","text":"写在前面这一部分的内容 会比较多 如果只是看代码的话 可能不够直观 所以这个时候我们就需要使出程序员必备技能DEBUG 当然前提是你已经搭建好了环境 如果没有话 请点击Spring源码分析环境搭建我们分析的这一部分的代码 spring中已经有了相关的测试类AspectJAutoProxyCreatorTests 相信结合下面的分析的话 读者是能够看懂这部分代码的.","tags":[{"name":"aop","slug":"aop","permalink":"http://yoursite.com/tags/aop/"}]},{"title":"aop源码解析一:注册BPP","date":"2017-04-20T05:25:52.000Z","path":"2017/04/20/aop源码解析一/","text":"本文目的如题,标签&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; expose-proxy=&quot;true&quot;/&gt;注册BPP(AspectJAutoProxyBeanDefinitionParser)源码分析 并没有介绍过BPP相关内容 这里简单的讲解下 读者心里有个概念就行 等有时间补写Bean的加载与读取的时候 会好好介绍这个重要的类!首先 spring在一些特殊的位置插入了一些处理代码(可能有些读者觉得这句话很眩 不太好理解 我换种表达方式:从加载配置文件到转换成对应的定义类 比如BeanDefinition 再到获取bean 这一整个过程都是spring在做的 他当然能够在任意想插的位置插入代码了) 例如在实例化前后 或者在初始化前后调的方法 这些类一般是BeanPostProcessor的子类 简称BPP 正文对于aop这样的非标准或者称为自定义命名空间的元素 spring会从spring.handlersspring.handlers文件中的对应关系找到相应的处理类 然后通过init()方法注册一些处理器 aop命名空间的处理类是AopNamespaceHandler 我们看一下他的init()方法 public void init() { // In 2.0 XSD as well as in 2.1 XSD. registerBeanDefinitionParser(&quot;config&quot;, new ConfigBeanDefinitionParser()); // registerBeanDefinitionParser(&quot;aspectj-autoproxy&quot;, new AspectJAutoProxyBeanDefinitionParser()); registerBeanDefinitionDecorator(&quot;scoped-proxy&quot;, new ScopedProxyBeanDefinitionDecorator()); // Only in 2.0 XSD: moved to context namespace as of 2.1 registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser()); } 从上面注册的处理器的关系我们知道 &lt;aop:aspectj-autoproxy&gt;标签的处理器是AspectJAutoProxyBeanDefinitionParser 同样 这是一个继承于BeanDefinitionParser的标准的解析器 我们看一下他的parse()方法 public BeanDefinition parse(Element element, ParserContext parserContext) { //注册BPP(AnnotationAwareAspectJAutoProxyCreator) AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element); // 如果有子元素的话 设置属性 extendBeanDefinition(element, parserContext); return null; } parse()方法可以说主要做了一件事情就是注册了一个BPP(BeanPostProcessor) 供后续使用 有些人看到这里可能就蒙圈了 这什么东西 名字这么长 看到后面的时候又会说这是什么东西 类的名字这么长 然后就会觉得好难 主要是读者阅读代码不多的原因 如果阅读的多了 你就会形成一个感觉：不管这个类名字多奇怪 名字多长 不过是一些基本类型(map list等)的包装而已 为了完成某一个功能所做的封装而已 //spring中的方法一般都比较清晰 短短的几行代码告诉了你这个方法要做什么事情 public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary( ParserContext parserContext, Element sourceElement) { //注册BPP(AnnotationAwareAspectJAutoProxyCreator) BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary( parserContext.getRegistry(), parserContext.extractSource(sourceElement)); //根据xml配置 设置AnnotationAwareAspectJAutoProxyCreator的proxyTargetClass exposeProxy属性 useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement); //注册组件bean 并暴露给外部 registerComponentIfNecessary(beanDefinition, parserContext); } 不断的追踪registerAspectJAnnotationAutoProxyCreatorIfNecessary()方法发现 就是注册了个BPP(AspectJAutoProxyBeanDefinitionParser) 不再贴出相关代码 我们看下useClassProxyingIfNecessary()方法 //处理proxy-target-class 以及 expose-proxy属性 private static void useClassProxyingIfNecessary(BeanDefinitionRegistry registry, Element sourceElement) { if (sourceElement != null) { //proxy-target-class true:强制使用CGLIB代理 推荐使用 boolean proxyTargetClass = Boolean.valueOf(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE)); if (proxyTargetClass) { AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry); } //expose-proxy true:暴露代理类 解决某些情况下 代理无法完成的情况 boolean exposeProxy = Boolean.valueOf(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE)); if (exposeProxy) { AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry); } } } 总结似乎&lt;aop:aspectj-autoproxy&gt;标签做的事情并不多 只是注册了一个BPP 但是这个BPP确实非常重要的! 我们用到的切面编程就依靠这个BPP去驱动实现 后面的文章会介绍这个BPP的源码是怎么实现AOP的","tags":[{"name":"aop","slug":"aop","permalink":"http://yoursite.com/tags/aop/"}]},{"title":"aop功能实现口述","date":"2017-04-19T10:22:15.000Z","path":"2017/04/19/aop功能实现口述/","text":"spring-aop功能 涉及到的东西很多 比如 切面 CGLIB 责任链等 这些东西会讲到 但不会详细讲解 一来是因为篇幅限制 另外博客的目的还是授人以鱼不如授人以渔 为了让大家能阅读下面几篇关于aop的文章更顺利些 这里先给读者讲一下 spring实现aop大概的流程以及涉及到的一些名词 因为注解形式的友好性 大家用的比较多 所以我们只谈这种形式的实现 aop 面向切面编程(AOP) :面向对象编程(OOP)的一种扩展 可以这样理解 我们之前所做的所有功能大体来说都是线性的(好比在流淌在水管里的水 一直是往前流动的 很难纵向扩展) 如果我们想加一些公共的服务 比如说日志 登录检查等 OOP将会有大量的重复代码 pointcut 连接点 就是这些额外的动作的发生点 advice 切面 就是我们上面说的那些公共服务 比如说日志 登录检查等 advisor 我们这里说的advisor 是实现代码里面的advisor 是一个封装类 包括了pointcut(验证是否跟指定方法匹配的功能) 与 advice 流程: 我们暂时把spring加载bean的过程笼统的分为两个阶段 spring加载配置文件并根据配置文件或者注解生成BeanDefinition的过程。 BeanDefinition看这个词的意思就略知一二 如果你看过tomcat的源码的话 应该会让你想起servletconfig 主要是用来保存bean的配置信息 如果bean是prototype类型的 那么下次就不用在加载了 spring提前加载非懒惰的bean的过程 很显然 aop的实现就是在第二个阶段 bean有几个比较特殊的阶段 比如实例化(instantiate) 初始化(initiate) 那么就可以在这几个特殊阶段的前后加一些方法 实现扩展 spring在bean初始化完成后的时机 完成了 找出所有切面类的切面方法 未完","tags":[{"name":"aop","slug":"aop","permalink":"http://yoursite.com/tags/aop/"}]},{"title":"component-scan做了些什么|源码解读","date":"2017-04-18T09:35:35.000Z","path":"2017/04/18/component-scan做了些什么/","text":"本文目的本文主要解决一个问题就是component-scan会扫描注册哪些注解标注的类 被@Controller标注的类会被扫描注册吗? 当然本文也可以当作spring解析非默认空间下元素的一个教程 正文当遇到component-scan这样非标准或者称为自定义的元素标签时 spring会通过spring.handlers文件中的对应关系http\\://www.springframework.org/schema/context= org.springframework.context.config.ContextNamespaceHandler找到ContextNamespaceHandler 通过ContextNamespaceHandler类init()方法自动注册一些解析器 下面列出了所有以context为命名空间的组合 例如常见的&lt;context:componet-scan&gt;元素 根据注册对应关系 知道其对应的解析器为ComponentScanBeanDefinitionParser public void init() { registerBeanDefinitionParser(&quot;property-placeholder&quot;, new PropertyPlaceholderBeanDefinitionParser()); registerBeanDefinitionParser(&quot;property-override&quot;, new PropertyOverrideBeanDefinitionParser()); registerBeanDefinitionParser(&quot;annotation-config&quot;, new AnnotationConfigBeanDefinitionParser()); registerBeanDefinitionParser(&quot;component-scan&quot;, new ComponentScanBeanDefinitionParser()); registerBeanDefinitionParser(&quot;load-time-weaver&quot;, new LoadTimeWeaverBeanDefinitionParser()); registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser()); registerBeanDefinitionParser(&quot;mbean-export&quot;, new MBeanExportBeanDefinitionParser()); registerBeanDefinitionParser(&quot;mbean-server&quot;, new MBeanServerBeanDefinitionParser()); } 那我们看一下&lt;context:component-scan&gt;的解析器ComponentScanBeanDefinitionParser的源码 (ComponentScanBeanDefinitionParser继承自BeanDefinitionParser) spring解析&lt;context:component-scan&gt;的时候会调用ComponentScanBeanDefinitionParser的parse()函数 //element 代表的是完整的&lt;context:component-scan&gt;标签 //parserContext 解析的上下文环境 能拿到一些诸如readerContext registry等变量 public BeanDefinition parse(Element element, ParserContext parserContext) { //将指定base-package拆分成string数组的形式 String[] basePackages = StringUtils.tokenizeToStringArray(element.getAttribute(BASE_PACKAGE_ATTRIBUTE), ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); // 根据xml配置或者默认配置(如果没有指定的话)配置扫描器ClassPathBeanDefinitionScanner ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element); //scanner扫描包下面含有特殊注解标注的类 //@Component @Named @ManagedBean (@Controller @Service @Repository @Configuration)都会被注册 Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages); // 注册组件以及一些我们常见的注解处理器(BPP) 如@Resouce @Autowired @Configuration @Value @Required @PostConstruct //那么以后看到属性注入(IOC/DI)的时候 就不会奇怪 这些注解的处理器(BPP)是在哪里注册的了 在这里! registerComponents(parserContext.getReaderContext(), beanDefinitions, element); return null; } 看一下scanner的创建以及设置 protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) { XmlReaderContext readerContext = parserContext.getReaderContext(); boolean useDefaultFilters = true; if (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) { useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)); } // 生成scanner的时候 在其父类构造函数中调用了`registerDefaultFilters()`方法中加入了3个注解类型的typeFilter 分别是@Component // @ManagedBean @Named 意思也就是看类上面有没有这三个注解或者注解的元注解中是否含有这三个注解之一 // 这里虽然没有加入如@Service的注解 但看@Service的定义会发现@Service注解也被@Component给标注了 ClassPathBeanDefinitionScanner scanner = createScanner(readerContext, useDefaultFilters); scanner.setResourceLoader(readerContext.getResourceLoader()); scanner.setEnvironment(parserContext.getDelegate().getEnvironment()); // 利用spring 启动的时候根据xml文件或者默认配置(如果没有指定的话)生成的BeanDefinition规则 scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults()); scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns()); if (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) { scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE)); } try { // 扫描注解定义的bean 需要定义一种beanName的生成规则 一般是驼峰命名法 parseBeanNameGenerator(element, scanner); } catch (Exception ex) { readerContext.error(ex.getMessage(), readerContext.extractSource(element), ex.getCause()); } try { // bean的scope singleton?prototype? parseScope(element, scanner); } catch (Exception ex) { readerContext.error(ex.getMessage(), readerContext.extractSource(element), ex.getCause()); } // 根据xml配置生成includeFilter excludeFilter 在创建scanner类的时候 就硬编码进去了3个注解类型 // 的typeFilter到includeFilter里面 // 类必须满足以下条件才会被注册 因为@Component等是被硬编码进去的 所以只有下面一种情况才会被注册了 // 不被excludeFilter匹配 并且被includeFilter匹配 parseTypeFilters(element, scanner, readerContext, parserContext); return scanner; } 下面在看一下真正的扫描过程doScan 我们发现spirng中真正干活的一般都是以do开头 前面的那么多只是为了做铺垫 单一指责 protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) { Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;); Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(); for (String basePackage : basePackages) { //寻找被@Component或者@Named注解标注的类 或者 类的注解的元注解中含有这两个注解 例如常见的@Respsitory @Controller @Service Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); // 对于生成的AnnotatedBeanDefinition做一些转化工作 例如前面说到的应用bd(BeanDefinition)默认配置 // 处理@Primary @Lazy @DependsOn @Role注解等 // 转化成BeanDefinitionHolder对象 for (BeanDefinition candidate : candidates) { ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) { postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); } if (candidate instanceof AnnotatedBeanDefinition) { AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); } if (checkCandidate(beanName, candidate)) { BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); //注册到容器中 registerBeanDefinition(definitionHolder, this.registry); } } } return beanDefinitions; } 看一下findCandidateComponents方法 public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) { Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;BeanDefinition&gt;(); try { String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + &quot;/&quot; + this.resourcePattern; //这里的resouces代表的就是路径下的各个类了 Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath); boolean traceEnabled = logger.isTraceEnabled(); boolean debugEnabled = logger.isDebugEnabled(); for (Resource resource : resources) { if (traceEnabled) { logger.trace(&quot;Scanning &quot; + resource); } if (resource.isReadable()) { try { // 这一步的作用就是能够不必加载class但能拿到class各种属性 并且这里也不能载入class(有很多是单例模式) 还没到那一步 // 只是为了做匹配 生成bd而已 MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); // 根据includeFilters excludeFilters做匹配 因为篇幅的限制 不详谈 有兴趣的可以研究一下typeFilter的实现 if (isCandidateComponent(metadataReader)) { ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); if (isCandidateComponent(sbd)) { if (debugEnabled) { logger.debug(&quot;Identified candidate component class: &quot; + resource); } candidates.add(sbd); } else { if (debugEnabled) { logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource); } } } else { if (traceEnabled) { logger.trace(&quot;Ignored because not matching any filter: &quot; + resource); } } } catch (Throwable ex) { throw new BeanDefinitionStoreException( &quot;Failed to read candidate component class: &quot; + resource, ex); } } else { if (traceEnabled) { logger.trace(&quot;Ignored because not readable: &quot; + resource); } } } } catch (IOException ex) { throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, ex); } return candidates; } 到这里 我们算是差不多看完了scanner的扫描注册过程 扫描注册过程不过循环base-package路径下面的所有类 看是否有标注特定注解(硬编码)的类 将这些类转化成bd 供我们后续使用 这里要注意的就是这里不能将类实例化我们再回到ComponentScanBeanDefinitionParser的parse()方法 看下registerComponents()方法registerComponents()方法中除了组件外 还有一个比较重要的事情 就是注册我们后面属性填充(IOC)需要用到的一些BPP 例如@Resouce @Autowired等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 protected void registerComponents( XmlReaderContext readerContext, Set&lt;BeanDefinitionHolder&gt; beanDefinitions, Element element) &#123; Object source = readerContext.extractSource(element); CompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), source); for (BeanDefinitionHolder beanDefHolder : beanDefinitions) &#123; compositeDef.addNestedComponent(new BeanComponentDefinition(beanDefHolder)); &#125; // Register annotation config processors, if necessary. // 默认注册 boolean annotationConfig = true; if (element.hasAttribute(ANNOTATION_CONFIG_ATTRIBUTE)) &#123; annotationConfig = Boolean.valueOf(element.getAttribute(ANNOTATION_CONFIG_ATTRIBUTE)); &#125; if (annotationConfig) &#123; //这里注册我们需要的BPP Set&lt;BeanDefinitionHolder&gt; processorDefinitions = AnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source); for (BeanDefinitionHolder processorDefinition : processorDefinitions) &#123; compositeDef.addNestedComponent(new BeanComponentDefinition(processorDefinition)); &#125; &#125; readerContext.fireComponentRegistered(compositeDef); &#125; public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors( BeanDefinitionRegistry registry, Object source) &#123; Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(4); // @Configuration if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; //@Autowired @Value if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; //@Required if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; //@PostConsruct @Resouce 等java注解 // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor. if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; // // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor. if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(); try &#123; def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, AnnotationConfigUtils.class.getClassLoader())); &#125; catch (ClassNotFoundException ex) &#123; throw new IllegalStateException( &quot;Cannot load optional framework class: &quot; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex); &#125; def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; return beanDefs; &#125; 总的来说 component-scan 做了什么事情就比较清晰了 下面做一下总结 根据配置生成扫描类ClassPathBeanDefinitionScanner 扫描注册包下符合匹配规则的类 扫描注册被@Controller @Service @Respsitory @Component @Configuration等标注的类 因为@Controller @Service @Respsitory注解的元注解包含@Component 也就是说@Controller @Service @Respsitory本身被@Component标注 而匹配规则中有一条就是元注解包含@Component @Named 或者 @ManagedBean 注册处理如@Resouce @Autowired @PostConstruct等的BPP 当然由于篇幅限制 并没有把所有的知识点都讲到 很多也是点到 那些东西需要读者有时间的时候自己跟着代码走一遍了那么又出现一个问题：既然@Controller注解标注的类也被像普通bean一样注册了 那么在web项目中 又是怎么知道哪些是我们需要的Controller类呢?且听下回分析…","tags":[{"name":"component-scan","slug":"component-scan","permalink":"http://yoursite.com/tags/component-scan/"}]},{"title":"ClassPathXmlApplicationContext源码解析二:默认空间元素解析","date":"2017-04-17T12:15:44.000Z","path":"2017/04/17/ClassPathXmlApplicationContext源码解析二-默认空间元素解析/","text":"写在前面在 ClassPathXmlApplicationContext源码解析一 中 我们用了很长的篇幅 介绍了加载上下文环境前的各种准备工作 spring是个世界级的项目框架 由精英团队打造 全世界的测试人员测试 即使如果读者感觉有点吃力 对突然冒出来的代码有点不习惯的话 也不要气馁 继续往下读 刚阅读源代码的时候 最怕纠结于一些琐碎单却不重要的事情 下面我们看一下parseBeanDefinitions(root, this.delegate)方法12345678910111213141516171819202122232425262728//对于`delegate` 我们暂时只要知道这个类中含有我们需要的一些environment,beanfactory等信息就可以了 当然他还提供一些解析方法 protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; /** * 如果是默认命名空间 也就是&quot;http://www.springframework.org/schema/beans&quot;这个空间下的元素 调用parseDefaultElement * 否则调用parseCustomElement 例如aop context tx等标签的解析 * 也就是parseDefaultElement 解析import alias bean beans标签元素 * parseCustomElement 解析aop context tx 或者是用户自定义命名空间的元素 */ if (delegate.isDefaultNamespace(root)) &#123; NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) &#123; //继续这个方法研究 parseDefaultElement(ele, delegate); &#125; else &#123; delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; delegate.parseCustomElement(root); &#125; &#125; 我们这篇文章只看默认命名空间的解析 也就是http://www.springframework.org/schema/beans这个空间下的定义的元素定义 对于非默认空间下的元素的解析的话 请看component-scan做了些什么 这篇文章讲解了component空间下的元素解析1234567891011121314151617181920private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123; //解析import元素标签 通过调用`loadBeanDefinitions`模块方法完成元素加载&lt;import resource=&quot;url&quot;/&gt; if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; importBeanDefinitionResource(ele); &#125; //解析alias元素标签 &lt;alias name=&quot;&quot; alias=&quot;&quot; /&gt; else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; //注册别名 说白点就是把name alias的对应关系加入到一个map中 processAliasRegistration(ele); &#125; //解析bean元素标签 最核心 &lt;bean &gt; else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; processBeanDefinition(ele, delegate); &#125; //解析beans元素标签 又调用了`doRegisterBeanDefinitions(element)`方法去解析&lt;beans&gt; else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; // recurse doRegisterBeanDefinitions(ele); &#125;&#125; 到达这个方法的时候 ele代表的就是一个bean标签元素了 例如1&lt;bean id=&quot;&quot; class=&quot;&quot;&gt; 我们不必深入了解xml文档的解析 也是能看的懂的 当然如果了解解析的过程 是更好的了我们可以很清晰的看到beans空间下的元素标签有import alias bean beans 我们当然是重点讲解bean标签的解析了 继续跟踪代码123456789101112131415161718protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;//继续跟踪 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) &#123; //处理非默认命名空间的元素 如果有的话 这里不继续跟踪下去了 bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; // 也就是放到一个map中去 key为beanName value为BeanDefinition BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error(&quot;Failed to register bean definition with name &apos;&quot; + bdHolder.getBeanName() + &quot;&apos;&quot;, ele, ex); &#125; // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125;&#125; 跟踪进BeanDefinitionParserDelegate.parseBeanDefinitionElement方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123; String id = ele.getAttribute(ID_ATTRIBUTE); String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); //bean标签中的name其实会被划分成alias List&lt;String&gt; aliases = new ArrayList&lt;String&gt;(); if (StringUtils.hasLength(nameAttr)) &#123; String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); &#125; String beanName = id; if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123; beanName = aliases.remove(0); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;No XML &apos;id&apos; specified - using &apos;&quot; + beanName + &quot;&apos; as bean name and &quot; + aliases + &quot; as aliases&quot;); &#125; &#125; if (containingBean == null) &#123; //beanName唯一性校验 checkNameUniqueness(beanName, aliases, ele); &#125; AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);//GenericBeanDefinition if (beanDefinition != null) &#123; // 阅读源代码要做到有的放矢 像下面这样的代码就没有太大的必要去看了 if (!StringUtils.hasText(beanName)) &#123; try &#123; if (containingBean != null) &#123; beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); &#125; else &#123; beanName = this.readerContext.generateBeanName(beanDefinition); String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123; aliases.add(beanClassName); &#125; &#125; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Neither XML &apos;id&apos; nor &apos;name&apos; specified - &quot; + &quot;using generated bean name [&quot; + beanName + &quot;]&quot;); &#125; &#125; catch (Exception ex) &#123; error(ex.getMessage(), ele); return null; &#125; &#125; //返回BeanDefinitionHolder String[] aliasesArray = StringUtils.toStringArray(aliases); return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); &#125; return null;&#125; id 就是beanName了 必须要唯一才行 其实parseBeanDefinitionElement这个方法的目的就很明确了 就是要把bean的配置读取并保存起来 保存到GenericBeanDefinition中 例如我们常见的property constructor-arg等 无非就是构造合适的结构 然后读取数据并保存起来 供以后使用我们就不再深入解读了 读者可以自己找几个解析方法阅读1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 在这个方法中会遇到我们之前可能没有遇到的标签/属性元素 最好的解决办法就是先搜索这个元素/属性的用法,然后再看解析, 再看他们的应用处理等 * 我们这里不对这些不常用的元素/属性进行详解 这里主要就是解析出来并保存到BeanDefinitiion中 */public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, BeanDefinition containingBean) &#123; this.parseState.push(new BeanEntry(beanName)); String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123; className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); &#125; try &#123; String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123; parent = ele.getAttribute(PARENT_ATTRIBUTE); &#125; //GenericBeanDefinition 设置className parentName变量 AbstractBeanDefinition bd = createBeanDefinition(className, parent);// //解析元素属性 例如scope lazy-init factory-method等属性的解析 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); //解析元素子元素开始 bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); //&lt;meta key=&quot;&quot; value=&quot;&quot; /&gt; 作为对bd的额外参数使用 parseMetaElements(ele, bd); //&lt;lookup-method name=&quot;&quot; bean=&quot;&quot; /&gt; 插拔式设计 方法根据配置 动态返回不同的bean 感兴趣的可以自行搜索相关使用demo parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); //&lt;replaced-method name=&quot;&quot; replacer=&quot;&quot;/&gt; 根据配置 替换/更改原来的方法逻辑 interesting 感兴趣的可以自行搜索相关使用demo parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); //todo &lt;constructor-arg index=&quot;i&quot;&gt;&lt;/constructor-arg&gt; parseConstructorArgElements(ele, bd); //&lt;property name=&quot;&quot; value=&quot;&quot;/&gt; or more complex property such as list,map 阅读源代码 我们要有的放矢 // 没必要把每一行都看懂 就像下面的解析构造参数 与 property一样 都是很复杂的 但我们没必要都读懂才行 parsePropertyElements(ele, bd); //&lt;qualifier /&gt; parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; &#125; catch (ClassNotFoundException ex) &#123; error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex); &#125; catch (NoClassDefFoundError err) &#123; error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err); &#125; catch (Throwable ex) &#123; error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex); &#125; finally &#123; this.parseState.pop(); &#125; return null;&#125; 生成beanDefinition后 再用BeanDefinitionHolder封装后返回注册 至此xml配置文件中的设置就转化为了java对象保存我们在回到refresh()方法 继续往下看prepareBeanFactory()方法123456789101112131415161718192021222324252627282930313233343536373839404142434445protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; // Tell the internal bean factory to use the context&apos;s class loader etc. beanFactory.setBeanClassLoader(getClassLoader()); // beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver()); // 我们知道xml文档中的都是字符串形式的值 但我们可能需要的是其他的类型 比如Float Date等 // 这里注册一些常用的属性编辑器 去解决类型转化问题 beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); //BPP 作用是如果bean实现了Aware接口的话 自动调用`setXXX`方法 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); //忽略特殊类`ResourceLoaderAware` 等的依赖 beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); beanFactory.ignoreDependencyInterface(EnvironmentAware.class); // BeanFactory interface not registered as resolvable type in a plain factory. // MessageSource registered (and found for autowiring) as a bean. beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // Detect a LoadTimeWeaver and prepare for weaving, if found. // @AspectJ相关 不常用 后面会专门讲解Spring AOP if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123; beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // Set a temporary ClassLoader for type matching. beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); &#125; // Register default environment beans. if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123; beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); &#125; if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123; beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); &#125; if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123; beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); &#125;&#125; 代码里面的注释应该是很详细了 我们来分析一个很有趣的事情如果我们想在我们自己类中 获取如ApplicationContext的话 我们一般会继承ApplicationContextAware 然后有个回调方法会让我们实现 例如setApplicationContext 那么为什么我们只要实现了这个接口 我们实现的回调方法就会调用呢 奥秘就在这句代码beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this))BPP(BeanFactoryPostProcessor)是个很重要的知识点 我们这里大概了解一下 不管是单例模式还是原型模式 我们定义的class肯定是要实例化的 如果有定义初始化方法的话 还会调用初始化方法 对于一个类来说 实例化 初始化都是很重要的时间节点 我们的class又是托管给spring进行管理的 那么spring就有能力 有机会在这些时间节点前后添加一些处理方法 spring中代表这一类操作的接口是BeanPostProcessor 简称BPP 中文翻译是后置处理器 当然spring中还有一种PostProcessor是容器级别的 BeanFactoryPostProcessor 就是在容器加载前后做一些特殊的操作 在ApplicationContextAwareProcessor.postProcessBeforeInitialization(final Object bean, String beanName)方法中 会调用invokeAwareInterfaces(bean)方法1234567891011121314151617181920212223private void invokeAwareInterfaces(Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof EnvironmentAware) &#123; ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment()); &#125; if (bean instanceof EmbeddedValueResolverAware) &#123; ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver( new EmbeddedValueResolver(this.applicationContext.getBeanFactory())); &#125; if (bean instanceof ResourceLoaderAware) &#123; ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext); &#125; if (bean instanceof ApplicationEventPublisherAware) &#123; ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext); &#125; if (bean instanceof MessageSourceAware) &#123; ((MessageSourceAware) bean).setMessageSource(this.applicationContext); &#125; if (bean instanceof ApplicationContextAware) &#123; ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext); &#125; &#125;&#125; 看起来很神秘的东西 它的实现是不是很一般 而且还感觉有点low 竟然没有魔法","tags":[{"name":"context","slug":"context","permalink":"http://yoursite.com/tags/context/"}]},{"title":"ClassPathXmlApplicationContext源码解析一:准备工作","date":"2017-04-17T10:00:36.000Z","path":"2017/04/17/ClassPathXmlApplicationContext源码解析一/","text":"其实在web环境中 用到的上下文环境是 XmlWebApplicationContext 但其实对于我们要讲解的内容来说 核心逻辑是一样的 在后面讲解到web环境加载的时候 会讲到XmlWebApplicationContext类的解析 下面几篇博客的内容我们会介绍Spring是怎么构建上下文环境的 也就是ClassPathXmlApplicationContext的源码的过程ClassPathXmlApplicationContext类的测试类是ClassPathXmlApplicationContextTests 如果读者能好好利用这个测试类的话 能节省不少阅读源码的时间构造函数123456789 //接收配置文件的地址 默认刷新 父容器为null 讲解web环境加载的时候 会讲到父容器的概念public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException &#123; super(parent); setConfigLocations(configLocations); if (refresh) &#123; refresh(); &#125;&#125; 以后讲解web环境加载的时候我们会讲到父子容器的概念 这里只考虑父容器为null的情况 如果路径中含有如${user.dir}的变量 会被处理替换掉 对替换这部分感兴趣的读者可以深入阅读 然后就进入最重要的一个方法refresh()refresh()refresh()方法从总体上看 还算比较清晰 用几个大的方法高度概括了refresh()要完成的工作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. // 加载前的准备工作:active标记为true；资源必要性验证等 prepareRefresh(); // 创建DefaultListableBeanFactory 并加载配置文件 转化为BeanDefinition保存 // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. //empty postProcessBeanFactory(beanFactory); // invoke // Invoke factory processors registered as beans in the context. // spring扩展的实现(容器级别) BeanFactoryPostProcessor 在实例化任何用户定义的bean之前 会首先调用BFPP的接口方法 // 常见的BFPP:PropertyPlaceholderConfigurer invokeBeanFactoryPostProcessors(beanFactory); // register // Register bean processors that intercept bean creation. // spring可扩展的另一个实现:BeanPostProcessor 在调用bean的init-method方法的前后会调用接口方法 // 较常见的硬编码的BPP:ApplicationContextAwareProcessor,ApplicationListenerDetector registerBeanPostProcessors(beanFactory); // Initialize message source for this context. //国际化 initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. //empty onRefresh(); // Check for listener beans and register them. // 注册listener registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. // 实例化所有的非懒惰加载的单例 finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt&quot;, ex); // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset &apos;active&apos; flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; &#125;&#125; 下面我们看obtainFreshBeanFactory()#AbstractRefreshableApplicationContext.refreshBeanFactory()方法(obtainFreshBeanFactory()方法中主要逻辑是在refreshBeanFactory()方法 我们就不再列出完整的obtainFreshBeanFactory()方法 以后这样的格式我们用#区分)再此感叹spring代码的优秀 每个方法都是那么的简短清晰 一层一层的深入12345678910111213141516171819202122protected final void refreshBeanFactory() throws BeansException &#123;// 如果已经加载过的话 先销毁再重新加载 if (hasBeanFactory()) &#123; destroyBeans(); closeBeanFactory(); &#125; try &#123; //实例化一个DefaultListableBeanFactory 这是一个很重要的类 DefaultListableBeanFactory beanFactory = createBeanFactory(); //设置id beanFactory.setSerializationId(getId()); customizeBeanFactory(beanFactory); loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) &#123; this.beanFactory = beanFactory; &#125; &#125; catch (IOException ex) &#123; throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex); &#125;&#125; 12345678910/** * 忽略BeanNameAware BeanFactoryAware BeanClassLoaderAware的依赖 spring有设置专门调用setXXX方法的地方 * Create a new AbstractAutowireCapableBeanFactory. */ public AbstractAutowireCapableBeanFactory() &#123; super(); ignoreDependencyInterface(BeanNameAware.class); ignoreDependencyInterface(BeanFactoryAware.class); ignoreDependencyInterface(BeanClassLoaderAware.class); &#125; 对于这样的代码 如果不跟踪进去的话 可能会对有些变量的值感到困惑createBeanFactory()实例化了一个DefaultListableBeanFactory 在实例化的过程中 其父类 AbstractAutowireCapableBeanFactory的构造函数注册了几个忽略依赖注入的接口 就是说以后对于bean的属性注入的时候 如果在我们注册的忽略接口里面的话 就不再依赖注入12345678910111213// protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123; //是否允许覆盖 if (this.allowBeanDefinitionOverriding != null) &#123; beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; //是否允许循环引用 循环引用是很重要的一个知识点 我们后面会专门讲解 if (this.allowCircularReferences != null) &#123; beanFactory.setAllowCircularReferences(this.allowCircularReferences); &#125; //设置Qualifier注解解析类 beanFactory.setAutowireCandidateResolver(new QualifierAnnotationAutowireCandidateResolver()); &#125; 我们看下beanFactory.setAutowireCandidateResolver(new QualifierAnnotationAutowireCandidateResolver())方法 这个方法就是设置autowireCandidateResolver变量 顺便做了一件事情 就是如果该变量继承了BeanFactoryAware的话 调用setBeanFactory()方法 我们从这里就可以看到sping代码优秀的另一个方面是约定习俗1234567891011121314151617181920public void setAutowireCandidateResolver(final AutowireCandidateResolver autowireCandidateResolver) &#123; Assert.notNull(autowireCandidateResolver, &quot;AutowireCandidateResolver must not be null&quot;); if (autowireCandidateResolver instanceof BeanFactoryAware) &#123; if (System.getSecurityManager() != null) &#123; final BeanFactory target = this; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; public Object run() &#123; ((BeanFactoryAware) autowireCandidateResolver).setBeanFactory(target); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; // 调用`setBeanFactory()`方法 this作为参数 ((BeanFactoryAware) autowireCandidateResolver).setBeanFactory(this); &#125; &#125; //设置变量 this.autowireCandidateResolver = autowireCandidateResolver;&#125; 下面就进入很重要的一个方法了AbstractXmlApplicationContext#loadBeanDefinitions(beanFactory); 载入配置文件 就是根据配置文件做相应的处理 例如将&lt;bean&gt;转化为BeanDefinition保存 这跟Tomcat将server.xml转化为StandardServer是一样的 阅读这部分代码并不需要你很了解是怎么解析xml文档的 因为方法包装的很好的 当然如果读者比较了解xml文档解析的话 那么就更好了 123456789101112131415protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123; // Create a new XmlBeanDefinitionReader for the given BeanFactory. XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context&apos;s // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // Allow a subclass to provide custom initialization of the reader, // then proceed with actually loading the bean definitions. initBeanDefinitionReader(beanDefinitionReader); loadBeanDefinitions(beanDefinitionReader);&#125; tips 前面几行代码一直在做准备工作 刚阅读源码的读者一定会被这错综复杂的关系所困扰 spring中模块众多,继承 组合关系也是错综复杂 第一次阅读的话 读者可不必太在意这些类之间的委托关系 跟着代码走就可以了 以后阅读第二遍第三遍的时候 再好好研究 比如到现在为止我们都是顺着代码走 并没有从代码设计的角度去讲解loadBeanDefinitions()方法最终会调用AbstractBeanDefinitionReader#loadBeanDefinitions()方法123456789101112131415161718192021222324252627282930313233343536373839404142public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException &#123;//ClassPathXmlApplicationContext ResourceLoader resourceLoader = getResourceLoader(); if (resourceLoader == null) &#123; throw new BeanDefinitionStoreException( &quot;Cannot import bean definitions from location [&quot; + location + &quot;]: no ResourceLoader available&quot;); &#125; if (resourceLoader instanceof ResourcePatternResolver) &#123; // Resource pattern matching available. try &#123; // 把String类型的地址封装成Resource类型 方便后续操作 Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location); int loadCount = loadBeanDefinitions(resources); if (actualResources != null) &#123; for (Resource resource : resources) &#123; actualResources.add(resource); &#125; &#125; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location pattern [&quot; + location + &quot;]&quot;); &#125; return loadCount; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( &quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex); &#125; &#125; else &#123; // Can only load single resources by absolute URL. Resource resource = resourceLoader.getResource(location); int loadCount = loadBeanDefinitions(resource); if (actualResources != null) &#123; actualResources.add(resource); &#125; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location [&quot; + location + &quot;]&quot;); &#125; return loadCount; &#125;&#125; 方法调用AbstractBeanDefinitionReader#loadBeanDefinitions(resource)#loadBeanDefinitions(encodedResource) 我们发现方法调来调去的 却一直没有看到我们想看的内容 一直做的都是准备工作 不急 慢慢来 我们继续往下看12345678910111213141516171819202122232425262728293031323334353637383940public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;); if (logger.isInfoEnabled()) &#123; logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource()); &#125; Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) &#123; currentResources = new HashSet&lt;EncodedResource&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); &#125; if (!currentResources.add(encodedResource)) &#123; throw new BeanDefinitionStoreException( &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;); &#125; try &#123; InputStream inputStream = encodedResource.getResource().getInputStream(); try &#123; InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding()); &#125; // return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); &#125; finally &#123; inputStream.close(); &#125; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex); &#125; finally &#123; currentResources.remove(encodedResource); if (currentResources.isEmpty()) &#123; this.resourcesCurrentlyBeingLoaded.remove(); &#125; &#125;&#125; 也是做各种准备工作 终于让我们遇到了我们想要看的代码doLoadBeanDefinitions 代码读到后面 读者就会注意到spring中以do开头的方法才是真正的核心逻辑的开始123456789101112protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException &#123; try &#123; //获取验证模式 dtd or xsd int validationMode = getValidationModeForResource(resource); //为SAX应用程序提供寻找本地验证文件(dtd/xsd文件) 并将配置文件加载为document保存 Document doc = this.documentLoader.loadDocument( inputSource, getEntityResolver(), this.errorHandler, validationMode, isNamespaceAware()); return registerBeanDefinitions(doc, resource); &#125; ......&#125; 当然还是山路十八弯123456789public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;//DefaultBeanDefinitionDocumentReader BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); documentReader.setEnvironment(getEnvironment()); int countBefore = getRegistry().getBeanDefinitionCount(); // documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125; 1234567public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; this.readerContext = readerContext; logger.debug(&quot;Loading bean definitions&quot;); Element root = doc.getDocumentElement(); //解析的核心部分开始 doRegisterBeanDefinitions(root);&#125; 12345678910111213141516171819protected void doRegisterBeanDefinitions(Element root) &#123; String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);//profile attribute if (StringUtils.hasText(profileSpec)) &#123; String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; return; &#125; &#125; BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(this.readerContext, root, parent); preProcessXml(root); parseBeanDefinitions(root, this.delegate); postProcessXml(root); this.delegate = parent;&#125; 在方法createDelegate(this.readerContext, root, parent);中 通过populateDefaults()方法设置了一些例如default-lazy-init default-autowire的值 如果根元素中有设置这些变量的话 将会覆盖默认值 起到全局变量的作用preProcessXml(root) postProcessXml(root)都被留空 留给子类实现终于 finally 最终 我们看到了我们一直想看到的代码的影子 parseBeanDefinitions(root, this.delegate)要知后事如何 且听下回分解","tags":[{"name":"context","slug":"context","permalink":"http://yoursite.com/tags/context/"}]},{"title":"Tomcat源码分析环境搭建","date":"2017-04-16T07:18:00.000Z","path":"2017/04/16/Tomcat源码分析环境搭建/","text":"阅读源码的第一步就是把环境搭建起来 并能够调试 这样在某些情况下 能帮助你更好的阅读源代码 看起来比较直观 在这一点上 我将再次推荐idea这款集成开发环境 简直是神器 安利网上也有比较多的教程教你怎么把tomcat源代码导入到idea中的教程 我就不再浪费时间在重复写了 我当初也是按着那样的步骤来的 相信读者这些应该是自己能够搞定的我就直接把我搭建好的push到了我的github上面 上面有两个分枝 一个是master分支 这个分支是纯净版的 也就是没有我的注释的版本 另外一个分支是tomcat-with-docs 这个分支是我后来阅读源码的过程中写的注释 以后我会出一系列tomcat源码解析的教程所以 如果你想看纯净版的1$ git clone git@github.com:sunmingshuai/apache-tomcat-7.0.73-src.git 或者你想看有注释的1$ git clone -b tomcat-with-docs git@github.com:sunmingshuai/apache-tomcat-7.0.73-src.git 然后当成maven项目导入到idea中就可以了","tags":[]},{"title":"搭建spring web项目供debug使用","date":"2017-04-16T06:58:58.000Z","path":"2017/04/16/搭建spring-web项目供debug使用/","text":"随着阅读源码的深入 越来越了解debug的重要性 要让代码跑起来 想想自己也是阅读了Spring的核心功能模块 搭建起来应该不费劲 顺便说说感受想想刚毕业那会 进到公司 上手的都是已经搭建好的体系 这个阶段属于依胡萝画瓢阶段后来自己上网搜索搭建教程 虽然也能搭建好 但还是不了解其意 仍然是依胡萝画瓢阶段现在刚好有要搭建spring web项目 供我debug的需求 所以就花点时间搭建了一个 总的来说 比较顺畅 而且基本上每个配置都知道它到底干了什么 给我的感觉不一样了我debug总的来说有2个方面 打包放到tomcat的webapps目录 研究tomcat的源码 启动web项目 研究spring源码 具体的搭建过程我就不说了 我搭建的比较简洁 完全为了debug搭建的 没有多余代码 push到了github仓库 感兴趣的可以clone到本地使用 1$ git clone git@github.com:sunmingshuai/springmvcdemo.git 当成maven项目导入到idea/eclipse就可以了以后有需求的话 会不断的加入一些功能并推送","tags":[]},{"title":"2017阅读书单(持续更新)","date":"2017-04-16T05:46:48.000Z","path":"2017/04/16/2017阅读书单/","text":"技术书单 How Tomcat Works Spring源码深度解析 ActiveMQ in Action(英文版) 成长 巨婴国 被嫌弃的松子的一生 丘吉尔:我的早年生活 梦幻花 如何阅读一本书 黄金时代 月亮与六便士","tags":[]},{"title":"Spring源码分析环境搭建","date":"2017-04-15T13:28:22.000Z","path":"2017/04/15/Spring源码环境搭建/","text":"想研究spring源码的第一步当然是源码的搭建 推荐大家使用idea集成开发环境 下面的搭建过程也以idea为基础需要gradle git环境 不再叙述从github仓库中clone一份代码到本地git clone -b 3.2.x git@github.com:spring-projects/spring-framework.git这里需要注意的是你所使用的jdk版本与spring源码所需要的版本的匹配问题 如果你使用的jdk版本是1.7 而clone的是4以上的spring源码的话 那么comiple的时候就会报错查看源码目录下的 import-into-idea.md 文件 发现步骤可真简单 到spring源码的目录下cd your_spring_dir 执行命令 ./gradlew :spring-oxm:compileTestJava cleanIdea idea 这个过程可能比较慢 感觉卡住的话 ctrl+c 结束执行再重新执行命令 多试几次就好了 导入idea","tags":[]},{"title":"当我谈源码时,我谈些什么","date":"2017-04-15T07:06:19.000Z","path":"2017/04/15/当我谈源码时-我谈些什么/","text":"我们为什么要阅读源码 | 阅读源码给我们带来了什么 简单方面来说，阅读源码使我们更了解所使用的框架，深入其实现原理 更深入方面，我觉得阅读源码是一次提升的机会，提升自己抽象能力，学习大师们解决问题的思路. 阅读源码常见误区 每行代码都要搞懂是什么意思对于一个开源框架 以Tomcat 或者 Spring源码来说 每行代码都要理解的话 一方面会需要大量的时间 另一方面可能会被琐碎但又不那么重要的代码逻辑缠住 可谓是：捡了芝麻 丢了西瓜 要做到: 有的放矢 阅读源码的方法不对阅读源码并不是说把源码导入到集成开发环境中 就不管三七二十一的看起来 要找到切入点 借助开发工具提供的能力 多看看类的层次结构 多思考 学习大牛的抽象能力与分解|解决问题的能力 这两个能力在Tomcat，Spring源码中会达到让你惊叹的地步","tags":[]},{"title":"Unknown system variable 'storage_engine'解决办法","date":"2017-04-14T03:02:18.000Z","path":"2017/04/14/Unknown-system-variable-storage-engine-解决办法/","text":"安装MySQL employees数据库，出现问题，mysql版本为：mysql Ver 14.14 Distrib 5.7.10, for Linux (x86_64) using EditLine wrapper mysql默认的数据库存储引擎是innodb,正好出错的也是这行，提示没有storage_engine变量。好像14以后的msql storage_engine变量更名为default_storage_engine，可是我更改为set default_storage_engine = innodb,还是这行出错，没办法，只能注释掉这样了，反正默认就是innodb引擎。下面说注意事项： 在employees.sql文件中，注释掉(也就是让这行不生效)的时候除了在这行的最前面加’–’外，’–’要跟后面的字符空一个格才生效。即 12345678-- set default_storage_engine = InnoDB -- set storage_engine = InnoDB; -- set storage_engine = MyISAM; -- set storage_engine = Falcon; -- set storage_engine = PBXT; -- set storage_engine = Maria; -- select CONCAT(&apos;storage engine: &apos;, @@storage_engine) as INFO; 不要忘了把INFO那行注释掉，其实这行只是安装的时候提示你安装到哪里了，如果出错的话，好排查。像上面那样注释掉后，再安装就可以了.","tags":[]},{"title":"mac安装sequelpro","date":"2017-04-14T02:55:49.000Z","path":"2017/04/14/mac安装sequelpro/","text":"mac安装sequelpro遇到的问题： 不像其他dmg镜像一样 打开后有一个拖到应用程序的界面 下载sequelpro后 只能以挂载镜像的方式打开 这样的话 倒是可以用 但一直有一个挂载镜像在哪 不舒服 找来找去还是靠一句英文搞定的: how to install sequelpro on mac 然后让我找到了下面一个地址 http://macappstore.org/sequel-pro/照着上面的提示总算安装好了 不过过程中还是遇到了一些问题，安装brew的时候出现了问题 建议去homebrew官网去 官网有安装命令 照着那个安装 可能会因为网络因素什么的 会安装失败 多试几次就好了 终于安装成功 国人的博客啊 很多还是抄来抄去的 不着调 看来跟学生时代 作业抄多了有关系 学习英文 没坏处","tags":[]},{"title":"nginx反向代理解决mac上tomcat80端口问题","date":"2017-04-14T02:47:14.000Z","path":"2017/04/14/nginx反向代理解决mac上tomcat80端口问题/","text":"后来发现一个比较容易的解决方案 灵光乍现 orz…这个方法不用nginx去解决 只要绑定hosts就可以了 tomcat绑定不了80端口 那么我们绑定8080端口 然后在hosts中绑定 1$ 127.0.0.1:8080 yourwebsite 在这里安利大家一个好用的编辑hosts的chrome插件 Host Switch Plus 不担心缓存 使用方便问题背景：mac的1024以下端口管理比较严格，搞了好久也没能让本地tomcat开启80端口，开启其他大于1024端口的倒是可以，但是这样不利用访问，访问web的时候，需要每次都带着端口访问，链接跳着跳着端口就有问题了，后来稍微了解了下nginx的知识，着手用nginx的反向代理能力去解决此问题。大概思路是让nginx开启80端口(这个倒是可以开启80端口 orz) 然后遇到自己设置的servername的时候再反向代理到本地tomcat开启的端口，比如8080 或者9090端口 mac安装nginx的功能就再说了，可以用brew安装也可以编译安装，自行百度，我好像是用brew安装的 我web开发工具用的是idea,怎么建tomcat也不说了，不是这篇文章的目的,tomcat的端口的话就用默认的8080就可以了。 修改nginx的配置文件nginx.conf 如果路径不一样的，自行更改 1$ sudo vim /usr/local/etc/nginx/nginx.conf 重要的都用箭头标出来了 listen 80：表示nginx监听80端口 server_name : 可以有多个 这里需要注意的是 每个域名要在hosts文件中绑定IP到127.0.0.1 不然还是拦截不到的 这点需要注意 access_log: 访问日志 可以打开 打开的话要把后面的main去掉 location： / 拦截所有访问本地80端口的路径 这是个正则表达式 有兴趣的可以去搜搜看 可以写成其他的正则 proxy_pass http://127.0.0.1:8080 这句就是核心了 将访问的80端口导到本地的8080端口(我的本地tomcat开启的端口) 开启nginx 1$ sudo nginx 大功告成！","tags":[]},{"title":"mysql禁用validate_password插件","date":"2017-04-14T02:36:01.000Z","path":"2017/04/14/mysql禁用validate_password插件/","text":"新版本的MySQL默认开启了validate_password插件，进行密码验证，需要很强的密码强度才能通过认证，如果是自己玩玩的话没必要那么复杂，如果是公司的话，还是不要禁用了。其实关闭插件很简单，在mysql配置文件(centos系统下是/etc/my.conf)里面[mysqld]选项下面添加下面一条语句即可 1validate_password=off 记得配置后要重启mysql.在shell下面运行下面两条语句： 12service mysqld stop service mysqld start 如果不想关闭，而是想修改密码强度的话，可以看看下面这篇文档，我就不多做解释了。http://dev.mysql.com/doc/refman/5.6/en/validate-password-plugin.html#option_mysqld_validate-password","tags":[]}]