[{"title":"Spring问题快问快答","date":"2017-12-31T12:21:34.000Z","path":"2017/12/31/Spring问题快问快答/","text":"这篇文章主要是博主平时遇到的问题 后来经过不断的学习 又被自己解决的问题 如果读者有什么问题的话 可以在下面留言 我会尽力解答 暂时没有目录 以后会想办法解决这个问题 1.@Controller与@Component注解有什么不同文章 component-scan做了些什么 最后问出的问题@Controller注解的作用只是注册普通bean 这是spring团队为了适应mvc所写的一个注解 让人一看就知道这是个控制器 真正起到路由作用的是@RequestMapping注解 spring会根据这个类上面有没有@RequestMapping来最终判定这个类是不是控制器 2.Tomcat中DefaultServlet拦截的路径是/ 而spring中DispatcherServlet一般拦截的路径也是/ 那为什么最后请求会给DispatcherServlet而不是DefaultServlet呢?如果有除了tomcat自带的DefaultServlet外的servlet的拦截路径也是/的话 这个servlet会被设置为默认servlet(defaultServlet) 相当于覆盖了tomcat自带的servlet 对于寻找请求的处理servlet 有专门的一套逻辑去处理 3.servlet过滤器 spring过滤器有什么不同 待解 4.@Before @Around @After的执行顺序?如果我们把@Around注解方法拆分为三块：around.before,proxyed_method(被代理的方法 即调用proceedingJoinPoint.proceed()那部分),around.after 那么执行顺序为: before_advice-&gt;around.before-&gt; proxyed_method-&gt;around.after-&gt;after 至于执行结果为什么是这样的 可以看下面的博文 @Before @Around @After的执行顺序源码解析 5.Spring的父子容器介绍我们通常说的父子容器是在web环境中 自然形成的 ContextLoaderListener加载的是父容器 而由DispatcherServlet加载的是子容器 就像java语言中父子关系一样 子类可以获得父类的属性 但父类不能活的子类的属性 详情请点击 spring web环境的加载 6.Spring类路径到底指的是什么路径网上的答案也是众说纷纭 让大家也是很苦恼 不知道相信哪一个 这个时候最好的解决办法就是找办法验证 通过测试去解决 在这里教大家一个更好的解决办法(maven spring web环境) 把你的web项目打包 然后看打包后的目录结构 你会发现main/resources目录下的配置文件都被放在了WEB_INF下 跟 classes 目录同级结构 这个时候我想一切就都明白了 7.控制器Controller 是单例模式吗默认情况下是的 Controller就是一个普通的Bean 只是在RequestMapping注解的作用下 具有了控制器的作用 但这并不改变Controller作为一个普通的Bean的作用 8.为什么@Value(&quot;${name}&quot;)中 ${name}没有解析成对应的value值这个问题就需要知道@Value注解是怎么被处理的 博主先把碰到的问题的场景叙述出来 我遇到的这个场景可能稍微有点复杂 todo 9.为什么@Autowired注解不能用在静态成员变量todo","tags":[]},{"title":"PropertyPlaceholderConfigurer源码解析","date":"2017-05-31T07:36:05.000Z","path":"2017/05/31/PropertyPlaceholderConfigurer源码解析/","text":"这篇文章我们介绍一个常用的BFPP来消除我们心中的对BFPP的陌生感在spring配置文件中 读者一定经常遇到过${xxx}的写法 然后spring会帮我们替换成properties中对应的value值 那么这个变量是什么时候又是被哪个类替换的呢在文章ClassPathXmlApplicationContext源码解析三:BFPP中我们提到了BFPP的概念 BFPP的全称是BeanFactoryPostProcessor是工厂级别的处理器 它的调用时间点是在将配置文件转化为BeanDefinition之后 加载成bean之前调用的我们先看下配置文件123456789&lt;bean id=&quot;dev_propertyPlace&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;2&quot;/&gt; &lt;property name=&quot;ignoreUnresolvablePlaceholders&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;locations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:config-sunms-dev.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 在使用这个bfpp之前当然是先获取这个bean 处理一些事情 比如将locations对应的string转化成需要的resource类型既然是bfpp 那么我们的阅读入口就好找了 PropertyResourceConfigurer##postProcessBeanFactory()方法12345678910111213public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; try &#123; //加载properties文件 Properties mergedProps = mergeProperties(); convertProperties(mergedProps); //替换 processProperties(beanFactory, mergedProps); &#125; catch (IOException ex) &#123; throw new BeanInitializationException(&quot;Could not load properties&quot;, ex); &#125;&#125; spring的代码一直这么优雅 高度抽象 让人一看就知道要做什么事情第一步就是加载我们指定的properties文件 第二步默认没有做什么事情最后一步就是重点了123456protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess, Properties props) throws BeansException &#123; StringValueResolver valueResolver = new PlaceholderResolvingStringValueResolver(props); doProcessProperties(beanFactoryToProcess, valueResolver);&#125; 先是构建一个处理类 处理类不过是提供一些方法 定义了诸如前缀${ 后缀} 使后面的代码更简洁 然后交给doProcessProperties处理123456789101112131415161718192021222324252627protected void doProcessProperties(ConfigurableListableBeanFactory beanFactoryToProcess, StringValueResolver valueResolver) &#123; BeanDefinitionVisitor visitor = new BeanDefinitionVisitor(valueResolver); String[] beanNames = beanFactoryToProcess.getBeanDefinitionNames(); for (String curName : beanNames) &#123; // Check that we&apos;re not parsing our own bean definition, // to avoid failing on unresolvable placeholders in properties file locations. if (!(curName.equals(this.beanName) &amp;&amp; beanFactoryToProcess.equals(this.beanFactory))) &#123; BeanDefinition bd = beanFactoryToProcess.getBeanDefinition(curName); try &#123; visitor.visitBeanDefinition(bd); &#125; catch (Exception ex) &#123; throw new BeanDefinitionStoreException(bd.getResourceDescription(), curName, ex.getMessage(), ex); &#125; &#125; &#125; // New in Spring 2.5: resolve placeholders in alias target names and aliases as well. beanFactoryToProcess.resolveAliases(valueResolver); // New in Spring 3.0: resolve placeholders in embedded values such as annotation attributes. // 处理如@Value(&quot;$&#123;name&#125;&quot;) beanFactoryToProcess.addEmbeddedValueResolver(valueResolver); &#125; 下面的代码就比较简单了 就是处理所有的BeanDefinitioin 不包含本身 将诸如parentName等属性中的${xxx}变量替换掉1234567891011public void visitBeanDefinition(BeanDefinition beanDefinition) &#123; visitParentName(beanDefinition); visitBeanClassName(beanDefinition); visitFactoryBeanName(beanDefinition); visitFactoryMethodName(beanDefinition); visitScope(beanDefinition); visitPropertyValues(beanDefinition.getPropertyValues()); ConstructorArgumentValues cas = beanDefinition.getConstructorArgumentValues(); visitIndexedArgumentValues(cas.getIndexedArgumentValues()); visitGenericArgumentValues(cas.getGenericArgumentValues());&#125; 有趣的是最后一行代码1beanFactoryToProcess.addEmbeddedValueResolver(valueResolver); 这句代码把构建好的工具类加入到了beanFactory中 是spring3.0加入的 加入的作用就是处理诸如@Value注解的时候 如果有${xxx}的形式的话 会被这个工具类给替换掉 这个在@Autowired注解工作原理源码解析的时候 我们会再提到","tags":[{"name":"BFPP","slug":"BFPP","permalink":"http://yoursite.com/tags/BFPP/"}]},{"title":"aop源码解析二:寻找Advisor","date":"2017-05-23T04:34:05.000Z","path":"2017/05/23/aop源码解析二-寻找Advisor/","text":"写在前面这一部分的内容 会比较多 如果只是看代码的话 可能不够直观 所以这个时候我们就需要使出程序员必备技能DEBUG 当然前提是你已经搭建好了环境 如果没有话 请点击Spring源码分析环境搭建我们分析的这一部分的代码 spring中已经有了相关的测试类AspectJAutoProxyCreatorTests 相信结合下面的分析的话 读者是能够看懂这部分代码的.","tags":[{"name":"aop","slug":"aop","permalink":"http://yoursite.com/tags/aop/"}]},{"title":"aop源码解析一:注册BPP","date":"2017-05-22T05:25:52.000Z","path":"2017/05/22/aop源码解析一/","text":"本文目的如题,标签&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; expose-proxy=&quot;true&quot;/&gt;注册BPP(AspectJAutoProxyBeanDefinitionParser)源码分析 并没有介绍过BPP相关内容 这里简单的讲解下 读者心里有个概念就行 等有时间补写Bean的加载与读取的时候 会好好介绍这个重要的类!首先 spring在一些特殊的位置插入了一些处理代码(可能有些读者觉得这句话很眩 不太好理解 我换种表达方式:从加载配置文件到转换成对应的定义类 比如BeanDefinition 再到获取bean 这一整个过程都是spring在做的 他当然能够在任意想插的位置插入代码了) 例如在实例化前后 或者在初始化前后调的方法 这些类一般是BeanPostProcessor的子类 简称BPP 正文对于aop这样的非标准或者称为自定义命名空间的元素 spring会从spring.handlersspring.handlers文件中的对应关系找到相应的处理类 然后通过init()方法注册一些处理器 aop命名空间的处理类是AopNamespaceHandler 我们看一下他的init()方法 public void init() { // In 2.0 XSD as well as in 2.1 XSD. registerBeanDefinitionParser(&quot;config&quot;, new ConfigBeanDefinitionParser()); // registerBeanDefinitionParser(&quot;aspectj-autoproxy&quot;, new AspectJAutoProxyBeanDefinitionParser()); registerBeanDefinitionDecorator(&quot;scoped-proxy&quot;, new ScopedProxyBeanDefinitionDecorator()); // Only in 2.0 XSD: moved to context namespace as of 2.1 registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser()); } 从上面注册的处理器的关系我们知道 &lt;aop:aspectj-autoproxy&gt;标签的处理器是AspectJAutoProxyBeanDefinitionParser 同样 这是一个继承于BeanDefinitionParser的标准的解析器 我们看一下他的parse()方法 public BeanDefinition parse(Element element, ParserContext parserContext) { //注册BPP(AnnotationAwareAspectJAutoProxyCreator) AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element); // 如果有子元素的话 设置属性 extendBeanDefinition(element, parserContext); return null; } parse()方法可以说主要做了一件事情就是注册了一个BPP(BeanPostProcessor) 供后续使用 有些人看到这里可能就蒙圈了 这什么东西 名字这么长 看到后面的时候又会说这是什么东西 类的名字这么长 然后就会觉得好难 主要是读者阅读代码不多的原因 如果阅读的多了 你就会形成一个感觉：不管这个类名字多奇怪 名字多长 不过是一些基本类型(map list等)的包装而已 为了完成某一个功能所做的封装而已 //spring中的方法一般都比较清晰 短短的几行代码告诉了你这个方法要做什么事情 public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary( ParserContext parserContext, Element sourceElement) { //注册BPP(AnnotationAwareAspectJAutoProxyCreator) BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary( parserContext.getRegistry(), parserContext.extractSource(sourceElement)); //根据xml配置 设置AnnotationAwareAspectJAutoProxyCreator的proxyTargetClass exposeProxy属性 useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement); //注册组件bean 并暴露给外部 registerComponentIfNecessary(beanDefinition, parserContext); } 不断的追踪registerAspectJAnnotationAutoProxyCreatorIfNecessary()方法发现 就是注册了个BPP(AspectJAutoProxyBeanDefinitionParser) 不再贴出相关代码 我们看下useClassProxyingIfNecessary()方法 //处理proxy-target-class 以及 expose-proxy属性 private static void useClassProxyingIfNecessary(BeanDefinitionRegistry registry, Element sourceElement) { if (sourceElement != null) { //proxy-target-class true:强制使用CGLIB代理 推荐使用 boolean proxyTargetClass = Boolean.valueOf(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE)); if (proxyTargetClass) { AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry); } //expose-proxy true:暴露代理类 解决某些情况下 代理无法完成的情况 boolean exposeProxy = Boolean.valueOf(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE)); if (exposeProxy) { AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry); } } } 总结似乎&lt;aop:aspectj-autoproxy&gt;标签做的事情并不多 只是注册了一个BPP 但是这个BPP确实非常重要的! 我们用到的切面编程就依靠这个BPP去驱动实现 后面的文章会介绍这个BPP的源码是怎么实现AOP的","tags":[{"name":"aop","slug":"aop","permalink":"http://yoursite.com/tags/aop/"}]},{"title":"aop功能实现口述","date":"2017-05-20T10:22:15.000Z","path":"2017/05/20/aop功能实现口述/","text":"spring-aop功能 涉及到的东西很多 比如 切面 CGLIB 责任链等 这些东西会讲到 但不会详细讲解 一来是因为篇幅限制 另外博客的目的还是授人以鱼不如授人以渔 为了让大家能阅读下面几篇关于aop的文章更顺利些 这里先给读者讲一下 spring实现aop大概的流程以及涉及到的一些名词 因为注解形式的友好性 大家用的比较多 所以我们只谈这种形式的实现 aop 面向切面编程(AOP) :面向对象编程(OOP)的一种扩展 可以这样理解 我们之前所做的所有功能大体来说都是线性的(好比在流淌在水管里的水 一直是往前流动的 很难纵向扩展) 如果我们想加一些公共的服务 比如说日志 登录检查等 OOP将会有大量的重复代码 pointcut 连接点 就是这些额外的动作的发生点 advice 切面 就是我们上面说的那些公共服务 比如说日志 登录检查等 advisor 我们这里说的advisor 是实现代码里面的advisor 是一个封装类 包括了pointcut(验证是否跟指定方法匹配的功能) 与 advice 流程: 我们暂时把spring加载bean的过程笼统的分为两个阶段 spring加载配置文件并根据配置文件或者注解生成BeanDefinition的过程。 BeanDefinition看这个词的意思就略知一二 如果你看过tomcat的源码的话 应该会让你想起servletconfig 主要是用来保存bean的配置信息 如果bean是prototype类型的 那么下次就不用在加载了 spring提前加载非懒惰的bean的过程 很显然 aop的实现就是在第二个阶段 bean有几个比较特殊的阶段 比如实例化(instantiate) 初始化(initiate) 那么就可以在这几个特殊阶段的前后加一些方法 实现扩展 spring在bean初始化完成后的时机 完成了 找出所有切面类的切面方法 未完","tags":[{"name":"aop","slug":"aop","permalink":"http://yoursite.com/tags/aop/"}]},{"title":"@Autowired注解工作原理源码解析","date":"2017-05-14T03:31:11.000Z","path":"2017/05/14/Autowired注解工作原理源码解析/","text":"spring框架提供的便利的注解方式的注入 大大方便了程序员的编程 但从另外一个方面来看 spring把功能细节隐藏的更深了 对技术有点追求的人 一定会很好奇spring注解的工作的方式 这篇博客就以@Autowired注解为例来讲解@Autowired注解是这么工作的 (其他注解如@Resource @Required注解的工作原理一样)component-scan做了些什么:源码解读这篇博客的最后有介绍到注册了一些注解处理器BPP 我们再看下这个方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors( BeanDefinitionRegistry registry, Object source) &#123; Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(4); // @Configuration if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; //@Autowired @Value if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; //@Required if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; //@PostConsruct @Resouce 等java注解 // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor. if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; // // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor. if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(); try &#123; def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, AnnotationConfigUtils.class.getClassLoader())); &#125; catch (ClassNotFoundException ex) &#123; throw new IllegalStateException( &quot;Cannot load optional framework class: &quot; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex); &#125; def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; return beanDefs;&#125; 注解以及对应的后置处理器如下表所示 注解 BPP @Configuration ConfigurationClassPostProcessor @Autowired,@Value,@Inject AutowiredAnnotationBeanPostProcessor @Required RequiredAnnotationBeanPostProcessor @Postconstruct,PreDestroy,@Resource CommonAnnotationBeanPostProcessor @Persistence PersistenceAnnotationBeanPostProcessor","tags":[]},{"title":"LimitLatch源码解析","date":"2017-05-13T09:59:57.000Z","path":"2017/05/13/LimitLatch源码解析/","text":"","tags":[]},{"title":"ClassPathXmlApplicationContext源码解析五:加载单例","date":"2017-05-12T01:03:38.000Z","path":"2017/05/12/ClassPathXmlApplicationContext源码解析五-加载单例/","text":"在refresh()方法中 最重要的方法有两个 分别是obtainFreshBeanFactory()与 finishBeanFactoryInitialization(beanFactory) 第一个方法我们已经讲解过了 现在我们看下第二个方法123456789101112131415protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123; if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123; beanFactory.setConversionService( beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)); &#125; String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false); for (String weaverAwareName : weaverAwareNames) &#123; getBean(weaverAwareName); &#125; beanFactory.setTempClassLoader(null); beanFactory.freezeConfiguration(); //重要 实例化所有的非懒惰加载的bean beanFactory.preInstantiateSingletons();&#125; 到beanFactory.freezeConfiguration()这里的时候 就不再允许改变配置文件了 因为可能会影响到后面的加载过程如果bean是单例模式 并且没有设置懒惰加载的话 就预先实例化这个bean 调用DefaultListableBeanFactory#preInstantiateSingletons()方法 DefaultListableBeanFactory是个很重要的类 承载了很多功能 读者可以借助编辑器查看下这个类的继承关系12345678910111213141516171819202122232425262728293031323334353637public void preInstantiateSingletons() throws BeansException &#123; if (this.logger.isInfoEnabled()) &#123; this.logger.info(&quot;Pre-instantiating singletons in &quot; + this); &#125; List&lt;String&gt; beanNames; synchronized (this.beanDefinitionMap) &#123; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames); &#125; // 循环检查所有的bean 并按情况加载 for (String beanName : beanNames) &#123; RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123; //如果是工厂bean if (isFactoryBean(beanName)) &#123; final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName); boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123; isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123; public Boolean run() &#123; return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit(); &#125; &#125;, getAccessControlContext()); &#125; else &#123; isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit()); &#125; if (isEagerInit) &#123; getBean(beanName); &#125; &#125; else &#123; getBean(beanName); &#125; &#125; &#125;&#125; 对于beanFactory中的每一个bean 先根据beanName获取BeanDefinition 因为我们所需要的属性等都在这个类里面了 调用getMergedLocalBeanDefinition(beanName) 方法获得 这里需要考虑的一个问题就是如果设置了parent属性的话(在由xml文件载入BeanDefinition的时候 parent属性被当作普通属性来对待 并没有做什么特殊处理)1&lt;bean id=&quot;xxx&quot; class=&quot;com.xxx.xxx&quot; parent=&quot;TestXXX&quot;/&gt; 那么就需要跟parent所指向的BeanDefinition的配置属性合并后再返回了. 当然这里肯定是个递归调用 因为parent本身可能也定义了自己的parent属性 合并的原则是先拷贝父类的所有属性元素,然后与子类的合并,如果有属性名一样的话,则覆盖.在满足下面三个条件的时候 才会尝试加载 不是抽象类 单例模式 没有设置懒惰加载 如果是FactoryBean的话 那么就需要考虑是返回FactoryBean本身 还是返回FactoryBean#getObect()方法返回的对象 spring约定 如果要返回FactoryBean本身 那么需要在beanName前加上约定的&amp;符号 否则就是返回T getObject() 我们看一下FactoryBean的接口定义 很显然 这是利用了工厂方法12345public interface FactoryBean &#123; T getObject() throws Exception; Class&lt;?&gt; getObjectType(); boolean isSingleton();&#125; 下面的源码内容 对于读者来说 比较难理解 对于作者本人来说比较难讲解 一个是涉及到的内容比较多 比如 FactoryBean 循环依赖 代理 属性填充 BPP 寻找构造函数等 另外一个是功能间咬合比较多 下文介绍的时候 我们就不考虑那么多 先把最简单的情况介绍到 如下面的代码实例:第一次加载 有默认构造函数 TestA中有一个java基本类型 一个引用类型 init-method属性, 在了解加载TestA的加载的基础上 再去了解那些扩展功能 当然对于TestA的加载其实过程很简单 简单叙述来说 就是根据TestA.class实例化TestA 这里用的是默认的构造函数 然后是属性的填充 调用init()方法等 1234567891011121314151617181920212223242526272829303132public class TestA&#123; private String a; private TestB b; @Autowired private TestC c; // getXXX setXXX public void init()&#123; System.out.println(&quot;Hello World&quot;); &#125;&#125;public class TestB&#123; private int c;&#125;____________________________......&lt;!-- --&gt; &lt;component:scan basepackage=&quot;com.xxx.xxx&quot;/&gt;&lt;bean id=&quot;testA&quot; class=&quot;com.xxx.xxx.TestA&quot;&gt; &lt;property name=&quot;b&quot; ref=&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;testB&quot; class=&quot;com.xxx.xxx.TestB&quot;/&gt;&lt;bean id=&quot;testC&quot; class=&quot;com.xxx.xxx.TestC&quot;/&gt;...... AbstractBeanFactory#doGetBean(...)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152protected &lt;T&gt; T doGetBean( final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123; // 如果是别名 就返回对应的真实的beanName // 如果以&amp;开头 先去除 final String beanName = transformedBeanName(name); Object bean; // Eagerly check singleton cache for manually registered singletons. Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isDebugEnabled()) &#123; if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.debug(&quot;Returning eagerly cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos; that is not fully initialized yet - a consequence of a circular reference&quot;); &#125; else &#123; logger.debug(&quot;Returning cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;); &#125; &#125; //todo 待看 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; //依赖分为三种依赖: 原型循环依赖 构造器循环依赖 单例循环依赖 //只有单例依赖才能解决 其他情况只能抛出异常 //原型循环依赖 无法解决 抛异常 if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; // Check if bean definition exists in this factory. BeanFactory parentBeanFactory = getParentBeanFactory(); //如果这个容器中没有bean的定义的话 去父容器中加载 if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // Not found -&gt; check parent. //还原beanName String nameToLookup = originalBeanName(name); if (args != null) &#123; // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else &#123; // No args -&gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; &#125; if (!typeCheckOnly) &#123; markBeanAsCreated(beanName); &#125; try &#123; //返回配置文件定义的bean的定义信息 GenericBeanDefinition-&gt;RootBeanDefinition final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // 先加载配置中`depend-on`属性中配置的`bean` String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; for (String dependsOnBean : dependsOn) &#123; getBean(dependsOnBean); registerDependentBean(dependsOnBean, beanName); &#125; &#125; // 单例模式 if (mbd.isSingleton()) &#123; sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; public Object getObject() throws BeansException &#123; try &#123; //核心加载部分 return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; &#125; &#125; &#125;); //获取到的bean可能是FactoryBean类型的bean bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; // 原型模式 else if (mbd.isPrototype()) &#123; // It&apos;s a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; else &#123; String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) &#123; throw new IllegalStateException(&quot;No Scope registered for scope &apos;&quot; + scopeName + &quot;&apos;&quot;); &#125; try &#123; Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123; public Object getObject() throws BeansException &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123; throw new BeanCreationException(beanName, &quot;Scope &apos;&quot; + scopeName + &quot;&apos; is not active for the current thread; &quot; + &quot;consider defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;, ex); &#125; &#125; &#125; catch (BeansException ex) &#123; cleanupAfterBeanCreationFailure(beanName); throw ex; &#125; &#125; // Check if required type matches the type of the actual bean instance. if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123; try &#123; return getTypeConverter().convertIfNecessary(bean, requiredType); &#125; catch (TypeMismatchException ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Failed to convert bean &apos;&quot; + name + &quot;&apos; to required type [&quot; + ClassUtils.getQualifiedName(requiredType) + &quot;]&quot;, ex); &#125; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; &#125; return (T) bean;&#125; 在getSingleton(beanName)的调用中 其实处理了好几种情况 是否已经加载完成过 bean的加载是个耗时的过程 加载完成后就放到map中保存 有就直接返回 没有加载完成 并且知道正在创建中 那么说明是遇到了循环依赖问题对于循环依赖问题 以后有时间会单独开一个博客讲解 这里简单介绍下 首先对于都是单例模式来说 会遇到两种循环依赖问题 构造器循环依赖 set循环依赖 举例如下 1234567891011121314//构造器循环依赖public class TestA()&#123; ... public TestA(TestB b)&#123; &#125; ...&#125;public class TestB()&#123; ... public TestB(TestA a)&#123; &#125; ...&#125; 123456789101112131415//set循环依赖public class TestA()&#123; ... @Autowired private TestB b; ...&#125;public class TestB()&#123; ... @Autowired private TestA a; ...&#125; 构造器循环依赖 是不能够被解决的 原因如下：在实例化TestA的时候需要去实例化TestB 然后去实例化TestB 然后这个时候又发现需要TestA 所以两个都不能完成实例化而对于set依赖来说 虽然也存在循环依赖 但问题却能够得到解决 解释如下：TestA实例化完成后 在给TestA填充属性的过程中发现需要TestB 存下TestA的引用 然后去获取TestB 实例化TestB后 给TestB填充属性的过程中发现需要TestA 然后再去获取TestA 之前埋入了TestA的引用 （虽然还没加载完整） 这个时候返回TestA的引用 这个时候TestB加载完成 回去继续加载TestA 这个时候循环依赖也就没有了Spring通过记录不同状态下的引用 即提前暴露地址的方式解决循环依赖在第一次讲解的时候 我们暂且不考虑那么多 我们就当成我们现在的情况是第一次加载这个bean 并且不存在循环依赖的情况 当然我们还是可以看下他们额外做了写什么 大概有个印象我们回到getSingleton(...)方法 里面有两个map 一个是earlySingletonObjects 另外一个是singletonFactories 这两个map中的东西似乎是互斥的.如果这个时候获得到了的话 就返回 然后再通过getObjectForBeanInstance处理 这个方法主要判断返回的是不是我们最终想要的 如果是FactoryBean类型的话 还需要进一步处理我们看下单例模式下的bean的加载123456789101112131415sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; public Object getObject() throws BeansException &#123; try &#123; //核心加载部分 return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; &#125; &#125; &#125;); 12345678910111213141516171819202122232425262728293031323334353637383940public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123; Assert.notNull(beanName, &quot;&apos;beanName&apos; must not be null&quot;); synchronized (this.singletonObjects) &#123; Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) &#123; if (this.singletonsCurrentlyInDestruction) &#123; throw new BeanCreationNotAllowedException(beanName, &quot;Singleton bean creation not allowed while the singletons of this factory are in destruction &quot; + &quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;); &#125; //时间节点 放入singletonsCurrentlyInCreation 代表这个bean正在加载中 beforeSingletonCreation(beanName); boolean recordSuppressedExceptions = (this.suppressedExceptions == null); if (recordSuppressedExceptions) &#123; this.suppressedExceptions = new LinkedHashSet&lt;Exception&gt;(); &#125; try &#123; singletonObject = singletonFactory.getObject(); &#125; catch (BeanCreationException ex) &#123; if (recordSuppressedExceptions) &#123; for (Exception suppressedException : this.suppressedExceptions) &#123; ex.addRelatedCause(suppressedException); &#125; &#125; throw ex; &#125; finally &#123; if (recordSuppressedExceptions) &#123; this.suppressedExceptions = null; &#125; //时间节点 从singletonsCurrentlyInCreation中清除 代表创建完成 afterSingletonCreation(beanName); &#125; //加入到singletonObjects中 从singletonFactories earlySingletonObjects中去除 addSingleton(beanName, singletonObject); &#125; return (singletonObject != NULL_OBJECT ? singletonObject : null); &#125;&#125; 我们看下singletonFactory回调方法createBean1234567891011121314151617181920212223242526272829303132333435protected Object createBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) throws BeanCreationException &#123; // 获取class属性 resolveBeanClass(mbd, beanName); // Prepare method overrides. try &#123; //look-method replace-method配置项检查处理 如果不清楚的可以先搜索相关使用demo mbd.prepareMethodOverrides(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, &quot;Validation of method overrides failed&quot;, ex); &#125; try &#123; // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. // todo AOP功能实现 `AnnotationAwareAspectJAutoProxyCreator` // [看另外一篇博客](http://www.sunmingshuai.cn/2017/05/22/aop%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%80/) Object bean = resolveBeforeInstantiation(beanName, mbd); if (bean != null) &#123; return bean; &#125; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex); &#125; Object beanInstance = doCreateBean(beanName, mbd, args); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Finished creating instance of bean &apos;&quot; + beanName + &quot;&apos;&quot;); &#125; return beanInstance;&#125; 如果我们有对类进行代理的话 那么返回的就是代理类 而不是裸类 这个处理就是在resolveBeforeInstantiation方法中处理的 这里不深入研究 想了解的可以看博主的另外的博客介绍 aop源码解析一:注册BPP aop源码解析二:寻找Advisor方法又转到了doCreateBean(beanName,mnb,args)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) &#123; // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) &#123; instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; //判断采用哪种实例化方法 factoryMethod | 构造器(如果有多个构造器还需要根据args判断采用哪个构造器构造) //如果有配置replace-method lookup-method 会创建代理 //注册属性编辑器 instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); // Allow post-processors to modify the merged bean definition. synchronized (mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; //todo ## BPP触发的另一个地方 如处理@AutoWired注解的AutowiredAnnotationBeanPostProcessor#postProcessMergedBeanDefinition() // [component-scan做了些什么:源码解读](http://www.sunmingshuai.cn/2017/04/28/component-scan%E5%81%9A%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/) applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); mbd.postProcessed = true; &#125; &#125; // 提前加入缓存 以辩能够解决循环引用问题 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Eagerly caching bean &apos;&quot; + beanName + &quot;&apos; to allow for resolving potential circular references&quot;); &#125; // 解决循环依赖问题的关键 提前把ObjectFactory加入进来 如果有碰到循环依赖的话 通过ObjectFactory获取bean // 因为他们代表的地址是一样的 addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123; public Object getObject() throws BeansException &#123; return getEarlyBeanReference(beanName, mbd, bean); &#125; &#125;); &#125; // 初始化bean的实例 Object exposedObject = bean; try &#123; // bean属性的填充(xml文件定义的属性 被@Autowired @Value等注解修饰 以及一些其他属性 IOC的直接体现 populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) &#123; exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; &#125; catch (Throwable ex) &#123; if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123; throw (BeanCreationException) ex; &#125; else &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex); &#125; &#125; if (earlySingletonExposure) &#123; // 再一次调用`getSingleton()`方法 只是这一次`allowEarlyReference`为false Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) &#123; if (exposedObject == bean) &#123; exposedObject = earlySingletonReference; &#125; else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123; String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length); for (String dependentBean : dependentBeans) &#123; if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123; actualDependentBeans.add(dependentBean); &#125; &#125; if (!actualDependentBeans.isEmpty()) &#123; throw new BeanCurrentlyInCreationException(beanName, &quot;Bean with name &apos;&quot; + beanName + &quot;&apos; has been injected into other beans [&quot; + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + &quot;] in its raw version as part of a circular reference, but has eventually been &quot; + &quot;wrapped. This means that said other beans do not use the final version of the &quot; + &quot;bean. This is often the result of over-eager type matching - consider using &quot; + &quot;&apos;getBeanNamesOfType&apos; with the &apos;allowEagerInit&apos; flag turned off, for example.&quot;); &#125; &#125; &#125; &#125; // Register bean as disposable. try &#123; registerDisposableBeanIfNecessary(beanName, bean, mbd); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex); &#125; return exposedObject; &#125; 这里会判断采用哪种方式实例化bean 如果采用有参构造函数的形式的话 匹配逻辑稍微有点复杂 实例化后会注册一些属性编辑器 就是把string类型的参数值能够转化为我们想要的类型值applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName)方法是spring的一个扩展方法 例如我们常用的@Autowired就在这个方法里预先处理了一下 找出该bean的标注有@Autowited所有的field与method 并放入合适的数据结构保存 我们这里就不展开讲解了addSingletonFactory这个方法逻辑不难 却意义重大 到这个阶段的时候 就把这个bean提前暴露出来了 就能够解决我们前面所说的第二种依赖了populateBean(beanName, mbd, instanceWrapper)方法的作用就是bean属性的填充 我们说的IOC DI的体现就是在这里了 由spring框架给我们注入我们想要的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) &#123; PropertyValues pvs = mbd.getPropertyValues(); if (bw == null) &#123; if (!pvs.isEmpty()) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;); &#125; else &#123; // Skip property population phase for null instance. return; &#125; &#125; // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the // state of the bean before properties are set. This can be used, for example, // to support styles of field injection. boolean continueWithPropertyPopulation = true; //实例化后的后置处理器 spring框架的扩展点 if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123; continueWithPropertyPopulation = false; break; &#125; &#125; &#125; &#125; if (!continueWithPropertyPopulation) &#123; return; &#125; if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123; MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // xml文件中定义的非java基本类型依赖 在这里就注入了 byName if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123; autowireByName(beanName, mbd, bw, newPvs); &#125; // xml文件中定义的非java基本类型依赖 在这里就注入了 byType if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123; autowireByType(beanName, mbd, bw, newPvs); &#125; pvs = newPvs; &#125; boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE); // @Autowired注解实现注入就是在这里 if (hasInstAwareBpps || needsDepCheck) &#123; PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); if (hasInstAwareBpps) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvs == null) &#123; return; &#125; &#125; &#125; &#125; if (needsDepCheck) &#123; checkDependencies(beanName, mbd, filteredPds, pvs); &#125; &#125; // applyPropertyValues(beanName, mbd, bw, pvs); &#125; 这里涉及到的几个BPP我们后面会挑一个出来讲解 如@Autowired注解的实现过程 这里就不深入讨论了 属性填充完后就到了init的环节 initializeBean(beanName, exposedObject, mbd)123456789101112131415161718192021222324252627282930313233343536protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123; // 这个时间点是属性填充完了 但是还没有调用initMethod方法的阶段 if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; public Object run() &#123; invokeAwareMethods(beanName, bean); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; //如果有继承xxxAware的话 调用setXXX相应的方法 invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; //initMethod方法调用前 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; //调用initMethod 或者 afterPropertiesSet方法 invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, &quot;Invocation of init method failed&quot;, ex); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean;&#125; 这个方法相对来说比较简单 有几点说一下 读者可能用过xxxAware 然后继承setXXX方法就可以了 那么是怎么实现的呢 答案很简单 spring会判断是哪个aware 然后调用响应的set方法 即invokeAwareMethods的方法实现我们前面说过初始化方法执行前后是个特殊的时间节点 spring自然不会忘记在其执行前后添加一些扩展点 就是调用BPP的扩展方法对于初始化来说 spring提供了一个类似功能的接口供我们继承InitializingBean123public interface InitializingBean &#123; void afterPropertiesSet() throws Exception;&#125; 跟init-method要实现的功能差不多初始化完成后 bean的加载基本上就算完成了","tags":[{"name":"context","slug":"context","permalink":"http://yoursite.com/tags/context/"}]},{"title":"常用命令行命令详解","date":"2017-05-07T01:58:35.000Z","path":"2017/05/07/常用命令行命令详解/","text":"","tags":[]},{"title":"ClassPathXmlApplicationContext源码解析四","date":"2017-05-04T03:38:03.000Z","path":"2017/05/04/ClassPathXmlApplicationContext源码解析四/","text":"我们回到refresh()方法 继续往下解读 下面这几个方法比较简洁 或者说简单 我们只是简单的列出 就不再作过多解读饿了1234567891011// spring可扩展的另一个实现:BeanPostProcessor 在调用beanClass实例化前后或者调用initMethod方法的前后会调用接口方法// 较常见的硬编码的BPP:ApplicationContextAwareProcessor,ApplicationListenerDetectorregisterBeanPostProcessors(beanFactory);//国际化initMessageSource();//广播initApplicationEventMulticaster();//emptyonRefresh();// 注册listenerregisterListeners(); registerBeanPostProcessors(beanFactory)方法是把BeanFactory中声明的BeanPostProcessor的实例加入到beanFactory中 注意此时的BeanPostProcessor并没有成形 还停留在BeanDefinition初级阶段 这个时候我们要通过beanFactory.getBean(name,requiredType)方法获取BeanPostProcessor实例 然后再加入到beanFactory中 getBean(name,requiredtype)是个很复杂很重要的方法 后面我们会讲到 component-scan做了些什么:源码解读 文章最后介绍的一个方法registerComponents()有介绍到注册的一些处理注解的BPPinitApplicationEventMulticaster()方法用来注册一个广播器onRefresh()方法留空 留给字类继承实现registerListeners() 将相关listener加入到我们上面生成的applicationEventMulticaster中","tags":[{"name":"context","slug":"context","permalink":"http://yoursite.com/tags/context/"}]},{"title":"ClassPathXmlApplicationContext源码解析三:BFPP","date":"2017-04-29T01:31:38.000Z","path":"2017/04/29/ClassPathXmlApplicationContext源码解析三-BFPP/","text":"让我们再回到refresh()方法 继续往下看 看下面两个方法123456789...//如果是XmlWebApplicationContext的话 会注册一些BPP 例如ServletContextAwareProcessor// 这里留空 postProcessBeanFactory(beanFactory); // spring扩展的实现(容器级别) BeanFactoryPostProcessor 在实例化任何用户定义的bean之前 会首先调用BFPP的接口方法 // 常见的BFPP:PropertyPlaceholderConfigurer invokeBeanFactoryPostProcessors(beanFactory);... 12345//BFPP接口public interface BeanFactoryPostProcessor &#123; void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;&#125; invokeBeanFactoryPostProcessors方法逻辑就比较简单了 就是调用BFPP的接口方法 这些BFPP的来源途径有 硬编码方式 用户配置 容器自身为了完成某些功能添加这些BFPP支持排序 排序大的先调用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123; // Invoke BeanDefinitionRegistryPostProcessors first, if any. Set&lt;String&gt; processedBeans = new HashSet&lt;String&gt;(); if (beanFactory instanceof BeanDefinitionRegistry) &#123; BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory; //BFPP(postProcessBeanFactory) List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new LinkedList&lt;BeanFactoryPostProcessor&gt;(); //BeanDefinitionRegistryPostProcessor 是BFPP的子类 List&lt;BeanDefinitionRegistryPostProcessor&gt; registryPostProcessors = new LinkedList&lt;BeanDefinitionRegistryPostProcessor&gt;(); //硬编码方式加入的BFPP 例如通过addXXX for (BeanFactoryPostProcessor postProcessor : getBeanFactoryPostProcessors()) &#123; if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123; BeanDefinitionRegistryPostProcessor registryPostProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor; registryPostProcessor.postProcessBeanDefinitionRegistry(registry); registryPostProcessors.add(registryPostProcessor); &#125; else &#123; regularPostProcessors.add(postProcessor); &#125; &#125; //处理配置中的BDRPP Map&lt;String, BeanDefinitionRegistryPostProcessor&gt; beanMap = beanFactory.getBeansOfType(BeanDefinitionRegistryPostProcessor.class, true, false); List&lt;BeanDefinitionRegistryPostProcessor&gt; registryPostProcessorBeans = new ArrayList&lt;BeanDefinitionRegistryPostProcessor&gt;(beanMap.values()); OrderComparator.sort(registryPostProcessorBeans); for (BeanDefinitionRegistryPostProcessor postProcessor : registryPostProcessorBeans) &#123; postProcessor.postProcessBeanDefinitionRegistry(registry); &#125; invokeBeanFactoryPostProcessors(registryPostProcessors, beanFactory); invokeBeanFactoryPostProcessors(registryPostProcessorBeans, beanFactory); invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory); processedBeans.addAll(beanMap.keySet()); &#125; else &#123; // Invoke factory processors registered with the context instance. invokeBeanFactoryPostProcessors(getBeanFactoryPostProcessors(), beanFactory); &#125; // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false); // Separate between BeanFactoryPostProcessors that implement PriorityOrdered, // Ordered, and the rest. List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;BeanFactoryPostProcessor&gt;(); List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;String&gt;(); List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;String&gt;(); for (String ppName : postProcessorNames) &#123; if (processedBeans.contains(ppName)) &#123; // skip - already processed in first phase above &#125; else if (isTypeMatch(ppName, PriorityOrdered.class)) &#123; priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)); &#125; else if (isTypeMatch(ppName, Ordered.class)) &#123; orderedPostProcessorNames.add(ppName); &#125; else &#123; nonOrderedPostProcessorNames.add(ppName); &#125; &#125; // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered. OrderComparator.sort(priorityOrderedPostProcessors); invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory); // Next, invoke the BeanFactoryPostProcessors that implement Ordered. List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;BeanFactoryPostProcessor&gt;(); for (String postProcessorName : orderedPostProcessorNames) &#123; orderedPostProcessors.add(getBean(postProcessorName, BeanFactoryPostProcessor.class)); &#125; OrderComparator.sort(orderedPostProcessors); invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory); // Finally, invoke all other BeanFactoryPostProcessors. List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;BeanFactoryPostProcessor&gt;(); for (String postProcessorName : nonOrderedPostProcessorNames) &#123; nonOrderedPostProcessors.add(getBean(postProcessorName, BeanFactoryPostProcessor.class)); &#125; invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);&#125; 上面的代码逻辑很简单 就不再解释了 下面我们介绍一个常用的BFPP: PropertyPlaceholderConfigurer 先看一下常用的配置123456789&lt;bean name=&quot;official&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;100&quot; /&gt; &lt;property name=&quot;ignoreUnresolvablePlaceholders&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;locations&quot;&gt; &lt;list&gt; &lt;value&gt;file:$&#123;user.home&#125;/config/official.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; PropertyPlaceholderConfigurer是用来在BeanClass实例化之前调用的,通过载入指定properties文件,替换诸如${}这种形式的变量.PropertyPlaceholderConfigurer可以用来区分生产环境与开发环境 例如我们在生产环境部署official.properties文件 这个文件中的参数值 如jdbc.url 代表的是生产环境的value 然后我们在开发环境中部署developer.properties文件 这个文件中的参数值 如jdbc.url 代表的是开发环境的value 这样我们的项目发布在什么环境读取的就是相应环境的变量值 不需要每次改代码去解决PropertyPlaceholderConfigurer的功能实现我们大概能猜的到 首先肯定是先获取这个Bean 这个步骤会涉及到Bean的实例化 属性填充等操作 我们暂且略过这个步骤 后面会详细介绍 然后就是读取配置的properties文件 再然后就是替换Bean属性中的${xx}","tags":[{"name":"context","slug":"context","permalink":"http://yoursite.com/tags/context/"}]},{"title":"component-scan做了些什么:源码解读","date":"2017-04-28T09:35:35.000Z","path":"2017/04/28/component-scan做了些什么/","text":"本文目的本文主要解决一个问题就是component-scan会扫描注册哪些注解标注的类 被@Controller标注的类会被扫描注册吗? 当然本文也可以当作spring解析非默认空间下元素的一个教程 正文当遇到component-scan这样非标准或者称为自定义的元素标签时 spring会通过spring.handlers文件中的对应关系http\\://www.springframework.org/schema/context= org.springframework.context.config.ContextNamespaceHandler找到ContextNamespaceHandler 通过ContextNamespaceHandler类init()方法自动注册一些解析器 下面列出了所有以context为命名空间的组合 例如常见的&lt;context:componet-scan&gt;元素 根据注册对应关系 知道其对应的解析器为ComponentScanBeanDefinitionParser public void init() { registerBeanDefinitionParser(&quot;property-placeholder&quot;, new PropertyPlaceholderBeanDefinitionParser()); registerBeanDefinitionParser(&quot;property-override&quot;, new PropertyOverrideBeanDefinitionParser()); registerBeanDefinitionParser(&quot;annotation-config&quot;, new AnnotationConfigBeanDefinitionParser()); registerBeanDefinitionParser(&quot;component-scan&quot;, new ComponentScanBeanDefinitionParser()); registerBeanDefinitionParser(&quot;load-time-weaver&quot;, new LoadTimeWeaverBeanDefinitionParser()); registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser()); registerBeanDefinitionParser(&quot;mbean-export&quot;, new MBeanExportBeanDefinitionParser()); registerBeanDefinitionParser(&quot;mbean-server&quot;, new MBeanServerBeanDefinitionParser()); } 那我们看一下&lt;context:component-scan&gt;的解析器ComponentScanBeanDefinitionParser的源码 (ComponentScanBeanDefinitionParser继承自BeanDefinitionParser) spring解析&lt;context:component-scan&gt;的时候会调用ComponentScanBeanDefinitionParser的parse()函数 //element 代表的是完整的&lt;context:component-scan&gt;标签 //parserContext 解析的上下文环境 能拿到一些诸如readerContext registry等变量 public BeanDefinition parse(Element element, ParserContext parserContext) { //将指定base-package拆分成string数组的形式 String[] basePackages = StringUtils.tokenizeToStringArray(element.getAttribute(BASE_PACKAGE_ATTRIBUTE), ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); // 根据xml配置或者默认配置(如果没有指定的话)配置扫描器ClassPathBeanDefinitionScanner ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element); //scanner扫描包下面含有特殊注解标注的类 //@Component @Named @ManagedBean (@Controller @Service @Repository @Configuration)都会被注册 Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages); // 注册组件以及一些我们常见的注解处理器(BPP) 如@Resouce @Autowired @Configuration @Value @Required @PostConstruct //那么以后看到属性注入(IOC/DI)的时候 就不会奇怪 这些注解的处理器(BPP)是在哪里注册的了 在这里! registerComponents(parserContext.getReaderContext(), beanDefinitions, element); return null; } 看一下scanner的创建以及设置 protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) { XmlReaderContext readerContext = parserContext.getReaderContext(); boolean useDefaultFilters = true; if (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) { useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)); } // 生成scanner的时候 在其父类构造函数中调用了`registerDefaultFilters()`方法中加入了3个注解类型的typeFilter 分别是@Component // @ManagedBean @Named 意思也就是看类上面有没有这三个注解或者注解的元注解中是否含有这三个注解之一 // 这里虽然没有加入如@Service的注解 但看@Service的定义会发现@Service注解也被@Component给标注了 ClassPathBeanDefinitionScanner scanner = createScanner(readerContext, useDefaultFilters); scanner.setResourceLoader(readerContext.getResourceLoader()); scanner.setEnvironment(parserContext.getDelegate().getEnvironment()); // 利用spring 启动的时候根据xml文件或者默认配置(如果没有指定的话)生成的BeanDefinition规则 scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults()); scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns()); if (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) { scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE)); } try { // 扫描注解定义的bean 需要定义一种beanName的生成规则 一般是驼峰命名法 parseBeanNameGenerator(element, scanner); } catch (Exception ex) { readerContext.error(ex.getMessage(), readerContext.extractSource(element), ex.getCause()); } try { // bean的scope singleton?prototype? parseScope(element, scanner); } catch (Exception ex) { readerContext.error(ex.getMessage(), readerContext.extractSource(element), ex.getCause()); } // 根据xml配置生成includeFilter excludeFilter 在创建scanner类的时候 就硬编码进去了3个注解类型 // 的typeFilter到includeFilter里面 // 类必须满足以下条件才会被注册 因为@Component等是被硬编码进去的 所以只有下面一种情况才会被注册了 // 不被excludeFilter匹配 并且被includeFilter匹配 parseTypeFilters(element, scanner, readerContext, parserContext); return scanner; } 下面在看一下真正的扫描过程doScan 我们发现spirng中真正干活的一般都是以do开头 前面的那么多只是为了做铺垫 单一职责 protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) { Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;); Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(); for (String basePackage : basePackages) { //寻找被@Component或者@Named注解标注的类 或者 类的注解的元注解中含有这两个注解 例如常见的@Respsitory @Controller @Service Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); // 对于生成的AnnotatedBeanDefinition做一些转化工作 例如前面说到的应用bd(BeanDefinition)默认配置 // 处理@Primary @Lazy @DependsOn @Role注解等 // 转化成BeanDefinitionHolder对象 for (BeanDefinition candidate : candidates) { ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) { postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); } if (candidate instanceof AnnotatedBeanDefinition) { AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); } if (checkCandidate(beanName, candidate)) { BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); //注册到容器中 registerBeanDefinition(definitionHolder, this.registry); } } } return beanDefinitions; } 看一下findCandidateComponents方法 public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) { Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;BeanDefinition&gt;(); try { String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + &quot;/&quot; + this.resourcePattern; //这里的resouces代表的就是路径下的各个类了 Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath); boolean traceEnabled = logger.isTraceEnabled(); boolean debugEnabled = logger.isDebugEnabled(); for (Resource resource : resources) { if (traceEnabled) { logger.trace(&quot;Scanning &quot; + resource); } if (resource.isReadable()) { try { // 这一步的作用就是能够不必加载class但能拿到class各种属性 并且这里也不能载入class(有很多是单例模式) 还没到那一步 // 只是为了做匹配 生成bd而已 MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); // 根据includeFilters excludeFilters做匹配 因为篇幅的限制 不详谈 有兴趣的可以研究一下typeFilter的实现 if (isCandidateComponent(metadataReader)) { ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); if (isCandidateComponent(sbd)) { if (debugEnabled) { logger.debug(&quot;Identified candidate component class: &quot; + resource); } candidates.add(sbd); } else { if (debugEnabled) { logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource); } } } else { if (traceEnabled) { logger.trace(&quot;Ignored because not matching any filter: &quot; + resource); } } } catch (Throwable ex) { throw new BeanDefinitionStoreException( &quot;Failed to read candidate component class: &quot; + resource, ex); } } else { if (traceEnabled) { logger.trace(&quot;Ignored because not readable: &quot; + resource); } } } } catch (IOException ex) { throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, ex); } return candidates; } 到这里 我们算是差不多看完了scanner的扫描注册过程 扫描注册过程不过循环base-package路径下面的所有类 看是否有标注特定注解(硬编码)的类 将这些类转化成bd 供我们后续使用 这里要注意的就是这里不能将类实例化我们再回到ComponentScanBeanDefinitionParser的parse()方法 看下registerComponents()方法registerComponents()方法中除了组件外 还有一个比较重要的事情 就是注册我们后面属性填充(IOC)需要用到的一些BPP 例如@Resouce @Autowired等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 protected void registerComponents( XmlReaderContext readerContext, Set&lt;BeanDefinitionHolder&gt; beanDefinitions, Element element) &#123; Object source = readerContext.extractSource(element); CompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), source); for (BeanDefinitionHolder beanDefHolder : beanDefinitions) &#123; compositeDef.addNestedComponent(new BeanComponentDefinition(beanDefHolder)); &#125; // Register annotation config processors, if necessary. // 默认注册 boolean annotationConfig = true; if (element.hasAttribute(ANNOTATION_CONFIG_ATTRIBUTE)) &#123; annotationConfig = Boolean.valueOf(element.getAttribute(ANNOTATION_CONFIG_ATTRIBUTE)); &#125; if (annotationConfig) &#123; //这里注册我们需要的BPP Set&lt;BeanDefinitionHolder&gt; processorDefinitions = AnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source); for (BeanDefinitionHolder processorDefinition : processorDefinitions) &#123; compositeDef.addNestedComponent(new BeanComponentDefinition(processorDefinition)); &#125; &#125; readerContext.fireComponentRegistered(compositeDef); &#125; public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors( BeanDefinitionRegistry registry, Object source) &#123; Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(4); // @Configuration if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; //@Autowired @Value if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; //@Required if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; //@PostConsruct @Resouce 等java注解 // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor. if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; // // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor. if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(); try &#123; def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, AnnotationConfigUtils.class.getClassLoader())); &#125; catch (ClassNotFoundException ex) &#123; throw new IllegalStateException( &quot;Cannot load optional framework class: &quot; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex); &#125; def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; return beanDefs; &#125; 总的来说 component-scan 做了什么事情就比较清晰了 下面做一下总结 根据配置生成扫描类ClassPathBeanDefinitionScanner 扫描注册包下符合匹配规则的类 扫描注册被@Controller @Service @Respsitory @Component @Configuration等标注的类 因为@Controller @Service @Respsitory注解的元注解包含@Component 也就是说@Controller @Service @Respsitory本身被@Component标注 而匹配规则中有一条就是元注解包含@Component @Named 或者 @ManagedBean 注册处理如@Resouce @Autowired @PostConstruct等的BPP 当然由于篇幅限制 并没有把所有的知识点都讲到 很多也是点到 那些东西需要读者有时间的时候自己跟着代码走一遍了那么又出现一个问题：既然@Controller注解标注的类也被像普通bean一样注册了 那么在web项目中 又是怎么知道哪些是我们需要的Controller类呢?且听下回分析…","tags":[{"name":"component-scan","slug":"component-scan","permalink":"http://yoursite.com/tags/component-scan/"}]},{"title":"ClassPathXmlApplicationContext源码解析二:默认空间元素解析","date":"2017-04-21T12:15:44.000Z","path":"2017/04/21/ClassPathXmlApplicationContext源码解析二-默认空间元素解析/","text":"写在前面在 ClassPathXmlApplicationContext源码解析一 中 我们用了很长的篇幅 介绍了加载上下文环境前的各种准备工作 spring是个世界级的项目框架 由精英团队打造 全世界的测试人员测试 即使如果读者感觉有点吃力 对突然冒出来的代码有点不习惯的话 也不要气馁 继续往下读 刚阅读源代码的时候 最怕纠结于一些琐碎单却不重要的事情 下面我们看一下parseBeanDefinitions(root, this.delegate)方法12345678910111213141516171819202122232425262728//对于`delegate` 我们暂时只要知道这个类中含有我们需要的一些environment,beanfactory等信息就可以了 当然他还提供一些解析方法 protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; /** * 如果是默认命名空间 也就是&quot;http://www.springframework.org/schema/beans&quot;这个空间下的元素 调用parseDefaultElement * 否则调用parseCustomElement 例如aop context tx等标签的解析 * 也就是parseDefaultElement 解析import alias bean beans标签元素 * parseCustomElement 解析aop context tx 或者是用户自定义命名空间的元素 */ if (delegate.isDefaultNamespace(root)) &#123; NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) &#123; //继续这个方法研究 parseDefaultElement(ele, delegate); &#125; else &#123; delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; delegate.parseCustomElement(root); &#125; &#125; 我们这篇文章只看默认命名空间的解析 也就是http://www.springframework.org/schema/beans这个空间下的定义的元素定义 对于非默认空间下的元素的解析的话 请看component-scan做了些什么 这篇文章讲解了component空间下的元素解析1234567891011121314151617181920private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123; //解析import元素标签 通过调用`loadBeanDefinitions`模块方法完成元素加载&lt;import resource=&quot;url&quot;/&gt; if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; importBeanDefinitionResource(ele); &#125; //解析alias元素标签 &lt;alias name=&quot;&quot; alias=&quot;&quot; /&gt; else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; //注册别名 说白点就是把name alias的对应关系加入到一个map中 processAliasRegistration(ele); &#125; //解析bean元素标签 最核心 &lt;bean &gt; else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; processBeanDefinition(ele, delegate); &#125; //解析beans元素标签 又调用了`doRegisterBeanDefinitions(element)`方法去解析&lt;beans&gt; else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; // recurse doRegisterBeanDefinitions(ele); &#125;&#125; 到达这个方法的时候 ele代表的就是一个bean标签元素了 例如1&lt;bean id=&quot;&quot; class=&quot;&quot;&gt; 我们不必深入了解xml文档的解析 也是能看的懂的 当然如果了解解析的过程 是更好的了我们可以很清晰的看到beans空间下的元素标签有import alias bean beans 我们当然是重点讲解bean标签的解析了 继续跟踪代码123456789101112131415161718protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;//继续跟踪 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) &#123; //处理非默认命名空间的元素 如果有的话 这里不继续跟踪下去了 bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; // 也就是放到一个map中去 key为beanName value为BeanDefinition BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error(&quot;Failed to register bean definition with name &apos;&quot; + bdHolder.getBeanName() + &quot;&apos;&quot;, ele, ex); &#125; // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125;&#125; 跟踪进BeanDefinitionParserDelegate.parseBeanDefinitionElement方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123; String id = ele.getAttribute(ID_ATTRIBUTE); String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); //bean标签中的name其实会被划分成alias List&lt;String&gt; aliases = new ArrayList&lt;String&gt;(); if (StringUtils.hasLength(nameAttr)) &#123; String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); &#125; String beanName = id; if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123; beanName = aliases.remove(0); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;No XML &apos;id&apos; specified - using &apos;&quot; + beanName + &quot;&apos; as bean name and &quot; + aliases + &quot; as aliases&quot;); &#125; &#125; if (containingBean == null) &#123; //beanName唯一性校验 checkNameUniqueness(beanName, aliases, ele); &#125; AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);//GenericBeanDefinition if (beanDefinition != null) &#123; // 阅读源代码要做到有的放矢 像下面这样的代码就没有太大的必要去看了 if (!StringUtils.hasText(beanName)) &#123; try &#123; if (containingBean != null) &#123; beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); &#125; else &#123; beanName = this.readerContext.generateBeanName(beanDefinition); String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123; aliases.add(beanClassName); &#125; &#125; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Neither XML &apos;id&apos; nor &apos;name&apos; specified - &quot; + &quot;using generated bean name [&quot; + beanName + &quot;]&quot;); &#125; &#125; catch (Exception ex) &#123; error(ex.getMessage(), ele); return null; &#125; &#125; //返回BeanDefinitionHolder String[] aliasesArray = StringUtils.toStringArray(aliases); return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); &#125; return null;&#125; id 就是beanName了 必须要唯一才行 其实parseBeanDefinitionElement这个方法的目的就很明确了 就是要把bean的配置读取并保存起来 保存到GenericBeanDefinition中 例如我们常见的property constructor-arg等 无非就是构造合适的结构 然后读取数据并保存起来 供以后使用 虽然目的明确 但过程确实是很繁琐的 因为spring支持多种复杂数据结构 例如list map等我们就不再深入解读了 读者可以自己找几个解析方法阅读1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 在这个方法中会遇到我们之前可能没有遇到的标签/属性元素 最好的解决办法就是先搜索这个元素/属性的用法,然后再看解析, 再看他们的应用处理等 * 我们这里不对这些不常用的元素/属性进行详解 这里主要就是解析出来并保存到BeanDefinitiion中 */public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, BeanDefinition containingBean) &#123; this.parseState.push(new BeanEntry(beanName)); String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123; className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); &#125; try &#123; String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123; parent = ele.getAttribute(PARENT_ATTRIBUTE); &#125; //GenericBeanDefinition 设置className parentName变量 parent属性目前只是作为一个普通属性放倒BeanDefinition中去了 后面加载单例的时候会用到 AbstractBeanDefinition bd = createBeanDefinition(className, parent);// //解析元素属性 例如scope lazy-init factory-method等属性的解析 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); //解析元素子元素开始 bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); //&lt;meta key=&quot;&quot; value=&quot;&quot; /&gt; 作为对bd的额外参数使用 parseMetaElements(ele, bd); //&lt;lookup-method name=&quot;&quot; bean=&quot;&quot; /&gt; 插拔式设计 方法根据配置 动态返回不同的bean 感兴趣的可以自行搜索相关使用demo parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); //&lt;replaced-method name=&quot;&quot; replacer=&quot;&quot;/&gt; 根据配置 替换/更改原来的方法逻辑 interesting 感兴趣的可以自行搜索相关使用demo parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); //todo &lt;constructor-arg index=&quot;i&quot;&gt;&lt;/constructor-arg&gt; parseConstructorArgElements(ele, bd); //&lt;property name=&quot;&quot; value=&quot;&quot;/&gt; or more complex property such as list,map 阅读源代码 我们要有的放矢 // 没必要把每一行都看懂 就像下面的解析构造参数 与 property一样 都是很复杂的 但我们没必要都读懂才行 parsePropertyElements(ele, bd); //&lt;qualifier /&gt; parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; &#125; catch (ClassNotFoundException ex) &#123; error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex); &#125; catch (NoClassDefFoundError err) &#123; error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err); &#125; catch (Throwable ex) &#123; error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex); &#125; finally &#123; this.parseState.pop(); &#125; return null;&#125; 生成beanDefinition后 再用BeanDefinitionHolder封装后返回注册 至此xml配置文件中的设置就转化为了java对象保存我们在回到refresh()方法 继续往下看prepareBeanFactory()方法123456789101112131415161718192021222324252627282930313233343536373839404142434445protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; // Tell the internal bean factory to use the context&apos;s class loader etc. beanFactory.setBeanClassLoader(getClassLoader()); // beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver()); // 我们知道xml文档中的都是字符串形式的值 但我们可能需要的是其他的类型 比如Float Date等 // 这里注册一些常用的属性编辑器 去解决类型转化问题 beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); //BPP 作用是如果bean实现了Aware接口的话 自动调用`setXXX`方法 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); //忽略特殊类`ResourceLoaderAware` 等的依赖 beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); beanFactory.ignoreDependencyInterface(EnvironmentAware.class); // BeanFactory interface not registered as resolvable type in a plain factory. // MessageSource registered (and found for autowiring) as a bean. beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // Detect a LoadTimeWeaver and prepare for weaving, if found. // @AspectJ相关 不常用 后面会专门讲解Spring AOP if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123; beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // Set a temporary ClassLoader for type matching. beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); &#125; // Register default environment beans. if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123; beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); &#125; if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123; beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); &#125; if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123; beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); &#125;&#125; 代码里面的注释应该是很详细了 我们来分析一个很有趣的事情如果我们想在我们自己类中 获取如ApplicationContext的话 我们一般会继承ApplicationContextAware 然后有个回调方法会让我们实现 例如setApplicationContext 那么为什么我们只要实现了这个接口 我们实现的回调方法就会调用呢 奥秘就在这句代码beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this))BPP(BeanFactoryPostProcessor)是个很重要的知识点 我们这里大概了解一下 不管是单例模式还是原型模式 我们定义的class肯定是要实例化的 如果有定义初始化方法的话 还会调用初始化方法 对于一个类来说 实例化 初始化都是很重要的时间节点 我们的class又是托管给spring进行管理的 那么spring就有能力 有机会在这些时间节点前后添加一些处理方法 spring中代表这一类操作的接口是BeanPostProcessor 简称BPP 中文翻译是后置处理器 当然spring中还有一种PostProcessor是容器级别的 BeanFactoryPostProcessor 就是在容器加载前后做一些特殊的操作 在ApplicationContextAwareProcessor.postProcessBeforeInitialization(final Object bean, String beanName)方法中 会调用invokeAwareInterfaces(bean)方法1234567891011121314151617181920212223private void invokeAwareInterfaces(Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof EnvironmentAware) &#123; ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment()); &#125; if (bean instanceof EmbeddedValueResolverAware) &#123; ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver( new EmbeddedValueResolver(this.applicationContext.getBeanFactory())); &#125; if (bean instanceof ResourceLoaderAware) &#123; ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext); &#125; if (bean instanceof ApplicationEventPublisherAware) &#123; ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext); &#125; if (bean instanceof MessageSourceAware) &#123; ((MessageSourceAware) bean).setMessageSource(this.applicationContext); &#125; if (bean instanceof ApplicationContextAware) &#123; ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext); &#125; &#125;&#125; 看起来很神秘的东西 它的实现是不是很一般 而且还感觉有点low 竟然没有魔法","tags":[{"name":"context","slug":"context","permalink":"http://yoursite.com/tags/context/"}]},{"title":"ClassPathXmlApplicationContext源码解析一:准备工作","date":"2017-04-17T10:00:36.000Z","path":"2017/04/17/ClassPathXmlApplicationContext源码解析一/","text":"其实在web环境中 用到的上下文环境是 XmlWebApplicationContext 但其实对于我们要讲解的内容来说 核心逻辑是一样的 在后面讲解到web环境加载的时候 会讲到XmlWebApplicationContext类的解析 下面几篇博客的内容我们会介绍Spring是怎么构建上下文环境的 也就是ClassPathXmlApplicationContext的源码的过程ClassPathXmlApplicationContext类的测试类是ClassPathXmlApplicationContextTests 如果读者能好好利用这个测试类的话 能节省不少阅读源码的时间构造函数123456789 //接收配置文件的地址 默认刷新 父容器为null 讲解web环境加载的时候 会讲到父容器的概念public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException &#123; super(parent); setConfigLocations(configLocations); if (refresh) &#123; refresh(); &#125;&#125; 以后讲解web环境加载的时候我们会讲到父子容器的概念 这里只考虑父容器为null的情况 如果路径中含有如${user.dir}的变量 会被处理替换掉 对替换这部分感兴趣的读者可以深入阅读 然后就进入最重要的一个方法refresh()refresh()refresh()方法从总体上看 还算比较清晰 用几个大的方法高度概括了refresh()要完成的工作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. // 加载前的准备工作:active标记为true；资源必要性验证等 prepareRefresh(); // 创建DefaultListableBeanFactory 并加载配置文件 转化为BeanDefinition保存 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); prepareBeanFactory(beanFactory); try &#123; //empty postProcessBeanFactory(beanFactory); // spring扩展的实现(容器级别) BeanFactoryPostProcessor 在实例化任何用户定义的bean之前 会首先调用BFPP的接口方法 // 常见的BFPP:PropertyPlaceholderConfigurer invokeBeanFactoryPostProcessors(beanFactory); // spring可扩展的另一个实现:BeanPostProcessor 在调用bean的init-method方法的前后会调用接口方法 // 较常见的硬编码的BPP:ApplicationContextAwareProcessor,ApplicationListenerDetector registerBeanPostProcessors(beanFactory); //国际化 initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. //empty onRefresh(); // Check for listener beans and register them. // 注册listener registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. // 实例化所有的非懒惰加载的单例 finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt&quot;, ex); // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset &apos;active&apos; flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; &#125;&#125; 下面我们看obtainFreshBeanFactory()#AbstractRefreshableApplicationContext.refreshBeanFactory()方法(obtainFreshBeanFactory()方法中主要逻辑是在refreshBeanFactory()方法 我们就不再列出完整的obtainFreshBeanFactory()方法 以后这样的格式我们用#区分)再此感叹spring代码的优秀 每个方法都是那么的简短清晰 一层一层的深入12345678910111213141516171819202122protected final void refreshBeanFactory() throws BeansException &#123;// 如果已经加载过的话 先销毁再重新加载 if (hasBeanFactory()) &#123; destroyBeans(); closeBeanFactory(); &#125; try &#123; //实例化一个DefaultListableBeanFactory 这是一个很重要的类 DefaultListableBeanFactory beanFactory = createBeanFactory(); //设置id beanFactory.setSerializationId(getId()); customizeBeanFactory(beanFactory); loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) &#123; this.beanFactory = beanFactory; &#125; &#125; catch (IOException ex) &#123; throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex); &#125;&#125; 12345678910/** * 忽略BeanNameAware BeanFactoryAware BeanClassLoaderAware的依赖 spring有设置专门调用setXXX方法的地方 * Create a new AbstractAutowireCapableBeanFactory. */ public AbstractAutowireCapableBeanFactory() &#123; super(); ignoreDependencyInterface(BeanNameAware.class); ignoreDependencyInterface(BeanFactoryAware.class); ignoreDependencyInterface(BeanClassLoaderAware.class); &#125; 对于这样的代码 如果不跟踪进去的话 可能会对有些变量的值感到困惑createBeanFactory()实例化了一个DefaultListableBeanFactory 在实例化的过程中 其父类 AbstractAutowireCapableBeanFactory的构造函数注册了几个忽略依赖注入的接口 就是说以后对于bean的属性注入的时候 如果在我们注册的忽略接口里面的话 就不再依赖注入12345678910111213// protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123; //是否允许覆盖 if (this.allowBeanDefinitionOverriding != null) &#123; beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; //是否允许循环引用 循环引用是很重要的一个知识点 我们后面会专门讲解 if (this.allowCircularReferences != null) &#123; beanFactory.setAllowCircularReferences(this.allowCircularReferences); &#125; //设置Qualifier注解解析类 beanFactory.setAutowireCandidateResolver(new QualifierAnnotationAutowireCandidateResolver()); &#125; 我们看下beanFactory.setAutowireCandidateResolver(new QualifierAnnotationAutowireCandidateResolver())方法 这个方法就是设置autowireCandidateResolver变量 顺便做了一件事情 就是如果该变量继承了BeanFactoryAware的话 调用setBeanFactory()方法 我们从这里就可以看到sping代码优秀的另一个方面是约定习俗1234567891011121314151617181920public void setAutowireCandidateResolver(final AutowireCandidateResolver autowireCandidateResolver) &#123; Assert.notNull(autowireCandidateResolver, &quot;AutowireCandidateResolver must not be null&quot;); if (autowireCandidateResolver instanceof BeanFactoryAware) &#123; if (System.getSecurityManager() != null) &#123; final BeanFactory target = this; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; public Object run() &#123; ((BeanFactoryAware) autowireCandidateResolver).setBeanFactory(target); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; // 调用`setBeanFactory()`方法 this作为参数 ((BeanFactoryAware) autowireCandidateResolver).setBeanFactory(this); &#125; &#125; //设置变量 this.autowireCandidateResolver = autowireCandidateResolver;&#125; 下面就进入很重要的一个方法了AbstractXmlApplicationContext#loadBeanDefinitions(beanFactory); 载入配置文件 就是根据配置文件做相应的处理 例如将&lt;bean&gt;转化为BeanDefinition保存 这跟Tomcat将server.xml转化为StandardServer是一样的 阅读这部分代码并不需要你很了解是怎么解析xml文档的 因为方法包装的很好的 当然如果读者比较了解xml文档解析的话 那么就更好了 123456789101112131415protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123; // Create a new XmlBeanDefinitionReader for the given BeanFactory. XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context&apos;s // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // Allow a subclass to provide custom initialization of the reader, // then proceed with actually loading the bean definitions. initBeanDefinitionReader(beanDefinitionReader); loadBeanDefinitions(beanDefinitionReader);&#125; tips 前面几行代码一直在做准备工作 刚阅读源码的读者一定会被这错综复杂的关系所困扰 spring中模块众多,继承 组合关系也是错综复杂 第一次阅读的话 读者可不必太在意这些类之间的委托关系 跟着代码走就可以了 以后阅读第二遍第三遍的时候 再好好研究 比如到现在为止我们都是顺着代码走 并没有从代码设计的角度去讲解loadBeanDefinitions()方法最终会调用AbstractBeanDefinitionReader#loadBeanDefinitions()方法123456789101112131415161718192021222324252627282930313233343536373839404142public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException &#123;//ClassPathXmlApplicationContext ResourceLoader resourceLoader = getResourceLoader(); if (resourceLoader == null) &#123; throw new BeanDefinitionStoreException( &quot;Cannot import bean definitions from location [&quot; + location + &quot;]: no ResourceLoader available&quot;); &#125; if (resourceLoader instanceof ResourcePatternResolver) &#123; // Resource pattern matching available. try &#123; // 把String类型的地址封装成Resource类型 方便后续操作 Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location); int loadCount = loadBeanDefinitions(resources); if (actualResources != null) &#123; for (Resource resource : resources) &#123; actualResources.add(resource); &#125; &#125; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location pattern [&quot; + location + &quot;]&quot;); &#125; return loadCount; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( &quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex); &#125; &#125; else &#123; // Can only load single resources by absolute URL. Resource resource = resourceLoader.getResource(location); int loadCount = loadBeanDefinitions(resource); if (actualResources != null) &#123; actualResources.add(resource); &#125; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location [&quot; + location + &quot;]&quot;); &#125; return loadCount; &#125;&#125; 方法调用AbstractBeanDefinitionReader#loadBeanDefinitions(resource)#loadBeanDefinitions(encodedResource) 我们发现方法调来调去的 却一直没有看到我们想看的内容 一直做的都是准备工作 不急 慢慢来 我们继续往下看12345678910111213141516171819202122232425262728293031323334353637383940public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;); if (logger.isInfoEnabled()) &#123; logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource()); &#125; Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) &#123; currentResources = new HashSet&lt;EncodedResource&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); &#125; if (!currentResources.add(encodedResource)) &#123; throw new BeanDefinitionStoreException( &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;); &#125; try &#123; InputStream inputStream = encodedResource.getResource().getInputStream(); try &#123; InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding()); &#125; // return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); &#125; finally &#123; inputStream.close(); &#125; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex); &#125; finally &#123; currentResources.remove(encodedResource); if (currentResources.isEmpty()) &#123; this.resourcesCurrentlyBeingLoaded.remove(); &#125; &#125;&#125; 也是做各种准备工作 终于让我们遇到了我们想要看的代码doLoadBeanDefinitions 代码读到后面 读者就会注意到spring中以do开头的方法才是真正的核心逻辑的开始123456789101112protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException &#123; try &#123; //获取验证模式 dtd or xsd int validationMode = getValidationModeForResource(resource); //为SAX应用程序提供寻找本地验证文件(dtd/xsd文件) 并将配置文件加载为document保存 Document doc = this.documentLoader.loadDocument( inputSource, getEntityResolver(), this.errorHandler, validationMode, isNamespaceAware()); return registerBeanDefinitions(doc, resource); &#125; ......&#125; 当然还是山路十八弯123456789public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;//DefaultBeanDefinitionDocumentReader BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); documentReader.setEnvironment(getEnvironment()); int countBefore = getRegistry().getBeanDefinitionCount(); // documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125; 1234567public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; this.readerContext = readerContext; logger.debug(&quot;Loading bean definitions&quot;); Element root = doc.getDocumentElement(); //解析的核心部分开始 doRegisterBeanDefinitions(root);&#125; 12345678910111213141516171819protected void doRegisterBeanDefinitions(Element root) &#123; String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);//profile attribute if (StringUtils.hasText(profileSpec)) &#123; String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; return; &#125; &#125; BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(this.readerContext, root, parent); preProcessXml(root); parseBeanDefinitions(root, this.delegate); postProcessXml(root); this.delegate = parent;&#125; 在方法createDelegate(this.readerContext, root, parent);中 通过populateDefaults()方法设置了一些例如default-lazy-init default-autowire的值 如果根元素中有设置这些变量的话 将会覆盖默认值 起到全局变量的作用preProcessXml(root) postProcessXml(root)都被留空 留给子类实现终于 finally 最终 我们看到了我们一直想看到的代码的影子 parseBeanDefinitions(root, this.delegate)要知后事如何 且听下回分解","tags":[{"name":"context","slug":"context","permalink":"http://yoursite.com/tags/context/"}]},{"title":"Tomcat源码分析环境搭建","date":"2017-04-16T07:18:00.000Z","path":"2017/04/16/Tomcat源码分析环境搭建/","text":"阅读源码的第一步就是把环境搭建起来 并能够调试 这样在某些情况下 能帮助你更好的阅读源代码 看起来比较直观 在这一点上 我将再次推荐idea这款集成开发环境 简直是神器 安利网上也有比较多的教程教你怎么把tomcat源代码导入到idea中的教程 我就不再浪费时间在重复写了 我当初也是按着那样的步骤来的 相信读者这些应该是自己能够搞定的我就直接把我搭建好的push到了我的github上面 上面有两个分枝 一个是master分支 这个分支是纯净版的 也就是没有我的注释的版本 另外一个分支是tomcat-with-docs 这个分支是我后来阅读源码的过程中写的注释 以后我会出一系列tomcat源码解析的教程所以 如果你想看纯净版的1$ git clone git@github.com:sunmingshuai/apache-tomcat-7.0.73-src.git 或者你想看有注释的1$ git clone -b tomcat-with-docs git@github.com:sunmingshuai/apache-tomcat-7.0.73-src.git 然后当成maven项目导入到idea中就可以了","tags":[]},{"title":"搭建spring web项目供debug使用","date":"2017-04-16T06:58:58.000Z","path":"2017/04/16/搭建spring-web项目供debug使用/","text":"随着阅读源码的深入 越来越了解debug的重要性 要让代码跑起来 想想自己也是阅读了Spring的核心功能模块 搭建起来应该不费劲 顺便说说感受想想刚毕业那会 进到公司 上手的都是已经搭建好的体系 这个阶段属于依胡萝画瓢阶段后来自己上网搜索搭建教程 虽然也能搭建好 但还是不了解其意 仍然是依胡萝画瓢阶段现在刚好有要搭建spring web项目 供我debug的需求 所以就花点时间搭建了一个 总的来说 比较顺畅 而且基本上每个配置都知道它到底干了什么 给我的感觉不一样了我debug总的来说有2个方面 打包放到tomcat的webapps目录 研究tomcat的源码 启动web项目 研究spring源码 具体的搭建过程我就不说了 我搭建的比较简洁 完全为了debug搭建的 没有多余代码 push到了github仓库 感兴趣的可以clone到本地使用 1$ git clone git@github.com:sunmingshuai/springmvcdemo.git 当成maven项目导入到idea/eclipse就可以了以后有需求的话 会不断的加入一些功能并推送","tags":[]},{"title":"2017阅读书单(持续更新)","date":"2017-04-16T05:46:48.000Z","path":"2017/04/16/2017阅读书单/","text":"技术书单 How Tomcat Works Spring源码深度解析 ActiveMQ in Action 成长 巨婴国 被嫌弃的松子的一生 丘吉尔:我的早年生活 梦幻花 如何阅读一本书 黄金时代 月亮与六便士 枪炮 病菌与钢铁","tags":[]},{"title":"Spring源码分析环境搭建","date":"2017-04-15T13:28:22.000Z","path":"2017/04/15/Spring源码环境搭建/","text":"想研究spring源码的第一步当然是源码的搭建 推荐大家使用idea集成开发环境 下面的搭建过程也以idea为基础需要gradle git环境 不再叙述从github仓库中clone一份代码到本地git clone -b 3.2.x git@github.com:spring-projects/spring-framework.git这里需要注意的是你所使用的jdk版本与spring源码所需要的版本的匹配问题 如果你使用的jdk版本是1.7 而clone的是4以上的spring源码的话 那么comiple的时候就会报错查看源码目录下的 import-into-idea.md 文件 发现步骤可真简单 到spring源码的目录下cd your_spring_dir 执行命令 ./gradlew :spring-oxm:compileTestJava cleanIdea idea 这个过程可能比较慢 感觉卡住的话 ctrl+c 结束执行再重新执行命令 多试几次就好了 导入idea","tags":[]},{"title":"当我谈源码时,我谈些什么","date":"2017-04-15T07:06:19.000Z","path":"2017/04/15/当我谈源码时-我谈些什么/","text":"我们为什么要阅读源码 | 阅读源码给我们带来了什么 简单方面来说，阅读源码使我们更了解所使用的框架，深入其实现原理 更深入方面，我觉得阅读源码是一次提升的机会，提升自己抽象能力，学习大师们解决问题的思路. 阅读源码常见误区 每行代码都要搞懂是什么意思对于一个开源框架 以Tomcat 或者 Spring源码来说 每行代码都要理解的话 一方面会需要大量的时间 另一方面可能会被琐碎但又不那么重要的代码逻辑缠住 可谓是：捡了芝麻 丢了西瓜 要做到: 有的放矢 阅读源码的方法不对阅读源码并不是说把源码导入到集成开发环境中 就不管三七二十一的看起来 要找到切入点 借助开发工具提供的能力 多看看类的层次结构 多思考 学习大牛的抽象能力与分解|解决问题的能力 这两个能力在Tomcat，Spring源码中会达到让你惊叹的地步","tags":[]},{"title":"Unknown system variable 'storage_engine'解决办法","date":"2017-04-14T03:02:18.000Z","path":"2017/04/14/Unknown-system-variable-storage-engine-解决办法/","text":"安装MySQL employees数据库，出现问题，mysql版本为：mysql Ver 14.14 Distrib 5.7.10, for Linux (x86_64) using EditLine wrapper mysql默认的数据库存储引擎是innodb,正好出错的也是这行，提示没有storage_engine变量。好像14以后的msql storage_engine变量更名为default_storage_engine，可是我更改为set default_storage_engine = innodb,还是这行出错，没办法，只能注释掉这样了，反正默认就是innodb引擎。下面说注意事项： 在employees.sql文件中，注释掉(也就是让这行不生效)的时候除了在这行的最前面加’–’外，’–’要跟后面的字符空一个格才生效。即 12345678-- set default_storage_engine = InnoDB -- set storage_engine = InnoDB; -- set storage_engine = MyISAM; -- set storage_engine = Falcon; -- set storage_engine = PBXT; -- set storage_engine = Maria; -- select CONCAT(&apos;storage engine: &apos;, @@storage_engine) as INFO; 不要忘了把INFO那行注释掉，其实这行只是安装的时候提示你安装到哪里了，如果出错的话，好排查。像上面那样注释掉后，再安装就可以了.","tags":[]},{"title":"mac安装sequelpro","date":"2017-04-14T02:55:49.000Z","path":"2017/04/14/mac安装sequelpro/","text":"mac安装sequelpro遇到的问题： 不像其他dmg镜像一样 打开后有一个拖到应用程序的界面 下载sequelpro后 只能以挂载镜像的方式打开 这样的话 倒是可以用 但一直有一个挂载镜像在哪 不舒服 找来找去还是靠一句英文搞定的: how to install sequelpro on mac 然后让我找到了下面一个地址 http://macappstore.org/sequel-pro/照着上面的提示总算安装好了 不过过程中还是遇到了一些问题，安装brew的时候出现了问题 建议去homebrew官网去 官网有安装命令 照着那个安装 可能会因为网络因素什么的 会安装失败 多试几次就好了 终于安装成功 国人的博客啊 很多还是抄来抄去的 不着调 看来跟学生时代 作业抄多了有关系 学习英文 没坏处","tags":[]},{"title":"nginx反向代理解决mac上tomcat80端口问题","date":"2017-04-14T02:47:14.000Z","path":"2017/04/14/nginx反向代理解决mac上tomcat80端口问题/","text":"后来发现一个比较容易的解决方案 灵光乍现 orz…这个方法不用nginx去解决 只要绑定hosts就可以了 tomcat绑定不了80端口 那么我们绑定8080端口 然后在hosts中绑定 1$ 127.0.0.1:8080 yourwebsite 在这里安利大家一个好用的编辑hosts的chrome插件 Host Switch Plus 不担心缓存 使用方便问题背景：mac的1024以下端口管理比较严格，搞了好久也没能让本地tomcat开启80端口，开启其他大于1024端口的倒是可以，但是这样不利用访问，访问web的时候，需要每次都带着端口访问，链接跳着跳着端口就有问题了，后来稍微了解了下nginx的知识，着手用nginx的反向代理能力去解决此问题。大概思路是让nginx开启80端口(这个倒是可以开启80端口 orz) 然后遇到自己设置的servername的时候再反向代理到本地tomcat开启的端口，比如8080 或者9090端口 mac安装nginx的功能就再说了，可以用brew安装也可以编译安装，自行百度，我好像是用brew安装的 我web开发工具用的是idea,怎么建tomcat也不说了，不是这篇文章的目的,tomcat的端口的话就用默认的8080就可以了。 修改nginx的配置文件nginx.conf 如果路径不一样的，自行更改 1$ sudo vim /usr/local/etc/nginx/nginx.conf 重要的都用箭头标出来了 listen 80：表示nginx监听80端口 server_name : 可以有多个 这里需要注意的是 每个域名要在hosts文件中绑定IP到127.0.0.1 不然还是拦截不到的 这点需要注意 access_log: 访问日志 可以打开 打开的话要把后面的main去掉 location： / 拦截所有访问本地80端口的路径 这是个正则表达式 有兴趣的可以去搜搜看 可以写成其他的正则 proxy_pass http://127.0.0.1:8080 这句就是核心了 将访问的80端口导到本地的8080端口(我的本地tomcat开启的端口) 开启nginx 1$ sudo nginx 大功告成！","tags":[]},{"title":"mysql禁用validate_password插件","date":"2017-04-14T02:36:01.000Z","path":"2017/04/14/mysql禁用validate_password插件/","text":"新版本的MySQL默认开启了validate_password插件，进行密码验证，需要很强的密码强度才能通过认证，如果是自己玩玩的话没必要那么复杂，如果是公司的话，还是不要禁用了。其实关闭插件很简单，在mysql配置文件(centos系统下是/etc/my.conf)里面[mysqld]选项下面添加下面一条语句即可 1validate_password=off 记得配置后要重启mysql.在shell下面运行下面两条语句： 12service mysqld stop service mysqld start 如果不想关闭，而是想修改密码强度的话，可以看看下面这篇文档，我就不多做解释了。http://dev.mysql.com/doc/refman/5.6/en/validate-password-plugin.html#option_mysqld_validate-password","tags":[]}]